<!doctype html><html lang="en-us">
<head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="In Manual maze, we define the block data structure and use it to draw a maze. If you can generate th...">

<meta property="og:locale" content="en_US">
<meta property="og:title" content="Binary tree algorithm">
<meta property="og:type" content="article">
<meta property="og:url" content="https://openhome.cc/eGossip/OpenSCAD/SimpleGeneratedMaze.html">
<meta property="og:image" content="https://openhome.cc/Gossip/images/caterpillar_small.jpg">
<meta property="og:site_name" content="OPENHOME.CC">
<meta property="og:description" content="In Manual maze, we define the block data structure and use it to draw a maze. If you can generate th...">

    <title>Binary tree algorithm</title>

<link rel="stylesheet" href="http://openhome.cc/Gossip/css/pure-0.6.0/pure-min.css">

    <!--[if lte IE 8]>
        <link rel="stylesheet" href="../../Gossip/css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="http://openhome.cc/Gossip/css/layouts/side-menu.css">
    <!--<![endif]-->
  

     <link rel="stylesheet" href="http://openhome.cc/Gossip/css/caterpillar.css">
     <script async src="http://openhome.cc/Gossip/google-code-prettify/run_prettify.js"></script>
<!-- 網頁層級廣告 --><script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle =window.adsbygoogle || []).push({google_ad_client: "ca-pub-9750319131714390",enable_page_level_ads: true });</script></head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="SimpleGeneratedMaze.html#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
    <div id="menu">
        <div class="pure-menu">
            <a class="pure-menu-heading" href="http://openhome.cc/eGossip/OpenSCAD/index.html">&lt;&lt; OpenSCAD TOC</a>
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><br><div class="social" style="text-align: center;"><a href="http://twitter.com/caterpillar"><img title="Twitter" alt="Twitter" src="../../Gossip/images/twitter.png"></a> <a href="http://www.facebook.com/openhome.cc"><img title="Facebook" alt="Facebook" src="../../Gossip/images/facebook.png"></a> </div><br> <div id="search box"><script>(function() {var cx = 'partner-pub-9750319131714390:3926766884';var gcse = document.createElement('script');gcse.type = 'text/javascript';gcse.async = true;gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(gcse, s);})();</script><gcse:searchbox-only></gcse:searchbox-only></div><br><div class="ad" style="text-align: center;"><script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 2015 新版型 160 x 600 廣告 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:600px"
     data-ad-client="ca-pub-9750319131714390"
     data-ad-slot="3747048883"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div></li>
            </ul>
        </div>
    </div>

    <main id="main">
        <header class="header">
            <h1>Binary tree algorithm</h1>
        </header>

        <article class="content">
            <br><div class="ad-3" style="text-align: center;"><script async="" src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型回應式廣告 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="7104125683" data-ad-format="auto"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div> 
            
            <p>In <a href="ManualMaze.html">Manual maze</a>, we define the block data structure and use it to draw a maze. If you can generate the block data automatically, the maze will have a different path. There are many maze algorithms. Here, I'll introduce the easiest binary tree algorithm.</p>
<h1>Binary tree algorithm</h1>
<p>The concept behind binary tree algorithm is easy, but it also has an apparent defect which we'll see soon. However, it helps us to understand why we can generate a maze automatically. The generated maze is a perfect maze, which means it has exactly one path between any two blocks.</p>
<p>Take a 4x4 maze for example. First, draw a maze with no wall carved. We start from the lower-left block.</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/SimpleGeneratedMaze-1.JPG" alt="Binary tree algorithm"  /></div></div></p>
<p>Now, let's flip a coin. If it's &ldquo;heads&rdquo;, we carve the right wall, otherwise, the upper wall. Then, we can move to the next block. For example, we get &ldquo;tails&rdquo; first.</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/SimpleGeneratedMaze-2.JPG" alt="Binary tree algorithm"  /></div></div></p>
<p>It doesn't matter which one is the next block. Binary tree algorithm doesn't care about it. For convenience, we always move to the right block if possible. Suppose we get &ldquo;heads&rdquo; and &ldquo;tails&rdquo; after two coin flipping. The status of the maze is:</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/SimpleGeneratedMaze-3.JPG" alt="Binary tree algorithm"  /></div></div></p>
<p>We've reached the rightmost column. What should we do now? You cannot carve the right wall if it's not an exit. For the rightmost column, we cut their upper walls directly without flipping a coin.</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/SimpleGeneratedMaze-4.JPG" alt="Binary tree algorithm"  /></div></div></p>
<p>Similarly, we cannot remove the upper wall of the uppermost row. We directly cut their right walls.</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/SimpleGeneratedMaze-5.JPG" alt="Binary tree algorithm"  /></div></div></p>
<p>Now, let's deal with the remaining blocks. We back to the (1, 2) block first.</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/SimpleGeneratedMaze-6.JPG" alt="Binary tree algorithm"  /></div></div></p>
<p>Suppose we get &ldquo;heads&rdquo;, move to the right block, get &ldquo;tails&rdquo;, move to the right block, and then get &ldquo;tails&rdquo;.</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/SimpleGeneratedMaze-7.JPG" alt="Binary tree algorithm"  /></div></div></p>
<p>There's still one row we have to carve. Let's start from the leftmost block. This time, we get three &ldquo;heads&rdquo;.</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/SimpleGeneratedMaze-8.JPG" alt="Binary tree algorithm"  /></div></div></p>
<p>Ya, we create a maze!</p>
<h1>Is it a binary tree?</h1>
<p>We can draw paths on the generated maze.</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/SimpleGeneratedMaze-9.JPG" alt="Binary tree algorithm"  /></div></div></p>
<p>Now remove all walls and rotate the paths 45 degrees.</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/SimpleGeneratedMaze-10.JPG" alt="Binary tree algorithm"  /></div></div></p>
<p>It's a binary tree, right? Every time we decide to carve a wall, we select a parent node. If you look inversely, a parent node has at most two child nodes. It's undoubtedly a binary tree, and the upper-left block is the root. In a binary tree, any two nodes have exactly one path. No matter what maze algorithm, it'll form a tree structure if it generates a perfect maze. There's no loop on these mazes.</p>
<p>And you might find that binary tree algorithm has a bias. Suppose you start from the root, you can reach any child node if you only go left or down.</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/SimpleGeneratedMaze-11.JPG" alt="Binary tree algorithm"  /></div></div></p>
<p>Inversely, suppose that the left-lower block is the starting point and the upper-right block is an exit, you can easily find a way through the maze by only going right or up.</p>
<p>We can add more rules or randoms to improve the bias. For example, I'll show how to walk randomly and carve the wall we encounter in the later doument.</p>
<p>Different algorithms will bring different mazes. If you are interested in maze algorithms, I suggest the book <a href="https://pragprog.com/book/jbmaze/mazes-for-programmers">Mazes for Programmers</a>.</p>
<h1>Implementing binary tree algorithm</h1>
<p>In OpenSCAD, we define a function to simulate coin flipping first.</p>
<pre class="prettyprint"><code lang="openscad">function flip_coin() = round(rands(0, 1, 1)[0]) + 1;
</code></pre>
<p>The <code>rands</code> function is a built-in function of OpenSCAD. You can pass the random number range and the number of random numbers to return a vector. For example, <code>rands(n, m, x)</code> returns a vector containing <code>x</code> random numbers range from <code>n</code> to <code>m</code>. Therefore, <code>rands(0, 1, 1)[0]</code> generate a random number between 0 and 1.</p>
<p>The built-in <code>round</code> function returns the closest integer. Thus, <code>round(rands(0, 1, 1)[0])</code> gets either 1 or 0. We add 1 to it so <code>flip_coin</code> returns either 1 or 2, which correspond with the wall constant <code>UP_WALL</code> or <code>RIGHT_WALL</code> respectively.</p>
<p>Then, we flip a coin for each block. Remember, you don't have to flip for the rightmost column and the uppermost row.</p>
<pre class="prettyprint"><code lang="openscad">function binary_tree_block(x, y, rows, columns) = 
    y == rows ? block_data(x, y, 1) : (        // the uppermost row
        x == columns ? block_data(x, y, 2) :   // the rightmost column
            block_data(x, y, flip_coin())      // flip a coin
    );
</code></pre>
<p>We go through the maze from left to right and lower to upper to generate all blocks.</p>
<pre class="prettyprint"><code lang="openscad">function binary_tree_algorithm(rows, columns) = 
    [
        for(y = [1:rows]) 
            for(x = [1:columns]) 
                binary_tree_block(x, y, rows, columns)
    ];
</code></pre>
<p>The following list all code for generating a maze. We don't change any code developed in <a href="ManualMaze.html">Manual maze</a> for representation and only use binary tree algorithm to generate the block data referred by <code>maze_blocks</code>.</p>
<pre class="prettyprint"><code lang="openscad">module line(point1, point2, width = 1, cap_round = true) {
    angle = 90 - atan((point2[1] - point1[1]) / (point2[0] - point1[0]));
    offset_x = 0.5 * width * cos(angle);
    offset_y = 0.5 * width * sin(angle);

    offset1 = [-offset_x, offset_y];
    offset2 = [offset_x, -offset_y];

    if(cap_round) {
        translate(point1) circle(d = width, $fn = 24);
        translate(point2) circle(d = width, $fn = 24);
    }

    polygon(points=[
        point1 + offset1, point2 + offset1,  
        point2 + offset2, point1 + offset2
    ]);
}

module polyline(points, width = 1) {
    module polyline_inner(points, index) {
        if(index &lt; len(points)) {
            line(points[index - 1], points[index], width);
            polyline_inner(points, index + 1);
        }
    }

    polyline_inner(points, 1);
}

// Wall constants

NO_WALL = 0;    
UP_WALL = 1;  
RIGHT_WALL = 2;  
UP_RIGHT_WALL = 3; 

function block_data(x, y, wall_type) = [x, y, wall_type];
function get_x(block_data) = block_data[0];
function get_y(block_data) = block_data[1];
function get_wall_type(block_data) = block_data[2];

module draw_block(wall_type, block_width, wall_thickness) {
    if(wall_type == UP_WALL || wall_type == UP_RIGHT_WALL) {
        // the upper wall
        polyline(
            [[0, block_width], [block_width, block_width]], wall_thickness
        ); 
    }

    if(wall_type == RIGHT_WALL || wall_type == UP_RIGHT_WALL) {
        // the right wall
        polyline(
            [[block_width, block_width], [block_width, 0]], wall_thickness
        ); 
    }
}

module draw_maze(rows, columns, blocks, block_width, wall_thickness) {
    for(block = blocks) {
        // move the block to its correspond position
        translate([get_x(block) - 1, get_y(block) - 1] * block_width) 
            draw_block(
                get_wall_type(block), 
                block_width, 
                wall_thickness
            );
    }

    // the lowermost wall
    polyline(
        [[0, 0], [block_width * columns, 0]], 
        wall_thickness);
    // the leftmost wall
    polyline(
        [[0, block_width], [0, block_width * rows]], 
        wall_thickness);
} 

block_width = 3;
wall_thickness = 1;
maze_rows = 10;
maze_columns = 10; 

function flip_coin() = round(rands(0, 1, 1)[0]) + 1;

function binary_tree_block(x, y, rows, columns) = 
    y == rows ? block_data(x, y, 1) : (        // the uppermost row
        x == columns ? block_data(x, y, 2) :   // the rightmost column
            block_data(x, y, flip_coin())      // flip a coin
    );

function binary_tree_algorithm(rows, columns) = 
    [
        for(y = [1:rows]) 
            for(x = [1:columns]) 
                binary_tree_block(x, y, rows, columns)
    ];

maze_blocks = binary_tree_algorithm(maze_rows, maze_columns);

draw_maze(
    maze_rows, 
    maze_columns, 
    maze_blocks, 
    block_width, 
    wall_thickness
);
</code></pre>
<p>Now, you can change the value of <code>maze_rows</code> or <code>maze_columns</code> to generate a bigger maze. If your friends don't know binary tree algorithm, it should be enough to deceive them :p</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/SimpleGeneratedMaze-12.JPG" alt="Binary tree algorithm"  /></div></div></p>

            
           <br><br><div class="ad336-280" style="text-align: center;"><script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型廣告 336 x 280 --><ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-9750319131714390" data-ad-slot="9976409681"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div><br><div class="recommend" style="text-align: center;"><hr><script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 自動大小回應相符內容 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="4953478487" data-ad-format="autorelaxed"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>
        </article></main></div></body>
<script src="http://openhome.cc/Gossip/js/ui.js"></script>
</html>
<div class="analytics"><script async src="https://www.googletagmanager.com/gtag/js?id=G-QVQQYFSC8J"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-QVQQYFSC8J');</script></div>
