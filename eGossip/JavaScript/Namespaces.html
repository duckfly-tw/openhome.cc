<!doctype html><html lang="en-us">
<head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="JavaScript doesn't provide built-in support for namespaces. Every variable is an object property. A ...">

<meta property="og:locale" content="en_US">
<meta property="og:title" content="Namespaces">
<meta property="og:type" content="article">
<meta property="og:url" content="https://openhome.cc/eGossip/Blog/Namespaces.html">
<meta property="og:image" content="https://openhome.cc/Gossip/images/caterpillar_small.jpg">
<meta property="og:site_name" content="OPENHOME.CC">
<meta property="og:description" content="JavaScript doesn't provide built-in support for namespaces. Every variable is an object property. A ...">


    <title>Namespaces</title>

<link rel="stylesheet" href="http://openhome.cc/Gossip/css/pure-0.6.0/pure-min.css">

    <!--[if lte IE 8]>
        <link rel="stylesheet" href="../../Gossip/css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="http://openhome.cc/Gossip/css/layouts/side-menu.css">
    <!--<![endif]-->
  

     <link rel="stylesheet" href="http://openhome.cc/Gossip/css/caterpillar.css">
     <script async src="http://openhome.cc/Gossip/google-code-prettify/run_prettify.js"></script>
<!-- 網頁層級廣告 --><script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle =window.adsbygoogle || []).push({google_ad_client: "ca-pub-9750319131714390",enable_page_level_ads: true });</script></head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="Namespaces.html#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
    <div id="menu">
        <div class="pure-menu">
            <a class="pure-menu-heading" href="index.html">&lt;&lt; JavaScript TOC</a>
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><br><div class="social" style="text-align: center;"><a href="http://twitter.com/caterpillar"><img title="Twitter" alt="Twitter" src="../../Gossip/images/twitter.png"></a> <a href="http://www.facebook.com/openhome.cc"><img title="Facebook" alt="Facebook" src="../../Gossip/images/facebook.png"></a> </div><br><div id="search box"><script>(function() {var cx = 'partner-pub-9750319131714390:3926766884';var gcse = document.createElement('script');gcse.type = 'text/javascript';gcse.async = true;gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(gcse, s);})();</script><gcse:searchbox-only></gcse:searchbox-only></div><br><div class="ad" style="text-align: center;"><script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 2015 新版型 160 x 600 廣告 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:600px"
     data-ad-client="ca-pub-9750319131714390"
     data-ad-slot="3747048883"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div></li>
            </ul>
        </div>
    </div>

    <main id="main">
        <header class="header">
            <h1>Namespaces</h1>
        </header>

        <article class="content"><br><div class="ad-3" style="text-align: center;"><script async="" src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型回應式廣告 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="7104125683" data-ad-format="auto"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div> 
            

      <br>
      JavaScript doesn't provide built-in support for namespaces. Every variable is an object property. A global variable is the property of the global object; a variable declared by <span

        class="courier">var</span> is the property of the call object. <br>
      <br>
      Name conflicts arise easily in JavaScript; even in the same js file. For example, one day you wrote a <span

        class="courier">validate</span> function; someday one takes over your code and write another <span

        class="courier">validate</span> function somewhere in the same file. <br>
      <blockquote><strong><span class="courier">function validate() {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; // .. do some validation</span><br>
          <span class="courier">}</span><br>
          <span class="courier">// a long..long program</span><br>
          <span class="courier">// someday...someone</span><br>
          <span class="courier">function validate() {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; // .. do another validation</span><br>
          <span class="courier">}</span><br>
        </strong></blockquote>
      Unfortunately, the later <span class="courier">validate</span> function overwrites the previous one. This might cause original features to fail. <br>
      <br>
      One of the JavaScript namespace strategies, basically, lets the function be the property of an object. Generally, a meaningful name for organization or a department is used to refer to that object. For example: <br>
      <blockquote><strong><span class="courier">var openhome = {};&nbsp; // creat a unique namespace</span><br>
          <span class="courier">function validate() {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; // .. do some validation</span><br>
          <span class="courier">}</span><br>
          <span class="courier">openhome.validate = validate;</span><br>
        </strong></blockquote>
      To call the <span class="courier">validate</span> function, you can do as follow:&nbsp; <br>
      <blockquote><strong><span class="courier">openhome.validate();</span></strong><br>
      </blockquote>
      Others might give similar consideration when defining functions. For example, one might define as follows in the same js file.<br>
      <blockquote><strong><span class="courier">var caterpillar = {}; // create a unique namespace</span><br>
          <span class="courier">function validate() {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; // .. do some validation</span><br>
          <span class="courier">}</span><br>
          <span class="courier">caterpillar.validate = validate;</span></strong><br>
      </blockquote>
      To invoke it, as follows: <br>
      <blockquote><strong><span class="courier">caterpillar.validate();</span></strong><br>
      </blockquote>
      This way avoids the variable overriding problem. Perhaps the above name conflicts are rare in one js file, this generally happens when two js files come from different origination or programmers.<br>
      <br>
      People from the same organization might use the same name as a namespace. If you write the following in a.js: <br>
      <blockquote><strong><span class="courier">var openhome = {}; // create a namespace</span><br>
          <span class="courier">function validate() {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; // .. do some validation</span><br>
          <span class="courier">}</span><br>
          <span class="courier">openhome.validate = validate;</span><br>
        </strong></blockquote>
      Another writes the following b.js:<br>
      <blockquote><strong><span class="courier">var openhome = {}; // create a namespace</span><br>
          <span class="courier">function format() {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; // .. do some formatting</span><br>
          <span class="courier">}</span><br>
          <span class="courier">openhome.format = format;</span></strong><br>
      </blockquote>
      What happens if one page includes both a.js and b.js? If b.js is included later, <span

        class="courier">openhome.validate</span> is not available. When creating a namespace, you can test the existence of the namespace object; if there's one, use it directly; if not, create a new object as the namespace. For example, a.js may be revised as follows: <br>
      <blockquote><strong><span class="courier">var openhome = openhome || {};</span><br>
          <span class="courier">function validate() {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; // .. do some validation</span><br>
          <span class="courier">}</span><br>
          <span class="courier">openhome.validate = validate;</span><br>
        </strong></blockquote>
      Such way; a new object is created only if <span class="courier">openhome</span> is <span

        class="courier">undefined</span>. The b.js may be revised in a similar way to avoid the above name conflict. <br>
      <br>
      Avoid using global variables when writing JavaScript. Does the above example have the problem? Yes! There're two global names in the a.js; one is <span

        class="courier">openhome </span>and the other is <span class="courier">validate</span>. Remember! When defining a function in the global scope, the function name is a property of the global object. You can revise the code as follows: <br>
      <blockquote><strong><span class="courier">var openhome = openhome || {};</span><br>
          <span class="courier">openhome.validate = function() {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; // do some validation</span><br>
          <span class="courier">};</span><br>
        </strong></blockquote>
      But, it's not convenient if this function can also be a property of another object. There's a beautiful way to solve this problem. For example:&nbsp; <br>
      <blockquote><strong><span class="courier">var openhome = openhome || {};</span><br>
          <span class="courier">(function() {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; function validate() {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // do some validation</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; }</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; openhome.validate = validate;</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; // ... other code ...</span><br>
          <span class="courier">})();</span></strong><br>
      </blockquote>
      It seems complex at first glance. We can look at it step by step. First, we write...<br>
      <blockquote><strong><span class="courier">function() {</span><br>
          <span class="courier">}</span><br>
        </strong></blockquote>
      This is a function literal and no variable refers to it, so there's nothing stepping into the global namespace. Then ...<br>
      <blockquote><strong><span class="courier">(function() {</span></strong><br>
        <strong><span class="courier">})</span></strong><br>
      </blockquote>
      Parentheses define the order of operations and evaluate the function literal as a function instance. Then...<br>
      <blockquote><strong><span class="courier">(function() {</span></strong><br>
        <strong><span class="courier">})();</span></strong><br>
      </blockquote>
      The final parentheses indicate calling the evaluated function. You can create local functions in the function literal. <br>
      <blockquote><strong><span class="courier">var openhome = openhome || {};</span><br>
          <span class="courier">(function() {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; function validate() { // validate is local</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // do some validation</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; }</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; openhome.validate = validate;</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; // ... other code ...</span><br>
          <span class="courier">})();</span><br>
        </strong></blockquote>
      The <span class="courier">validate</span> function doesn't invade the global namespace because it's local. Finally, only the name <span

        class="courier">openhome</span> exists in the global scope. Patterns like this are broadly used in the world of JavaScript; generally used in a js file for module initialization.<br>
      <br>
      When designing a library, there's one convention if you want to avoid name conflicts from others. For example, if you want to prevent one from overwriting your name <span

        class="courier">global</span>, you can do as follows: <br>
      <blockquote><strong><span class="courier">(function(global) {</span><br>
          <span class="courier">&nbsp;&nbsp; var global.openhome = global.openhome || {};</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; ...</span><br>
          <br>
          <span class="courier">})(this);</span><br>
        </strong></blockquote>
      Maybe that is because you're not sure where your anonymous function will be initialized; you want to use the name <span

        class="courier">global</span> but are afraid of being occupied by someone else. If you use the above way in a browser, the real object referred by <span

        class="courier">this</span> will be passed to the parameter <span

        class="courier">global</span>. The parameter <span class="courier">global</span> is a local variable so this way avoids name conflicts from other libraries. <br>
      <br>
      Even file names suffer from name conflicts. A file name may have an organization-related prefix, such as "openhome.formutil.js", "caterpillar.formutil.js" and so on, to avoid file name conflicts. <br>
      <br>
      Deep namespace hierarchies might also be a problem. For example: <br>
      <blockquote><strong><span class="courier">openhome.book.web.some = 'some';</span></strong><br>
        <strong><span class="courier">openhome.book.web.other = 'other';</span></strong><br>
        <strong><span class="courier">openhome.book.web.another = 'another';</span></strong><br>
      </blockquote>
      Deep namespace hierarchies are not only troublesome but the successive dot operators also have a performance problem. JavaScript has a hard time optimizing successive dot operators. (Statically typed languages, such as Java, can optimize that.) Although you can use <span

        class="courier">with</span> as follows:&nbsp;&nbsp; <br>
      <blockquote><strong><span class="courier">with(openhome.book.web) {</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; some = 'some';</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; other = 'other';</span><br>
          <span class="courier">&nbsp;&nbsp;&nbsp; another = 'another';</span><br>
          <span class="courier">}</span><br>
        </strong></blockquote>
      But it is not recommended; though it eliminates some typing, but with is hard to optimize, and even might be slower. The better way is: <br>
      <blockquote><strong><span class="courier">var web = openhome.book.web;</span></strong><br>
        <strong><span class="courier">web.some = 'some';</span></strong><br>
        <strong><span class="courier">web.other = 'other';</span></strong><br>
        <strong><span class="courier">web.another = 'another';</span></strong><br>
      </blockquote>
     <div class="recommend" style="text-align: center;"><hr><script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 自動大小回應相符內容 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="4953478487" data-ad-format="autorelaxed"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>
        </article></main></div></body>
<script src="http://openhome.cc/Gossip/js/ui.js"></script>
</html>
<div class="analytics"><script async src="https://www.googletagmanager.com/gtag/js?id=G-QVQQYFSC8J"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-QVQQYFSC8J');</script></div>
