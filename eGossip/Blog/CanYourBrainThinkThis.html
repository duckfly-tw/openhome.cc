<!doctype html><html lang="en">
<head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="One day, you're browsing through your code, and you notice two big blocks that look almost exactly t...">

<meta property="og:locale" content="en">
<meta property="og:title" content="Can Your Brain Think This?">
<meta property="og:type" content="article">
<meta property="og:url" content="https://openhome.cc/eGossip/Blog/CanYourBrainThinkThis.html">
<meta property="og:image" content="https://openhome.cc/Gossip/images/caterpillar_small.jpg">
<meta property="og:site_name" content="OPENHOME.CC">
<meta property="og:description" content="One day, you're browsing through your code, and you notice two big blocks that look almost exactly t...">


    <title>Can Your Brain Think This?</title>

<link rel="stylesheet" href="../../Gossip/css/pure-0.6.0/pure-min.css">

    <!--[if lte IE 8]>
        <link rel="stylesheet" href="../../Gossip/css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="../../Gossip/css/layouts/side-menu.css">
    <!--<![endif]-->
  

     <link rel="stylesheet" href="../../Gossip/css/caterpillar.css">
     <script async src="../../Gossip/google-code-prettify/run_prettify.js"></script>
<!-- 網頁層級廣告 --><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle =window.adsbygoogle || []).push({google_ad_client: "ca-pub-9750319131714390",enable_page_level_ads: true });</script></head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="CanYourBrainThinkThis.html#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
    <div id="menu">
        <div class="pure-menu">
            <a class="pure-menu-heading" href="index.html">&lt;&lt; Blog Picks</a>
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><br><div class="social" style="text-align: center;"><a href="http://twitter.com/caterpillar"><img title="Twitter" alt="Twitter" src="../../Gossip/images/twitter.png"></a> <a href="http://www.facebook.com/openhome.cc"><img title="Facebook" alt="Facebook" src="../../Gossip/images/facebook.png"></a> </div><br><div id="search box"><script>(function() {var cx = 'partner-pub-9750319131714390:3926766884';var gcse = document.createElement('script');gcse.type = 'text/javascript';gcse.async = true;gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(gcse, s);})();</script><gcse:searchbox-only></gcse:searchbox-only></div><br><div class="ad" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 2015 新版型 160 x 600 廣告 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:600px"
     data-ad-client="ca-pub-9750319131714390"
     data-ad-slot="3747048883"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div></li>
            </ul>
        </div>
    </div>

    <main id="main">
        <header class="header">
            <h1>Can Your Brain Think This?</h1>
        </header>

        <article class="content"><br><div class="ad-3" style="text-align: center;"><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型回應式廣告 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="7104125683" data-ad-format="auto"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div> 
            
      
      <br>
      One day, you're browsing through your code, and you notice two big blocks that look almost exactly the same. In fact, they're exactly the same, except that one block refers to "Spaghetti" and one block refers to "Chocolate Moose."<br>
      <br>
      <div class="courier" style="margin-left: 40px;"><span>System.out.println("I'd like some Spaghetti!");</span><span><br>
        </span><span>System.out.println("I'd like some Chocolate Moose!");</span><span><br>
        </span></div>
      <br>
      These examples happen to be in Java, but even if you don't know Java, you should be able to follow along.<br>
      <br>
      The repeated code looks wrong, of course, so you create a method:<br>
      <br>
      <div class="courier" style="margin-left: 40px;"><span>static void swedishChef(String food) {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; println("I'd like some " + food + "!");</span><span><br>
        </span><span>}</span><span><br>
        </span><span><br>
        </span><span>static void println(Object obj) {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; System.out.println(obj);</span><span><br>
        </span><span>}</span><span><br>
        </span><span><br>
        </span><span>swedishChef("Spaghetti!");</span><span><br>
        </span><span>swedishChef("Chocolate Moose!");</span><span><br>
        </span></div>
      <br>
      OK, it's a trivial example, but you can imagine a more substantial example. This is better code for many reasons, all of which you've heard a million times. Maintainability, Readability, Abstraction = Good!<br>
      <br>
      Now you notice two other blocks of code which look almost the same, except that one of them keeps calling this method called <span

        class="courier">boomBoom</span> and the other one keeps calling this method called <span

        class="courier">putInPot</span>. Other than that, the code is pretty much the same.<br>
      <br>
      <div class="courier" style="margin-left: 40px;"><span>println("get the lobster");</span><span><br>
        </span><span>putInPot("lobster");</span><span><br>
        </span><span>putInPot("water");</span><span><br>
        </span><span><br>
        </span><span>println("get the chicken");</span><span><br>
        </span><span>boomBoom("chicken");</span><span><br>
        </span><span>boomBoom("coconut");</span><span><br>
        </span></div>
      <br>
      Now you need a way to replace the block in a method with another block. This is an important thinking, because it increases the chances that you'll be able to find common code that can be stashed away in a method.<br>
      <br>
      <div class="courier" style="margin-left: 40px;"><span>interface Block&lt;P&gt; { </span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; void apply(P p);</span><span><br>
        </span><span>}</span><span><br>
        </span><span><br>
        </span><span>static void cook(String food1, String food2, Block cooker) {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; println("get the " + food1);</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; cooker.apply(food1);</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; cooker.apply(food2);</span><span><br>
        </span><span>}</span><span><br>
        </span><span><br>
        </span><span>cook("lobster", "water", new Block&lt;String&gt;() {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; public void apply(String food) { putInPot(food); }</span><span><br>
        </span><span>});</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span><br>
        </span><span>cook("chicken", "coconut", new Block&lt;String&gt;() {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; public void apply(String food) { boomBoom(food); }</span><span><br>
        </span><span>});</span><span><br>
        </span></div>
      <br>
      Look! We're replacing the block.<br>
      <br>
      Can your brain think this?<br>
      <br>
      Wait... suppose you haven't already defined the methods <span class="courier">putInPot</span> or <span

        class="courier">boomBoom</span>. Wouldn't it be nice if you could just write them in the <span

        class="courier">apply</span> method? Besides, calling the <span

        class="courier">cook</span> method seems verbose. Using proper variables will make them clearer than writing them inline.<br>
      <br>
      <div class="courier" style="margin-left: 40px;"><span>Block&lt;String&gt; putInPot = new Block&lt;String&gt;() {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; public void apply(String food) { println("pot " + food); }</span><span><br>
        </span><span>};</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span><br>
        </span><span>Block&lt;String&gt; boomBoom = new Block&lt;String&gt;() {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; public void apply(String food) { println("boom " + food);}</span><span><br>
        </span><span>};</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span><br>
        </span><strong><span>cook("lobster", "water", putInPot);</span></strong><strong><span><br>
          </span></strong><strong><span>cook("chicken", "coconut", boomBoom);</span></strong><span><br>
        </span></div>
      <br>
      Jeez, calling the <span class="courier">cook</span> method looks clearer. When creating an instance of an anonymous class on the fly, you can give it a proper name and then toss it into a method.<br>
      <br>
      As soon as you start thinking in terms of anonymous class instances as arguments, you might notice code all over the place that, say, does something to every element of a list.<br>
      <br>
      <div class="courier" style="margin-left: 40px;"><span>List&lt;Integer&gt; numbers = asList(1, 2, 3);</span><span><br>
        </span><span><br>
        </span><span>List&lt;Integer&gt; multipliedWith2 = new ArrayList&lt;&gt;();</span><span><br>
        </span><span>for (Integer number : numbers) {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; multipliedWith2.add(number * 2);</span><span><br>
        </span><span>}</span><span><br>
        </span></div>
      <br>
      Doing something to every element of a list is pretty common, and you can write a method that does it for you:<br>
      <br>
      <div class="courier" style="margin-left: 40px;"><strong><span>interface Mapper&lt;P, R&gt; {</span></strong><strong><span><br>
          </span></strong><strong><span>&nbsp;&nbsp;&nbsp; R apply(P p);</span></strong><strong><span><br>
          </span></strong><strong><span>}</span></strong><span><br>
        </span><span><br>
        </span><span>static &lt;T, R&gt; List&lt;R&gt; map(List&lt;T&gt; lt, <strong>Mapper&lt;T, R&gt; mapper</strong>) {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; List&lt;R&gt; mapped = new ArrayList&lt;&gt;();</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; for (T elem : lt) {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mapped.add(<strong>mapper.apply(elem)</strong>);</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; }</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; return mapped;</span><span><br>
        </span><span>}</span><span><br>
        </span></div>
      <br>
      Now you can rewrite the code above as:<br>
      <br>
      <div class="courier" style="margin-left: 40px;"><span>Mapper&lt;Integer, Integer&gt; multiply2 = new Mapper&lt;Integer, Integer&gt;() {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; public Integer apply(Integer number) { return number * 2; }</span><span><br>
        </span><span>};</span><span><br>
        </span><span><br>
        </span><strong><span>List&lt;Integer&gt; multipliedBy2 = map(numbers, multiply2);</span></strong></div>
      <br>
      Another common thing with lists is to combine all the values of the list in some way. <br>
      <br>
      <div class="courier" style="margin-left: 40px;"><span>static Integer sum(List&lt;Integer&gt; numbers) {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; Integer sum = 0;</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; for (Integer number : numbers) { sum += number; }</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; return sum;</span><span><br>
        </span><span>}</span><span><br>
        </span><span>&nbsp;&nbsp; </span><span><br>
        </span><span>static String join(List&lt;String&gt; strs) {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; String joined = "";</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; for (String str : strs) { joined += str; }</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; return joined;</span><span><br>
        </span><span>}</span><span><br>
        </span><span><br>
        </span><span>println(sum(asList(1, 2, 3)));</span><span><br>
        </span><span>println(join(asList("a","b","c")));</span><span><br>
        </span></div>
      <br>
      <span class="courier">sum</span> and <span class="courier">join</span> look so similar, you might want to abstract out their essence into a generic method that combines elements of a list into a single value:<br>
      <br>
      <div class="courier" style="margin-left: 40px;"><strong><span>interface Reducer&lt;R, P&gt; {</span></strong><strong><span><br>
          </span></strong><strong><span>&nbsp;&nbsp;&nbsp; R apply(R r, P p);</span></strong><strong><span><br>
          </span></strong><strong><span>}</span></strong><strong><span><br>
          </span></strong><span><br>
        </span><span>static &lt;T, R&gt; R reduce(List&lt;T&gt; lt, <strong>Reducer&lt;R, T&gt; reducer</strong>, R init) {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; R r = init;</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; for(T elem : lt) { r = <strong>reducer.apply(r, elem);</strong> }</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; return r;</span><span><br>
        </span><span>}</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; </span><span><br>
        </span><span>static Integer sum(List&lt;Integer&gt; numbers) {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; Reducer&lt;Integer, Integer&gt; sumUp = new Reducer&lt;Integer, Integer&gt;() {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public Integer apply(Integer sum, Integer number) { return sum + number; }</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; };</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; return <strong>reduce(numbers, sumUp, 0);</strong></span><span><br>
        </span><span>}</span><span><br>
        </span><span>&nbsp; </span><span><br>
        </span><span>static String join(List&lt;String&gt; strs) {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; Reducer&lt;String, String&gt; joinAll = new Reducer&lt;String, String&gt;() {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public String apply(String all, String str) { return all + str; }</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; };</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; return <strong>reduce(strs, joinAll, "");</strong></span><span><br>
        </span><span>}</span><span><br>
        </span></div>
      <br>
      Using a language such as JavaScript will have an easier way to do this kind of stuff. Many older languages simply had no way to do this kind of stuff. Other languages let you do it, but it's hard (for example, C has function pointers, but you have to declare and define the function somewhere else). Object-oriented programming languages aren't completely convinced that you should be allowed to do anything with functions, such as Java.<br>
      <br>
      If you want to simulate first-class functions, Java required you to create a whole object with a single method called a functor if you wanted to treat a function like a first class object. Combine that with the fact that many OO languages want you to create a whole file for each class, and it gets really klunky fast. If your programming language requires you to use functors, you're not getting all the benefits of a modern programming environment. See if you can get some of your money back.<br>
      <br>
      When using a language with first-class functions, will you automatically own the ability to write code such as above? Definitely, it's verbose without first-functions, but the point is the process of thinking. Hum? How much benefit do you really get out of writing itty bitty functions that do nothing more than iterate through a list doing something to each element?<br>
      <br>
      Well, let's go back to that <span class="courier">map</span> function. When you need to do something to every element in a list in turn, the truth is, it probably doesn't matter what order you do them in. You can run through the array forward or backwards and get the same result, right? In fact, if you have two CPUs handy, maybe you could write some code to have each CPU do half of the elements, and suddenly map is twice as fast.<br>
      <br>
      Or maybe, just hypothetically, you have hundreds of thousands of servers in several data centers around the world, and you have a really big list, containing, let's say, again, just hypothetically, the entire contents of the internet. Now you can run map on thousands of computers, each of which will attack a tiny part of the problem.<br>
      <br>
      So now, for example, writing some really fast code to search the entire contents of the internet is as simple as calling the map function with a basic string searcher as an argument.<br>
      <br>
      The really interesting thing I want you to notice, here, is that as soon as you think of map and reduce as functions that everybody can use, and they use them, you only have to get one supergenius to write the hard code to run map and reduce on a global massively parallel array of computers, and all the old code that used to work fine when you just ran a loop still works only it's a zillion times faster which means it can be used to tackle huge problems in an instant.<br>
      <br>
      Lemme repeat that. By abstracting away the very concept of looping, you can implement looping any way you want, including implementing it in a way that scales nicely with extra hardware.<br>
      <br>
      And now you understand something I want to ask: are you a programmer writing nothing without first-class functions? <br>
      <br>
      Without understanding functional programming, you can't invent MapReduce, the algorithm that makes Google so massively scalable. The terms Map and Reduce come from Lisp and functional programming. MapReduce is, in retrospect, obvious to anyone who remembers from their functional programming that purely functional programs have no side effects and are thus trivially parallelizable. <br>
      <br>
      Ok. I hope you're convinced, by now, that programming languages with first-class functions definitely let you find more opportunities for abstraction, which means your code is smaller, tighter, more reusable, and more scalable. Without first-class functions, however, you can use the same process of thinking to write reusable and extensible programs. Lots of Google applications use MapReduce and they all benefit whenever someone optimizes it or fixes bugs.<br>
      <br>
      I'm confused every time. The most productive programming environments definitely let you easily work at different levels of abstraction. Crappy old FORTRAN really didn't even let you write functions. C had function pointers, but they were ugleeeeee and not anonymous and had to be implemented somewhere else than where you were using them. Java made you use functors, which is even uglier. As Steve Yegge points out, Java is the Kingdom of Nouns.<br>
      <br>
      So what? Cannot a C program be written in object-oriented ways? With powerful first-class functions, will your brain level up automatically? Lambda will be introduced into JDK8. If you even write code such as above, you'll benefit from JDK8 Lambda directly.<br>
      <br>
      <div class="courier" style="margin-left: 40px;"><span>static Integer sum(List&lt;Integer&gt; numbers) {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; return <strong>reduce(numbers, (sum, number) -&gt; sum + number, 0);</strong></span><span><br>
        </span><span>}</span><span><br>
        </span><span>&nbsp; </span><span><br>
        </span><span>static String join(List&lt;String&gt; strs) {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; return <strong>reduce(strs, (all, str) -&gt; all + str, "");</strong></span><span><br>
        </span><span>}</span><span><br>
        </span></div>
      <br>
      If your brain cannot think this, it's mostly likely to just take JDK8 Lambda as syntax sugars. There's no way your brain will be leveled up automatically because you use a language with first-class functions. Don't forget those not object-oriented codes written with Java.<br>
      <br>
      PS. Most sections are copied from <a href="http://www.joelonsoftware.com/items/2006/08/01.html">Can Your Programming Language Do This?</a> . Doing it on purpose is simply for earning your smile.<br>
<div class="recommend" style="text-align: center;"><hr><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 自動大小回應相符內容 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="4953478487" data-ad-format="autorelaxed"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>
    
        </article></main></div></body>
<script src="../../Gossip/js/ui.js"></script>
</html>
<div class="analytics"><script async src="https://www.googletagmanager.com/gtag/js?id=G-QVQQYFSC8J"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-QVQQYFSC8J');</script></div>
