<!doctype html><html lang="en">
<head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="In the previous "Understanding Lambda/Closure" series, we use JavaScript and Python to demonstrate w...">

<meta property="og:locale" content="en">
<meta property="og:title" content="Understanding Lambda/Closure, Part 4 - Learning from Scala">
<meta property="og:type" content="article">
<meta property="og:url" content="https://openhome.cc/eGossip/Blog/UnderstandingLambdaClosure4.html">
<meta property="og:image" content="https://openhome.cc/Gossip/images/caterpillar_small.jpg">
<meta property="og:site_name" content="OPENHOME.CC">
<meta property="og:description" content="In the previous "Understanding Lambda/Closure" series, we use JavaScript and Python to demonstrate w...">


    <title>Understanding Lambda/Closure, Part 4 - Learning from Scala</title>

<link rel="stylesheet" href="../../Gossip/css/pure-0.6.0/pure-min.css">

    <!--[if lte IE 8]>
        <link rel="stylesheet" href="../../Gossip/css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="../../Gossip/css/layouts/side-menu.css">
    <!--<![endif]-->
  

     <link rel="stylesheet" href="../../Gossip/css/caterpillar.css">
     <script async src="../../Gossip/google-code-prettify/run_prettify.js"></script>
<!-- 網頁層級廣告 --><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle =window.adsbygoogle || []).push({google_ad_client: "ca-pub-9750319131714390",enable_page_level_ads: true });</script></head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="UnderstandingLambdaClosure4.html#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
    <div id="menu">
        <div class="pure-menu">
            <a class="pure-menu-heading" href="index.html">&lt;&lt; Blog Picks</a>
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><br><div class="social" style="text-align: center;"><a href="http://twitter.com/caterpillar"><img title="Twitter" alt="Twitter" src="../../Gossip/images/twitter.png"></a> <a href="http://www.facebook.com/openhome.cc"><img title="Facebook" alt="Facebook" src="../../Gossip/images/facebook.png"></a> </div><br><div id="search box"><script>(function() {var cx = 'partner-pub-9750319131714390:3926766884';var gcse = document.createElement('script');gcse.type = 'text/javascript';gcse.async = true;gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(gcse, s);})();</script><gcse:searchbox-only></gcse:searchbox-only></div><br><div class="ad" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 2015 新版型 160 x 600 廣告 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:600px"
     data-ad-client="ca-pub-9750319131714390"
     data-ad-slot="3747048883"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div></li>
            </ul>
        </div>
    </div>

    <main id="main">
        <header class="header">
            <h1>Understanding Lambda/Closure, Part 4 - Learning from Scala</h1>
        </header>

        <article class="content"><br><div class="ad-3" style="text-align: center;"><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型回應式廣告 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="7104125683" data-ad-format="auto"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div> 
            
      
      <br>
      In the previous "Understanding Lambda/Closure" series, we use JavaScript and Python to demonstrate what lambda/closure is and how to use them. That's a good start to learn about lambda/closure, because they are dynamically-typed languages. You don't have to care about types in these languages. When getting into statically-typed languages, we know that type information is necessary for compilers to check a large class of type errors at compilation time. This is a good thing, because you can catch any error early and reduce the cost of errors. When the cleanness comes into the question, however, statically-typed languages are always criticized for their lengthy type declarations.<br>
      <br>
      Let's see how to define a function in Scala. <br>
      <br>
      <div style="margin-left: 40px;"><span class="courier" style="font-weight: bold;">def max(m: Int, n: Int): Int = if(m &gt; n) m else n<br>
        </span></div>
      <br>
      Scala is a statically-typed language, so we have to declare what type a parameter is. It seems the type declaration doesn't cause a big problem in this example. Well, let's see how to write an anonymous function and assign to a variable.<br>
      <br>
      <div class="courier" style="margin-left: 40px;"><span><strong>val max: (Int, Int) =&gt; Int = (m: Int, n: Int) =&gt; if(m &gt; n) m else n</strong></span><span><strong><br>
          </strong></span></div>
      <br>
      Oh...what a big stuff! You have to say that the type of <span class="courier">max</span> is <span

        class="courier">(Int, Int) =&gt; Int</span> - a specific function type says that a function accepts two <span

        class="courier">Int</span> arguments and returns a <span class="courier">Int</span> value. When defining an anonymous function, you also have to declare parameter types, such as <span

        class="courier">(m: Int, n: Int) =&gt; if(m &gt; n) m else n</span>. If you want to define a parameter which accepts a callback function, you have to declare its function type, too. For example:<br>
      <br>
      <div class="courier" style="margin-left: 40px;"><span>def bubbleSort(arr: Array[Int], <strong>order: (Int, Int) =&gt; Boolean</strong>): Unit {</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; ...</span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; val o: Boolean = <strong>order(a, b)</strong></span><span><br>
        </span><span>&nbsp;&nbsp;&nbsp; ...</span><span><br>
        </span><span>}</span></div>
      <br>
      The <span class="courier">order</span> parameter accepts a function which accepts two <span

        class="courier">Int</span> parameters and returns a <span class="courier">Boolean</span> value. The following code shows how to call the <span

        class="courier">bubbleSort</span> function.<br>
      <br>
      <div class="courier" style="margin-left: 40px;"><span>val arr: Array[Int] = Array(2, 5, 1, 7, 8)</span><span><br>
        </span><span>bubbleSort(arr, <strong>(a: Int, b: Int) =&gt; a &gt; b</strong>)</span></div>
      <br>
      If the lengthy syntax is definitely necessary in Scala, do you want to use lambda/closure? Fortunately, Scala compiler is clever enough to do type inference. It can infer the type information from the context of the source code, so you don't always have to provide the type information when declaring a variable or writing an anonymous function. For example, the above code may be rewritten as follows:<br>
      <br>
      <div class="courier" style="margin-left: 40px;"><span>val arr = Array(2, 5, 1, 7, 8)</span><span><br>
        </span><span>bubbleSort(arr, <strong>(a, b) =&gt; a &gt; b</strong>)</span></div>
      <br>
      Scala compiler infers the <span class="courier">arr</span> type is <span

        class="courier">Array[Int]</span> from <span class="courier">Array(2, 5, 1, 7, 8)</span>, so we don't have to declare it again. Also, Scala complier infers both parameters of the anonymous function are <span

        class="courier">Int</span> from <span class="courier">arr</span>, so we only have to provide the parameter names and the function body. In Scala, actually, you can even use shorter code to call the function. For example:<br>
      <br>
      <div class="courier" style="margin-left: 40px;"><span>val arr = Array(2, 5, 1, 7, 8)</span><span><br>
        </span><span>bubbleSort(arr, <span style="font-weight: bold;">(_: Int) &gt; (_: Int)</span>)</span></div>
      <br>
      Or, even shortest code:<br>
      <br>
      <div class="courier" style="margin-left: 40px;"><span>val arr = Array(2, 5, 1, 7, 8)</span><span><br>
        </span><span>bubbleSort(arr, <strong>_ &gt; _</strong>)</span></div>
      <br>
      I don't want to explain how Scala plays these magic. If you're interested, take a look at <a

        href="https://openhome.cc/Gossip/Scala/index.html">Scala Goosip</a>. The point here is that, the abilities of type inference are important for statically-typed languages. It can provide short and clean syntax while type information is necessary, such as declaring a variable or writing an anonymous function. Lambda/closure is an expressive tool. Without type inference, the lengthy syntax will keeps developers out of using lambda/closure. <br>
      <br>
      The next article will talk about lambda/closure in Java, but we'll look its <a

        href="http://cr.openjdk.java.net/%7Emr/lambda/straw-man/">old proposal</a> first. This will help us understanding how lambda/closure evolved into the current state in JDK8.<br>
      <br>
      
<div class="recommend" style="text-align: center;"><hr><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 自動大小回應相符內容 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="4953478487" data-ad-format="autorelaxed"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>      
    
        </article></main></div></body>
<script src="../../Gossip/js/ui.js"></script>
</html>
<div class="analytics"><script async src="https://www.googletagmanager.com/gtag/js?id=G-QVQQYFSC8J"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-QVQQYFSC8J');</script></div>
