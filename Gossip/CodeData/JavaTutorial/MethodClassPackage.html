<!doctype html><html lang="zh-tw">
<head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Java Tutorial 第二堂（2）容器與流程語法&nbsp;&lt;&lt; 前情 
      
      雖然在&nbsp;Java Tutorial 第二堂（1）中談過，Java 中...">

<meta property="og:locale" content="zh_TW">
<meta property="og:title" content="Java Tutorial 第二堂（3）方法、類別與套件">
<meta property="og:type" content="article">
<meta property="og:url" content="https://openhome.cc/Gossip/CodeData/JavaTutorial/MethodClassPackage.html">
<meta property="og:image" content="https://openhome.cc/Gossip/images/caterpillar_small.jpg">
<meta property="og:site_name" content="OPENHOME.CC">
<meta property="og:description" content="Java Tutorial 第二堂（2）容器與流程語法&nbsp;&lt;&lt; 前情 
      
      雖然在&nbsp;Java Tutorial 第二堂（1）中談過，Java 中...">


    <title>Java Tutorial 第二堂（3）方法、類別與套件</title>

<link rel="stylesheet" href="../../css/pure-0.6.0/pure-min.css">

    <!--[if lte IE 8]>
        <link rel="stylesheet" href="../../css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="../../css/layouts/side-menu.css">
    <!--<![endif]-->
  

     <link rel="stylesheet" href="../../css/caterpillar.css">
     <script async src="../../google-code-prettify/run_prettify.js"></script>
<!-- 網頁層級廣告 --><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle =window.adsbygoogle || []).push({google_ad_client: "ca-pub-9750319131714390",enable_page_level_ads: true });</script></head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="MethodClassPackage.html#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon --><span></span>
        
    </a>
    <div id="menu">
        <div class="pure-menu">
            <a class="pure-menu-heading" href="index.html">回 Java Tutorial</a>
            <ul class="pure-menu-list">
                <br><div class="social" style="text-align: center;"><a href="http://twitter.com/caterpillar"><img title="Twitter" alt="Twitter" src="../../images/twitter.png"></a> <a href="http://www.facebook.com/openhome.cc"><img title="Facebook" alt="Facebook" src="../../images/facebook.png"></a> </div><br><div id="search box"><script>(function() {var cx = 'partner-pub-9750319131714390:3926766884';var gcse = document.createElement('script');gcse.type = 'text/javascript';gcse.async = true;gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(gcse, s);})();</script><gcse:searchbox-only></gcse:searchbox-only></div><br><div class="ad" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 2015 新版型 160 x 600 廣告 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:600px"
     data-ad-client="ca-pub-9750319131714390"
     data-ad-slot="3747048883"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div></li>
            </ul>
        </div>
    </div>

    <main id="main">
        <header class="header">
            <h1>Java Tutorial 第二堂（3）方法、類別與套件</h1>
        </header>

        <article class="content"><br><div class="ad-3" style="text-align: center;"><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型回應式廣告 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="7104125683" data-ad-format="auto"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div> 
              <br>
      <br>
      雖然在&nbsp;<a href="NumberString.html">Java Tutorial 第二堂（1）</a>中談過，Java 中並非每個值都是物件，不過&nbsp;<span

        style="color: #ff0000;"><strong>Java 基本上是個以物件導向為主要典範的語言</strong></span>，任何程式都以定義類別為出發點，即使只是個「哈囉！世界！」也不例外：
      <pre class="prettyprint"><code lang="java">public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("哈囉！世界！");
    }
}</code></pre>
      <br>
      不過這看來不太像物件導向，若只是這樣的需求，似乎也不需要動用到物件導向，如果 Java 具有其他語言中函式（Function）的概念，不是可以更簡單一些，呼叫個 <code>println("哈囉！世界！")</code> 就解決這個問題嗎？直接從類別定義出發，再定義靜態方法（Static method），對一些簡單需求來說，確實是不必要，不過就程式的組織與架構上，Java 的作法與一些語言並沒有差別，只不過要求你明確定義類別及定義方法罷了，這篇文章後續會說明這點。 <br>
      <br>
      基本上，無論採用何種典範，關鍵在於架構程式時應思考的幾個重點，像是…
      <ul>
        <li><span style="line-height: 1.714285714; font-size: 1rem; color: #ff0000;">抽象層的封裝與隔離</span></li>
        <li><span style="line-height: 1.714285714; font-size: 1rem; color: #ff0000;">物件的狀態</span></li>
        <li><span style="line-height: 1.714285714; font-size: 1rem; color: #ff0000;">名稱空間（Namespace）</span></li>
        <li><span style="line-height: 1.714285714; font-size: 1rem; color: #ff0000;">資源的實體組織方式，像是原始碼檔案、套件（Package）等</span></li>
      </ul>
      只有在腦海中清楚地思考過這幾個重點，才能在程式語言中採用適當的機制來加以實現，或者是在程式語言不支援時，想辦法自行實作類似機制，像是在 JavaScript 中，即使沒有名稱空間及套件機制，仍有開發者依各自需求實現各種風格的機制，來解決對應的問題。 <br>
      <br>
      幸運地，Java 中對於這幾個思考重點，在實作時提供的機制算是為完整，提供了像是靜態方法、類別（Class）與套件等支援。
      <h1>靜態方法</h1>
      不管你願不願意，想撰寫第一個可執行的 Java 程式，就一定得接觸靜態方法，因為程式進入點就規定一定得是 <code>public static void main(String[] args)</code>，而且必須定義在類別之中，在初學階段，對於靜態方法可以先理解為，它就像是其他語言中的函式。舉例而言，當發現到兩個程式片段極為類似，只有當中幾個計算用到的數值或變數不同時，例如 <code>main</code> 中可能如此撰寫：
      <pre class="prettyprint"><code lang="java">...
Integer max1 = a &gt; b ? a : b;
...
Integer max2 = x &gt; y ? x : y;
...</code></pre>
      <br>
      可以使用靜態方法來封裝程式片段，將流程中引用不同數值或變數的部份設計為參數，例如：
      <pre class="prettyprint"><code lang="java">/* 存為 Math.java */
class Math {
    static Integer max(Integer a, Integer b) {
        return a &gt; b ? a : b;
    }
}</code></pre>
      <br>
      靜態方法得定義在類別之中，如此一來，就可以在其他地方透過類別名稱來呼叫靜態方法，例如 <code>main</code> 中可直接如下呼叫：
      <pre class="prettyprint"><code lang="java">...
Integer max1 = Math.max(a, b);
...
Integer max2 = Math.max(x, y);
...</code></pre>
      <span style="color: #ff0000;"><strong><br>
          就某些程度上，包括靜態方法的類別充當了名稱空間</strong></span>，就像是 Python 中模組之作用，而類別中的靜態方法，就像是 Python 中的函式，而函式是一種抽象，對流程的抽象，因此如上定義了 <code>Math.max</code> 靜態方法之後，客戶端對求最大值的流程，被抽象為 <code>Math.max(x, y)</code> 這樣的呼叫，求值流程實作被隱藏了起來。 <br>
      <br>
      Java 中有一些 API，就是以這樣的概念來實現，像是 <a href="http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html"><code>java.lang.Math</code></a> 中就有大量與數學相關的靜態方法，而想到陣列操作時，也可以看看 <a

        href="http://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html"><code>java.util.Arrays</code></a> 中有沒有現成的靜態方法可以使用，<span

        style="color: #ff0000;"><strong>當想操作的功能不渉及狀態時，可以考慮使用靜態方法</strong></span>，就像是這邊的 <code>Math.max</code>，因為傳入的兩個值是平等的，跟任何物件的狀態沒有關係。 <br>
      <br>
      那麼 Java 中的靜態方法，就只是函式的概念嗎？不！不只是這樣的，這篇文章稍後，馬上就可以看到靜態方法的其他應用…
      <h1>類別</h1>
      如果只是將類別拿來當作靜態方法的名稱空間，並不是什麼物件導向，那類別的應用場合呢？…嗯…在你想要表達一組相關聯的數據時，例如，若你想表達帳戶資料，而帳戶有名稱、帳號與餘額，<span

        style="color: #ff0000;"><strong>為了易於操作</strong></span>，可定義類別將它們視為一個整體：
      <pre class="prettyprint"><code lang="java">/* 存為 Account.java */
class Account {
    String name;
    String number;
    Integer balance;
}</code></pre>
      <br>
      這麼一來，就使用 <code>new Account()</code> 來建立物件並進行操作，也許一開始，你是定義了一些靜態方法來建立與操作 <code>Account</code> 實例：
      <pre class="prettyprint"><code lang="java">/* 存為 Bank.java */
class Bank {
    static Account account(String name, String number, Integer balance) {
        Account acct = new Account();
        acct.name = name;
        acct.number = number;
        acct.balance = balance;
        return acct;
    }

    static void deposit(Account acct, Integer amount) {
        if(amount &lt;= 0) {
             throw new IllegalArgumentException("amount must be positive");
         }
         acct.balance += amount;
     }

    static void withdraw(Account acct, Integer amount) {
        if(amount &gt; acct.balance) {
            throw new RuntimeException("balance not enough");
        }
        acct.balance -= amount;
    }

    static String toStr(Account acct) {
        return String.format("Account(%s, %s, %d)", 
                          acct.name, acct.number, acct.balance);
    }
}</code></pre>
      <br>
      當中是有關於帳戶建立、存款、提款等函式，你會這麼使用：
      <pre class="prettyprint"><code lang="java">public class Main {
    public static void main(String[] args) {
        Account acct = Bank.account("Java", "001", 100);
        Bank.deposit(acct, 500);
        Bank.withdraw(acct, 200);
        System.out.println(Bank.toStr(acct));
    }
}</code></pre>
      <br>
      實際上，<code>Bank</code> 類別中的靜態方法，都是與傳入的 <code>Account</code> 實例，也就是代表帳戶狀態的物件相關，每個靜態方法的第一個參數是 <code>Account</code>，就暗示了這些方法應該與 <code>Account</code> 類別放在一起，<span

        style="color: #ff0000;"><strong>何不將相關的狀態與操作黏在一起呢？這樣比較容易使用些</strong></span>，因此你重新定義了 <code>Account</code> 類別：
      <pre class="prettyprint"><code lang="java">class Account {
    private String name;
    private String number;
    private Integer balance;

    Account(String name, String number, Integer balance) {
        this.name = name;
        this.number = number;
        this.balance = balance;
    }

    void deposit(Integer amount) {
        if(amount &lt;= 0) {
             throw new IllegalArgumentException("amount must be positive");
        }
        this.balance += amount;
    }

    void withdraw(Integer amount) {
        if(amount &gt; this.balance) {
           throw new RuntimeException("balance not enough");
        }
        this.balance -= amount;
    }

    String toStr() {
        return String.format("Account(%s, %s, %d)", 
                         this.name, this.number, this.balance);
    }
}</code></pre>
      <br>
      在 <code>Account</code> 類別中，<strong>與類別名稱同名且沒有宣告傳回值型態的方法，稱之為建構式（Constructor），它定義了物件的初始流程</strong>，取代了原本的 <code>account</code> 靜態方法，注意到每個類別中的方法沒有宣告 <code>static</code>，這表示它是個實例方法，<strong>方法中的 <code>this</code> 表示物件本身</strong>，如果沒有與參數名稱衝突的話，基本上可以省略，不過有時寫出來比較清楚易懂。 <span

        style="line-height: 1.714285714; font-size: 1rem;"><br>
        <br>
        我們希望客戶端必須透過 </span><code style="line-height: 1.714285714;">deposit</code><span

        style="line-height: 1.714285714; font-size: 1rem;">、</span><code

        style="line-height: 1.714285714;">withdraw</code><span style="line-height: 1.714285714; font-size: 1rem;"> 等操作物件，而不是直接存取物件的 </span><code

        style="line-height: 1.714285714;">name</code><span style="line-height: 1.714285714; font-size: 1rem;">、</span><code

        style="line-height: 1.714285714;">number</code><span style="line-height: 1.714285714; font-size: 1rem;"> 與 </span><code

        style="line-height: 1.714285714;">balance</code><span style="line-height: 1.714285714; font-size: 1rem;"> 等狀態成員，這樣 </span><code

        style="line-height: 1.714285714;">deposit</code><span style="line-height: 1.714285714; font-size: 1rem;">、</span><code

        style="line-height: 1.714285714;">withdraw</code><span style="line-height: 1.714285714; font-size: 1rem;"> 中設定的流程控管才有意義，因此在 </span><code

        style="line-height: 1.714285714;">name</code><span style="line-height: 1.714285714; font-size: 1rem;">、</span><code

        style="line-height: 1.714285714;">number</code><span style="line-height: 1.714285714; font-size: 1rem;"> 與 </span><code

        style="line-height: 1.714285714;">balance</code><span style="line-height: 1.714285714; font-size: 1rem;"> 等狀態成員上設定了 </span><strong

        style="line-height: 1.714285714; font-size: 1rem;"><code>private</code></strong><span

        style="line-height: 1.714285714; font-size: 1rem;">，表示這只能是類別內部的程式碼才能存取。</span> <br>
      <br>
      如此定義之後，<span style="color: #ff0000;"><strong>客戶端在使用上就容易得多了</strong></span>…
      <pre class="prettyprint"><code lang="java">public class Main {
    public static void main(String[] args) {
        Account acct = new Account("Java", "001", 100);
        acct.deposit(500);
        acct.withdraw(200);
        System.out.println(acct.toStr());
    }
}</code></pre>
      <br>
      是的！<strong>容易使用</strong>！在討論物件導向時，大家總是愛談可重用性（Reusability），然而要談到重用性的話，函式的重用性還高上許多，在考量物件導向時，<strong><span

          style="color: #ff0000;">易用性（Usability）</span></strong>其實才是它的重點。
      <h1>套件</h1>
      假設現在你有一些 .java 與編譯完成的檔案，別人同樣也有一堆 .java 與 .class 檔案，你們的檔案現在得放在同一專案中，那麼檔案名稱衝突是有可能發生的，最好是為你們的 .java、.class 檔案分別開設目錄；另一方面，只使用外部類別充當名稱空間，也不是好的作法，當多個名稱空間階層時，就會有許多不便。 <br>
      <br>
      使用 Java 時，你可以在原始碼開頭使用 <strong><code>package</code></strong> 來宣告套件階層。例如，想將你的 <code>Account</code> 宣告在 <code>tw.codedata.bank</code> 套件階層之下的話，可以如下：
      <pre class="prettyprint"><code lang="java">package tw.codedata.bank;

public class Account {
    private String name;
    private String number;
    private Integer balance;

    public Account(String name, String number, Integer balance) {
        this.name = name;
        this.number = number;
        this.balance = balance;
    }

    public void deposit(Integer amount) {
        if(amount &lt;= 0) {
             throw new IllegalArgumentException("amount must be positive");
        }
        this.balance += amount;
    }

    public void withdraw(Integer amount) {
        if(amount &gt; this.balance) {
            throw new RuntimeException("balance not enough");
        }
        this.balance -= amount;
    }

    public String toString() {
        return String.format("Account(%s, %s, %d)", 
                          this.name, this.number, this.balance);
    }
}</code></pre>
      <br>
      使用 <code>package</code> 宣告 <code>Account</code> 是在 <code>tw.codedata.bank</code> 意謂著幾件事，如果在其他套件中使用它，必須使用<strong>類別全名</strong> <code>tw.codedata.bank.Account</code>，Account.java 必須放置在原始碼路徑（SOURCEPATH）（可使用 <code>javac</code> 的 <code>-sourcepath</code> 指定）的 tw/codedata/bank 目錄中，編譯完成的 Account.class 必須放在類別路徑（CLASSPATH）的 tw/codedata/bank 目錄中，在遵守這幾件規範，以及好的階層命名下，可以減少名稱空間檔案與衝突的發生。 <br>
      <br>
      注意，程式中宣告了<strong> <code>public</code></strong>，這意謂著被公開的類別或方法對其他套件中的程式碼來說是有用的，沒有宣告任何權限時，預設並不會對其他套件公開這些資訊，只能在相同套件中使用。 <br>
      <br>
      在類別中還定義了&nbsp;<strong><code>toString</code>&nbsp;</strong>方法來取代 <code>toStr</code>，許多程式庫若想要取得物件的字串說明，都會透過&nbsp;<code>toString</code>&nbsp;方法，例如&nbsp;<code>System.out.println</code>&nbsp;方法，如果給它個物件，都就會自動呼叫物件的&nbsp;<code>toString</code>，然再用取得的字串進行文字輸出。 假設你在先前的 Main.java 中宣告套件：
      <pre class="prettyprint"><code lang="java">package tw.codedata;

import tw.codedata.bank.Account;

public class Main {
    public static void main(String[] args) {
        Account acct = new Account("Java", "001", 100);
        acct.deposit(500);
        acct.withdraw(200);
        System.out.println(acct);
    }
}</code></pre>
      <br>
      因為類別全名為 <code>tw.codedata.bank.Account</code> 打來有些冗長，因此這邊使用 <code>import tw.codedata.bank.Account</code> 先聲明了後續的 <code>Account</code> 應該會是 <code>tw.codedata.bank.Account</code>，同樣的，這個 Main.java 與編譯出來的 Main.class 要各自放在原始碼路徑與類別路徑的 tw/codedata 目錄下。 <strong><span

          style="color: #ff0000;"><br>
          <br>
          練習 7：運用類別與套件來組織程式</span></strong> <br>
      <br>
      在練習用的檔案中，有個 exercises/exercise7/Bank 目錄，這個目錄符合 Gradle 架構，裏頭草草寫了一些類別與靜態方法，以及執行結果輸出的程式碼，請利用這邊介紹的類別與套件等語法，來重新組織當中可重用的程式碼，讓它們可以位於 <code>tw.codedata</code>、<code>tw.codedata.bank</code> 套件中的適當類別。 <br>
      <br>
      最後，你完成的程式在實體架構上，應該會像是以下的圖片示意（如果不知道怎麼完成實作，記得參考練習用檔案中 solutions/exercise7/Bank 的成果 ）：<br>
      <br>
      &nbsp;<a href="images/java-tutorial-the-2nd-class-3.png"><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" class="alignnone size-full wp-image-3340"

          alt="java-tutorial-the-2nd-class-3" src="images/java-tutorial-the-2nd-class-3.png"

          height="362" width="400" /></div></div></a>
      <h1>再看靜態方法</h1>
      實際上，Java 的靜態方法並非只是將外部類別作為名稱空間，常見的運用之一是將靜態方法用來隱藏物件實作與建構細節，像是 Guava 的 <code>ImmutableList</code>，實際上你並不用去知道實作類別有哪些，也因此也不用想辦法使用 <code>new</code> 來建構實例，而是透過 <code>of</code> 靜態方法來取得 <code>ImmutableList</code> 實例。 <br>
      <br>
      類似的應用還有實現單例（Singleton），例如 Java 中的 <code>java.lang.Runtime</code>類別實作如下：
      <pre class="prettyprint"><code lang="java">public class Runtime { 
    private static Runtime currentRuntime = new Runtime(); 

    public static Runtime getRuntime() { 
        return currentRuntime; 
    } 

   /** Don't let anyone else instantiate this class */ 
   private Runtime() {} 

    // 略 ...
}</code></pre>
      <br>
      建構式被設為 <code>private</code>，因此 <code>Runtime</code> 類別以外的程式碼都不能建構它的實例，只有 <code>Runtime</code> 類別內部可以建立實例，也因此，實現了每個 JVM 執行時都有唯一的 <code>Runtime</code> 實例。 第二堂時間差不多到了，休息一下，接下來的第三堂課要來認識 Java 的 IDE、社群、文件以及更多的 API … <br>
      <br><br><br><div class="ad336-280" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型廣告 336 x 280 --><ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-9750319131714390" data-ad-slot="9976409681"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div><br><div class="recommend" style="text-align: center;"><hr><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 自動大小回應相符內容 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="4953478487" data-ad-format="autorelaxed"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></article></main></div></body>
<script src="../../js/ui.js"></script>
</html>
<div class="analytics"><script async src="https://www.googletagmanager.com/gtag/js?id=G-QVQQYFSC8J"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-QVQQYFSC8J');</script></div>
