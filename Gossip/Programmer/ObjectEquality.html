<!doctype html><html lang="zh-tw">
<head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="iThome 網站首載：Wat？為何不相等？
      
      相等與否看似簡單議題，但因語言中夾雜多個元素而變得複雜，不明就理的開發者面對時戰戰競競，瞭若指掌的開發者侃侃而談玩Wat（W...">

<meta property="og:locale" content="zh_TW">
<meta property="og:title" content="Wat？為何不相等？">
<meta property="og:type" content="article">
<meta property="og:url" content="https://openhome.cc/Gossip/Programmer/ObjectEquality.html">
<meta property="og:image" content="https://openhome.cc/Gossip/images/caterpillar_small.jpg">
<meta property="og:site_name" content="OPENHOME.CC">
<meta property="og:description" content="iThome 網站首載：Wat？為何不相等？
      
      相等與否看似簡單議題，但因語言中夾雜多個元素而變得複雜，不明就理的開發者面對時戰戰競競，瞭若指掌的開發者侃侃而談玩Wat（W...">


    <title>Wat？為何不相等？</title>

<link rel="stylesheet" href="http://openhome.cc/Gossip/css/pure-0.6.0/pure-min.css">

    <!--[if lte IE 8]>
        <link rel="stylesheet" href="../css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="http://openhome.cc/Gossip/css/layouts/side-menu.css">
    <!--<![endif]-->
  

     <link rel="stylesheet" href="http://openhome.cc/Gossip/css/caterpillar.css">
     <script async src="http://openhome.cc/Gossip/google-code-prettify/run_prettify.js"></script>
<!-- 網頁層級廣告 --><script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle =window.adsbygoogle || []).push({google_ad_client: "ca-pub-9750319131714390",enable_page_level_ads: true });</script></head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="ObjectEquality.html#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon --><span></span>
        
    </a>
    <div id="menu">
        <div class="pure-menu">
            <a class="pure-menu-heading" href="http://openhome.cc/Gossip/Programmer/">回程式人目錄</a>
            <ul class="pure-menu-list">
                <br><div class="social" style="text-align: center;"><a href="http://twitter.com/caterpillar"><img title="Twitter" alt="Twitter" src="../images/twitter.png"></a> <a href="http://www.facebook.com/openhome.cc"><img title="Facebook" alt="Facebook" src="../images/facebook.png"></a> </div><br><div id="search box"><script>(function() {var cx = 'partner-pub-9750319131714390:3926766884';var gcse = document.createElement('script');gcse.type = 'text/javascript';gcse.async = true;gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(gcse, s);})();</script><gcse:searchbox-only></gcse:searchbox-only></div><br><div class="ad" style="text-align: center;"><script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 2015 新版型 160 x 600 廣告 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:600px"
     data-ad-client="ca-pub-9750319131714390"
     data-ad-slot="3747048883"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div></li>
            </ul>
        </div>
    </div>

    <main id="main">
        <header class="header">
            <h1>Wat？為何不相等？</h1>
        </header>

        <article class="content"><br><div class="ad-3" style="text-align: center;"><script async="" src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型回應式廣告 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="7104125683" data-ad-format="auto"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div> 
             iThome 網站首載：<a href="http://www.ithome.com.tw/itadm/article.php?c=75742">Wat？為何不相等？</a><br>
      <br>
      相等與否看似簡單議題，但因語言中夾雜多個元素而變得複雜，不明就理的開發者面對時戰戰競競，瞭若指掌的開發者侃侃而談玩Wat（What諧音字，無意義但出乎意料的結果）。相等性的諸多議題反映出語言中的細微特性，不搞懂這些細微特性，程式中隨時就會出現Wat脫口而出的狀況。<br>
      <br>
      <dl>
        <dt>基本型態與物件型態的相等性</dt>
      </dl>
      <br>
      有些程式語言為了效率，型態系統中有基本型態與物件型態，基本型態的相等性是比較值，物件型態的相等性通常是依方法定義比較狀態，有時則會針對物件參考（Reference）是否相等進行比較。<span

        class="courier">程式普遍來說多採用==作為相等性的比較符號，然而==符號作用為何，依程式語言而有所不同。</span><span><br>
      </span><br>
      以Java為例，<span class="courier">基本型態使用==比較時，是在比較數值是否相同，物件型態使用==比較時，是在比較參考是否相同，如果要比較兩物件狀態的相等性，則必須定義並使用equals方法。JavaScript基本上也使用==進行相等比較</span>，基本型態比較值，物件型態則比較物件參考，JavaScript沒有規範比較狀態相等性的方法名稱，有賴開發者自行定義。<br>
      <br>
      有些語言只有物件型態，然而物件的相等性依舊有兩種情況，也就是比較物件狀態或是物件參考的相等性。以Ruby為例，所有資料都是物件，<span

        class="courier">==用於比較物件狀態相等性，可自行定義==方法定義比較流程，如果要比較參考相等性，則使用equal?方法</span>。<br>
      <br>
      <dl>
        <dt>語言特殊定義影響相等性判斷</dt>
      </dl>
      <br>
      程式語言普遍來說，基本型態的相等性是比較值，物件型態的相等性是比較物件狀態或物件參考，然而讓事情變得複雜的是語言中的特殊定義。<br>
      <br>
      例如Java中被<span class="courier">""</span>包括的字串無論出現幾次，只要字元序列相同，只會在字串池（String pool）產生一個String實例，因此<span

        class="courier">new String("ABC") == new String("ABC")會是false，但"ABC" == "ABC"卻會是true；如果Integer a = 100; Integer b = 100;，則a == b會是true，但a與b的值100改為200時，a == b卻會是false</span>，這主要是自動裝箱（Auto-boxing）語法動了手腳，開發者若不明就理，Wat就脫口而出。追根究底，如果開發者想要的是物件狀態相等性，那在Java中應該使用<span

        class="courier">equals方法而不是==</span>。<br>
      <br>
      JavaScript雖可使用<span class="courier">==</span>進行相等比較，然而JavaScript偏向弱型別（Weak type），也就是許多情況下可自動發生型態轉換以換取語法簡潔，例如<span

        class="courier">==可允許型態轉換後的比較，像是'123' == 123、'' == 0、[] + [] == ""等都會是true</span>，然而JavaScript過於寬鬆的<span

        class="courier">==常令開發者難以掌握，建議採用嚴格的===，只要兩邊型態不一，就會判斷為false</span>，型態相同時才進一步比較參考。有些語言中還會有些特殊值，必須用特殊方法比較。例如JavaScript中的NaN絕不等於任何值，如果想判斷某變數是否為<span

        class="courier">NaN，必須使用isNaN</span>方法來判斷。<br>
      <br>
      <dl>
        <dt>同時運用equals與hashCode的場合</dt>
      </dl>
      <br>
      有些API對相等性會有特定要求，通常要求在定義狀態相等性方法時，同時定義可傳回雜湊碼的方法。以Java為例，<span class="courier">通常要求定義equals時同時定義hashCode方法</span>，Ruby則是定義<span

        class="courier">eql?與hash</span>方法，JavaScript則視程式庫要求的方法名稱而定。舉例來說，<span

        class="courier">如果Point類別中有兩個public的x與y成員，而且僅定義equals方法如下</span>：<br>
      <div class="courier" style="margin-left: 40px;"><span><strong>if(that instanceof Point) {</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp; Point p = (Point) that;</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp; return this.x == p.x &amp;&amp; this.y == p.y;</strong></span><span><strong><br>
          </strong></span><span><strong>} <br>
            return false;</strong></span><strong><br>
        </strong></div>
      <br>
      <span class="courier">若s參考HashSet實例，呼叫s.add(new Point(1, 1))兩次，可能會收集到兩個代表座標(1, 1)的Point實例，這是因為HashSet實作會先在內部資料結構中，看看對應hashCode的雜湊桶</span>（Hash bucket）看看是否已收集物件，<span

        class="courier">如果有才進一步使用equals比較狀態相等性，如果對應的雜湊桶沒有收集物件，那麼就直接把新物件放到該雜湊桶。在新建物件時，預設的hashCode實作通常會有不同值，因此先前HashSet才會收集到兩個物件，如果Point實例代表的座標相同時不想重複收集，</span>需依Java API文件中<span

        class="courier">Object類別對於hashCode</span>的規範進行定義。<br>
      <br>
      <span class="courier">通常定義equals引用的物件資料成員，在定義hashCode時也會用來產生雜湊碼，因此定義equasl與hashCode時，應避免使用會變動的資料成員。例如上述Point類別的hashCode若定義為傳回41 * (41 + x) + y，如果p參考至座標(1, 1)的Point實例，s參考至HashSet實例，s.add(p)後若執行p.x = 2，測試set.contains(p)時就會是false，造成明明是同一實例，HashSet中卻找不到的問題，原因在於hashCode根據x、y計算雜湊值，x既然變動，算出來的雜湊值就不同，依照先前HashSet判斷物件是否重複的規則，自然就會認定set.contains(p)結果是false。</span><br>
      <br>
      <dl>
        <dt>參數化型態的相等性</dt>
      </dl>
      <br>
      在能夠參數化型態的語言中，型態參數實例化可視為新型態，例如Java中，<span class="courier">ArrayList&lt;String&gt;可視為新型態，ArrayList&lt;Integer&gt;可視為新型態，那麼new ArrayList&lt;String&gt;().equals(new ArrayList&lt;Integer&gt;())的結果會是什麼呢？答案是true！</span>Wat？<span

        class="courier">ArrayList&lt;String&gt;與ArrayList&lt;Integer&gt;不是應該算不同型態嗎？</span><br>
      <br>
      Java泛型採用型態抹除，泛型語法中指定的型態資訊主要用於編譯時期檢查，執行時期無法使用泛型語法中指定的型態資訊。具體來說，如果有個<span

        class="courier">class Basket&lt;T&gt;包裹了T[]，其equals方法定義為：</span><br>
      <div class="courier" style="margin-left: 40px;"><span><strong>if(o instanceof Basket&lt;?&gt;) {</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp; Basket that = (Basket) o;</strong></span><span><strong><br>
          </strong></span><span><strong>&nbsp;&nbsp;&nbsp; return Arrays.deepEquals(this.things, that.things); </strong></span><span><strong><br>
          </strong></span><span><strong>} </strong></span><span><strong><br>
          </strong></span><span><strong>return false;</strong></span><span><br>
        </span></div>
      <br>
      <span class="courier">程式中Basket&lt;?&gt;不可改為Basket&lt;T&gt;（會造成編譯錯誤），因為執行時期無法使用泛型語法中對T的實際型態指定（那是用於編譯時期檢查），Arrays.deepEquals會先比較this.things與that.things的長度，長度不同傳回false，如果相同則逐一取得元素使用equals比較，只要有一個比較結果為false，結果就是false，否則就為true。在new Basket&lt;Integer&gt;().equals(new Basket&lt;String&gt;())時，內部包裹物件長度都為0，沒有任何元素可比較出false的結果，所以結果自然是true。</span><br>
      <br>
      <dl>
        <dt>繼承關係下父子類別的相等性</dt>
      </dl>
      <br>
      <span class="courier">如果有Point3D繼承先前Point類別並新增z軸資訊，有趣現象就發生了，依目前Point的equals定義，new Point(1, 1).equals(new Point3D(1, 1, 1))會是true。</span>Wat？平面座標的點怎麼會等於立體座標的點？假設這是你要的結果，<span

        class="courier">因為你考慮的是立體座標的點投射在xy平面上是否相等，那麼new Point(1, 1, 1).equals(new Point3D(1, 1))會是true或是false呢？如果是false</span>，那就違反Java API文件<span

        class="courier">Object對equals</span>規範的對稱性（Symmetric）原則，<span class="courier">如果是true，那麼你顯然忽略z軸資訊。如果Point3D的equals定義傳入Point實例時只比較x、y，傳入Point3D實例就比較x、y、z呢？那麼又會違反equals</span>規範的傳遞性（Transitive）原則。<br>
      <br>
      一般來說，對於不同的類別實例，會將之視為不同。<span class="courier">上例基本上可以在instanceof判斷後，再使用this.getClass() == p.getClass()判斷，也就是直接判斷實例的類別，讓不同類別的實例視為不相等，就此例而言，使得Point只能與Point比，Point3D只能與Point3D比，直接解決不同繼承階層下equals的原則問題。</span><br>
      <br>
      Wat？為何相等性要考量這麼多因素？這無非反映出程式語言都會有些細微特性，有的特性是好的，有的特性則要迴避，使用程式庫時也要瞭解規範，網路上偶而會出現「其實你並不懂 XXX」的文章，通常也在強調對語言或技術必須有一定程度瞭解，才不至於誤觸地雷。那麼，<span

        class="courier">若a為0.1，那麼a + a + a == 0.3的結果是true還是false呢？</span>Wat？<br>
      <br>
      <br>
      <p></p>
      <p></p>
      <ul>
      </ul><br><br><div class="ad336-280" style="text-align: center;"><script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型廣告 336 x 280 --><ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-9750319131714390" data-ad-slot="9976409681"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div><br><div class="recommend" style="text-align: center;"><hr><script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 自動大小回應相符內容 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="4953478487" data-ad-format="autorelaxed"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></article></main></div></body>
<script src="http://openhome.cc/Gossip/js/ui.js"></script>
</html>
<div class="analytics"><script async src="https://www.googletagmanager.com/gtag/js?id=G-QVQQYFSC8J"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-QVQQYFSC8J');</script></div>
