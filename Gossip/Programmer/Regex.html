<!doctype html><html lang="zh-tw">
<head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="iThome 網站首載：Regex的強大與哀愁
      
      Regular Expression常縮寫為regexp、regex或RE，中文則有正則表達式、正規表達式、常規表示式等譯...">

<meta property="og:locale" content="zh_TW">
<meta property="og:title" content="Regex的強大與哀愁">
<meta property="og:type" content="article">
<meta property="og:url" content="https://openhome.cc/Gossip/Programmer/Regex.html">
<meta property="og:image" content="https://openhome.cc/Gossip/images/caterpillar_small.jpg">
<meta property="og:site_name" content="OPENHOME.CC">
<meta property="og:description" content="iThome 網站首載：Regex的強大與哀愁
      
      Regular Expression常縮寫為regexp、regex或RE，中文則有正則表達式、正規表達式、常規表示式等譯...">


    <title>Regex的強大與哀愁</title>

<link rel="stylesheet" href="http://openhome.cc/Gossip/css/pure-0.6.0/pure-min.css">

    <!--[if lte IE 8]>
        <link rel="stylesheet" href="../css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="http://openhome.cc/Gossip/css/layouts/side-menu.css">
    <!--<![endif]-->
  

     <link rel="stylesheet" href="http://openhome.cc/Gossip/css/caterpillar.css">
     <script async src="http://openhome.cc/Gossip/google-code-prettify/run_prettify.js"></script>
<!-- 網頁層級廣告 --><script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle =window.adsbygoogle || []).push({google_ad_client: "ca-pub-9750319131714390",enable_page_level_ads: true });</script></head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="Regex.html#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon --><span></span>
        
    </a>
    <div id="menu">
        <div class="pure-menu">
            <a class="pure-menu-heading" href="http://openhome.cc/Gossip/Programmer/">回程式人目錄</a>
            <ul class="pure-menu-list">
                <br><div class="social" style="text-align: center;"><a href="http://twitter.com/caterpillar"><img title="Twitter" alt="Twitter" src="../images/twitter.png"></a> <a href="http://www.facebook.com/openhome.cc"><img title="Facebook" alt="Facebook" src="../images/facebook.png"></a> </div><br><div id="search box"><script>(function() {var cx = 'partner-pub-9750319131714390:3926766884';var gcse = document.createElement('script');gcse.type = 'text/javascript';gcse.async = true;gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(gcse, s);})();</script><gcse:searchbox-only></gcse:searchbox-only></div><br><div class="ad" style="text-align: center;"><script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 2015 新版型 160 x 600 廣告 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:600px"
     data-ad-client="ca-pub-9750319131714390"
     data-ad-slot="3747048883"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div></li>
            </ul>
        </div>
    </div>

    <main id="main">
        <header class="header">
            <h1>Regex的強大與哀愁</h1>
        </header>

        <article class="content"><br><div class="ad-3" style="text-align: center;"><script async="" src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型回應式廣告 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="7104125683" data-ad-format="auto"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div> 
             iThome 網站首載：<a href="http://www.ithome.com.tw/voice/88694">Regex的強大與哀愁</a><br>
      <br>
      Regular Expression常縮寫為regexp、regex或RE，中文則有正則表達式、正規表達式、常規表示式等譯名，regex強大有目共睹，不侷限於資訊領域應用，其他領域也能夠從regex獲益良多，然而正如regex全名本身不易理解而產生各種譯名，regex語法中繁多符號的排列組合，產生出高資訊密度的regex語句，也經常令人費解而望之卻步。<br>
      &nbsp;<br>
      <dl>
        <dt>數小時到數秒鐘的魔術元素</dt>
      </dl>
      <br>
      你有一堆HTML檔案，每個HTML中都有一堆<code>&lt;img&gt;</code>標籤被<code>&lt;a&gt;&lt;/a&gt;</code>標籤包裹，每個<code>&lt;img&gt;</code>與包在外頭<code>&lt;a&gt;</code>中有一個以上的HTML屬性設定，你得把那些包在<code>&lt;img&gt;</code>外的<code>&lt;a&gt;&lt;/a&gt;</code>去除，手工檢查這堆HTML也許要花上個把個小時的時間，使用文字編輯器的"尋找"功能也是費力的一件事，如果手邊有個支援regex的工具，可指定比對<code>&lt;a.+&gt;(&lt;img.+&gt;)&lt;/a&gt;</code>並以<code>\$1</code>取代，那麼只要幾秒時間就可以完成這項任務，只要懂regex的魔術，不必是程式設計師也能辦到這種事。<br>
      <br>
      就像魔術，只要你懂其中的元素就會恍然大悟，<code>&lt;a.+&gt;(&lt;img.+&gt;)&lt;/a&gt;</code>中可以先拿掉<code>.+()</code>這幾個符號，剩下的就是<code>&lt;a&gt;&lt;img&gt;&lt;/a&gt;</code>，很簡單的意涵，找出被<code>&lt;a&gt;&lt;/a&gt;</code>中包裹<code>&lt;img&gt;</code>的文字，regex的一部份就是由這類按照字面意義比對的字面字元（Literal）組成，那麼實現魔術的部份就是<code>.+()</code>這幾個符號了，這類符號是不照字面比對的詮譯字元（metacharacter），在不同情境中可能有不同的意涵，以這邊的regex來說，「<code>.</code>」表示任意字元，「<code>+</code>」表示可以出現一次以上，「<code>.+</code>」就表示「有一個以上的任意字元」，<code>&lt;a.+&gt;</code>或<code>&lt;img.+&gt;</code>就表示<code>&lt;a&gt;</code>或<code>&lt;img&gt;</code>中可以有任意個字元，也就作為HTML屬性設定的那些字元，<code>(&lt;img.+&gt;)</code>表示被<code>&lt;img.+&gt;</code>比對到的文字納為一組，使用<code>\$1</code>就可以取得被比對到的這組文字，將<code>&lt;a.+?&gt;(&lt;img.+?&gt;)&lt;/a&gt;</code>比對到的文字，以<code>&lt;img.+&gt;</code>比對到的文字取代，結果就是去除了<code>&lt;img&gt;</code>外的<code>&lt;a&gt;&lt;/a&gt;</code>。<br>
      <br>
      按照字面搜尋的功能，基本的文字編輯器就做得到，顯然地，讓魔術得以實現的是詮譯字元，網路上找到數不清的regex文件，多是在告訴你詮譯字元代表哪些規則。使用regex的時機提示就是，你在處理文字檔時有了重複操作，把你的重複操作步驟寫下來，找出比對規則，因為電腦看不懂人類的文字，因此，你要使用電腦看得懂的詮譯字元告訴它字面文字外的比對規則，只要有了規則，電腦絕對比人類擅長處理重複的事。<br>
      <br>
      <dl>
        <dt>看似雜訊的詮譯字元</dt>
      </dl>
      <br>
      如果你沒有學過regex，不瞭解各個詮譯字元在regex中代表的意義，單看<code>&lt;img.+&gt;</code>只覺得其中有毫無意義的符號，實際上，詮譯字元真正的意義，在於統一了描述規則的方式，舉例來說，對方才的HTML案例，「<code>&lt;img&gt;</code>中有一種以上的HTML屬性設定」、「<code>&lt;img&gt;</code>中有一個以上的字元」都可以是描述的方式，也許你寫下的需求描述也與我不同，然而，詮譯字元給了我們共同的描述方式，只要我們都學過基本的regex，就都能理解<code>&lt;img.+&gt;</code>代表什麼意義。<br>
      <br>
      詮譯字元是文字處理中的「模式」，文字處理中會有「<code>X</code>或<code>Y</code>」的比對，regex可以寫為<code>X|Y</code>，文字處理中會有多個「或」的需求，因此有字元類（Character class）結構，文字處理會有「出現幾次」的描述，因此會有量詞（Quantifier），你也需要描述定位，因此需要錨點（Anchor），對於某組具有相同模式的文字，你可能會很感興趣，因此才會有分組（Group），類似設計模式提供了開發者共同的設計語言，詮譯字元也為文字處理統一了描述的方式。<br>
      <br>
      對於簡單地搜尋比對需求，使用現代程式語言也許只要短短幾行就辦得到，只要語言的語法或API命名具有意義，也容易閱讀出比對描述的意義；regex使用符號來代表規則描述，當一堆符號組合在一起時，就會包括極為大量的資訊，試著用程式語言來實作出<code>&lt;a.+&gt;(&lt;img.+&gt;)&lt;/a&gt;</code>應有的效果，就會發現資訊的龐大程度；另一方面，完整的regex其實是逐步加入小規則建構起來的，如果當初沒有將建構順序記錄下來，未來在看到完整的regex時，就會因為難以理解當初建構的順序，因而不理解regex甚至弄錯真正想要比對的對象。<br>
      <br>
      雖然詮譯字元給了共同的描述方式，然而，從人類文字轉譯為詮譯字元的過程中，容易有失去準頭的問題，這就類似程式語言或人類語言在轉譯時也不是一對一的情況，特別是在對另一門語言不瞭解的情況下，轉譯就更容易出錯。「<code>&lt;img&gt;</code>中有一個以上的字元」這個描述轉譯為regex時，寫為<code>&lt;img+&gt;</code>看似正確，因為+代表一個以上的字元，實際上是錯的，因為這只會比對到<code>&lt;img&gt;</code>、<code>&lt;imgg&gt;</code>、<code>&lt;imggg&gt;</code>這類的情況，因為<code>+</code>是配合著<code>g</code>，<code>&lt;img+&gt;</code>是指「<code>&lt;img&gt;</code>中的<code>g</code>可以有一個或多個」。<br>
      <br>
      <dl>
        <dt>理解文字內容並善用工具</dt>
      </dl>
      <br>
      就像樂高一樣，每個零件都很簡單，然而可以用各種方式組合出複雜成品，完整的regex實際上也是由許多小零件組合而成，只是在運用這些小零件之前，你得逐步理解要處理的文件內容，先用一般文字寫下你的需求，然而從最簡單的字面文字開始建構regex，測試一下尋找到的對象，然後加入新的規則再測試，在這個反覆過程中，你往往會發現，自己一開始對文件中要比對的目標內容理解度並不是那麼精確，你得重新調整對目標內容的認識，然後用更精確的規則來描述它，並加入regex的建構之中。<br>
      <br>
      舉例來說，「<code>&lt;img&gt;</code>中有一種以上的HTML屬性設定」這個需求是籠統的，你用<code>&lt;img&gt;</code>這個regex作為開頭，實際比對不出HTML中任何東西，用<code>&lt;img</code>開始測試才能有些結果，然後使用<code>&lt;img.測試，接著是&lt;img.+測試時，你發現找出的東西除了&lt;img&gt;標籤外，後頭的東西也找出來了，於是再使用&lt;img.+&gt;&lt;/a&gt;加上限制，然後再往前依&gt;&lt;img.+&gt;&lt;/a&gt;</code>、<code>.+&gt;&lt;img.+&gt;&lt;/a&gt;</code>、<code>a.+&gt;&lt;img.+&gt;&lt;/a&gt;</code>與<code>&lt;a.+&gt;&lt;img.+&gt;&lt;/a&gt;</code>的順序，得到完整的regex。根據你對文件內容的理解方式，也會影響建構regex的順序，以這邊的需求來說，你也可以從<code>&lt;a</code>開始。完整的regex建構，其實也像程式設計一樣，都是從問題子集開始個別擊破，對於每個比對子集可以試著加入<code>()</code>加以分組，對於regex日後的解讀會有所幫助。<br>
      <br>
      在逐步建構regex的過程中，一個方便的工具是必要的，像是老牌的regex建構工具Expresso，可以方便你一邊建構regex一邊即時地測試，建構regex時的設計選單，可以讓你不用查閱詮譯字元的意義或誤打詮譯字元，Expresso本身也內建了一些常用的regex。如果想在產生regex的過程中順便記錄下建構過程，Github上有個有趣的VerbalExpressions專案，它提供了Java、Python、JavaScript、Ruby等語言的實作，可以讓你用流暢API風格來建構regex，例如若使用Java實作版本，可以撰寫<code>new VerbalExpression.Builder().find("&lt;a").something().find("&gt;&lt;img").something().find("&gt;&lt;/a&gt;").build()</code>，產生的regex就有<code>&lt;a.+&gt;(&lt;img.+&gt;)&lt;/a&gt;</code>的比對效果，既表現regex的順序，也不用記憶詮譯字元的意義。<br>
      <br>
      <dl>
        <dt>將regex視為語言</dt>
      </dl>
      <br>
      雖然regex一般人會將它看成是一種比對規則的表示方式，實際上它更像是門語言，VerbalExpressions專案只是突顯了這個事實，進一步賦予詮譯字元的符號有意義的名稱，如果你看看VerbalExpressions的Ruby實作版本，就更能瞭解這個事實，現在多數程式語言都會內建對regex的直接或間接支援，這讓regex就像是個外部特定領域語言（Domain-specific language），專門用來處理文字比對相關事務，而不是使用既有語言的語法寫一大堆繁複的程式碼來解決相同的事。<br>
      <br>
      就如同各門程式語言的學習，你該學習的並不只是語法，而是該門語言背後的文化、思考與典範，既然regex可視為一門語言，一門專用於文字比對的特定領域語言，就代表著你要理解該門語言的思考框架，像是理解文件內容、尋找目標規則、個別小任務的擊破與組合等，而不只是僅止於跟那些奇妙的符號搏鬥。<br>
      <br>
      <br>
      <br>
      <br>
      <p></p>
      <p></p>
      <ul>
      </ul><br><br><div class="ad336-280" style="text-align: center;"><script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型廣告 336 x 280 --><ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-9750319131714390" data-ad-slot="9976409681"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div><br><div class="recommend" style="text-align: center;"><hr><script async src="http://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 自動大小回應相符內容 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="4953478487" data-ad-format="autorelaxed"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></article></main></div></body>
<script src="http://openhome.cc/Gossip/js/ui.js"></script>
</html>
<div class="analytics"><script async src="https://www.googletagmanager.com/gtag/js?id=G-QVQQYFSC8J"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-QVQQYFSC8J');</script></div>
