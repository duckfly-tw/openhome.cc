<!doctype html><html lang="zh-tw">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="如果想做個圓形迷宮，方式是之是透過遮罩，例如，透過圓形遮罩結合〈迷宮與遮罩〉的程式，可以做出以下的迷宮：

不過，也許會覺得用這種方式做圓形迷宮有點投機取巧，畢竟，你可能看過這樣的圓形迷宮：

這種迷...">

    <meta property="og:locale" content="zh_TW">
    <meta property="og:title" content="Theta 迷宮（一）">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://openhome.cc/Gossip/P5JS/ThetaMaze.html">
    <meta property="og:image" content="https://openhome.cc/Gossip/images/caterpillar_small.jpg">
    <meta property="og:site_name" content="OPENHOME.CC">
    <meta property="og:description" content="如果想做個圓形迷宮，方式是之是透過遮罩，例如，透過圓形遮罩結合〈迷宮與遮罩〉的程式，可以做出以下的迷宮：

不過，也許會覺得用這種方式做圓形迷宮有點投機取巧，畢竟，你可能看過這樣的圓形迷宮：

這種迷...">

    <title>Theta 迷宮（一）</title>

    <link rel="stylesheet" href="../css/pure-0.6.0/pure-min.css">

    <!--[if lte IE 8]>
        <link rel="stylesheet" href="../css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="../css/layouts/side-menu.css">
    <!--<![endif]-->
  

     <link rel="stylesheet" href="../css/caterpillar.css">
     <script async src="../google-code-prettify/run_prettify.js"></script>
     <!-- 網頁層級廣告 --><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle =window.adsbygoogle || []).push({google_ad_client: "ca-pub-9750319131714390",enable_page_level_ads: true });</script></head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="ThetaMaze.html#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
    <div id="menu">
        <div class="pure-menu">
            <a class="pure-menu-heading" href="index.html">回 p5.js</a>
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><br><div class="social" style="text-align: center;"><a href="http://twitter.com/caterpillar"><img title="Twitter" alt="Twitter" src="../images/twitter.png"></a> <a href="http://www.facebook.com/openhome.cc"><img title="Facebook" alt="Facebook" src="../images/facebook.png"></a></div><br> <div id="search box"><script>(function() {var cx = 'partner-pub-9750319131714390:3926766884';var gcse = document.createElement('script');gcse.type = 'text/javascript';gcse.async = true;gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(gcse, s);})();</script><gcse:searchbox-only></gcse:searchbox-only></div><br><div class="ad" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 2015 新版型 160 x 600 廣告 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:600px"
     data-ad-client="ca-pub-9750319131714390"
     data-ad-slot="3747048883"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div></li>
            </ul>
        </div>
    </div>

    <main id="main">
        <header class="header">
            <h1>Theta 迷宮（一）</h1>
        </header>

        <article class="content">
            <br><div class="ad-3" style="text-align: center;"><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型回應式廣告 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="7104125683" data-ad-format="auto"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div> 
            
            <p>如果想做個圓形迷宮，方式之一是透過遮罩，例如，透過圓形遮罩結合〈<a href="MazeMasking.html">迷宮與遮罩</a>〉的程式，可以做出以下的迷宮：</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/ThetaMaze-1.JPG" alt="Theta 迷宮"  /></div></div></p>
<p>不過，也許會覺得用這種方式做圓形迷宮有點投機取巧，畢竟，你可能看過這樣的圓形迷宮：</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/ThetaMaze-2.JPG" alt="Theta 迷宮"  /></div></div></p>
<p>這種迷宮是基於極座標繪製而成，常被稱為 Theta 迷宮，有沒有可能基於〈<a href="RecursiveBacktrackerMaze.html">遞迴回溯迷宮</a>〉實作 Theta 迷宮呢？畢竟，〈<a href="HexagonMaze.html">蜂巢狀迷宮</a>〉就是基於遞迴回溯迷宮，只是繪圖上做些變化。</p>
<h1>基於方形迷宮變化</h1>
<p>基本上是可以，出發點是可以將底下的圖形：</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/ThetaMaze-3.JPG" alt="Theta 迷宮"  /></div></div></p>
<p>繞為底下的圓：</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/ThetaMaze-4.JPG" alt="Theta 迷宮"  /></div></div></p>
<p>若要配合遞迴回溯迷宮的細胞索引方式，就像是將矩形迷宮轉 90 度後，將每一列剪下來，變成環狀，細胞索引 y 就是 y 環索引，索引 x 就是每一環細胞的逆時針 x 索引：</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/ThetaMaze-5.JPG" alt="Theta 迷宮"  /></div></div></p>
<p>如果只是將方拉成圓，你也可以不用如上拉成圓，只不過這樣拉圓，配合原本方形迷宮的索引方式會比較方便罷了，顯然地，若要用這樣的方式建立 Theta 迷宮，<code>Maze</code> 的實作完全不用更改，純粹就是繪圖的方式罷了。</p>
<p>因為將方形迷宮逆時針轉 90 度了，方形迷宮中每個細胞的上與右牆，會變成：</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/ThetaMaze-6.JPG" alt="Theta 迷宮"  /></div></div></p>
<p>將 <code>TWO_PI</code> 除以行（column） 數，就可以求得 <code>Θ</code>，方形迷宮的 <code>x</code> 索引，就是對應至的 <code>Θ * x</code> 與 <code>Θ * (x + 1)</code> 間的弧，圓形細胞的大小會以上圖中的「細胞寬度」決定，圖中定義了「內半徑向量」與「外半徑向量」，是因為 p5.js 中提供了 <code>p5.Vector</code>，透過這兩個向量的操作，可以很簡單的取得繪製上牆、右牆必要的頂點。</p>
<h1>繪製 Theta 迷宮</h1>
<p>從上頭的描述可以知道，〈<a href="RecursiveBacktrackerMaze.html">遞迴回溯迷宮</a>〉的 <code>Maze</code> 實作不用任何修改，需要的就只是繪製方形改為繪製圓形，一個簡化繪製程式實作的方式是透過 <code>p5.Vector</code>，這樣就不用直接使用三角函式了：</p>
<pre class="prettyprint"><code lang="javascript">function drawMaze(maze, cellWidth) {
    const thetaStep = TWO_PI / maze.columns;

    maze.cells.forEach(cell =&gt; {
        const innerR = (cell.y) * cellWidth;
        const outerR = (cell.y + 1) * cellWidth;   
        const theta1 = -thetaStep * cell.x;
        const theta2 = -thetaStep * (cell.x + 1);

        const innerVt1 = p5.Vector.fromAngle(theta1, innerR);
        const innerVt2 = p5.Vector.fromAngle(theta2, innerR);
        const outerVt2 = p5.Vector.fromAngle(theta2, outerR);

        if(cell.wallType === Maze.TOP_WALL || cell.wallType === Maze.TOP_RIGHT_WALL) {
            line(innerVt1.x, innerVt1.y, innerVt2.x, innerVt2.y);
        }


        if(cell.wallType === Maze.RIGHT_WALL || cell.wallType === Maze.TOP_RIGHT_WALL) {
            line(innerVt2.x, innerVt2.y, outerVt2.x, outerVt2.y);
        }
    });

    const r = cellWidth * (maze.rows);
    for(let theta = 0; theta &lt; TWO_PI; theta = theta + thetaStep) {
        const vt1 = p5.Vector.fromAngle(theta, r);
        const vt2 = p5.Vector.fromAngle(theta + thetaStep, r);
        line(vt1.x, vt1.y, vt2.x, vt2.y);
    }
}
</code></pre>
<p>然而，若直接使用這個 <code>drawMaze</code> 來繪製 <code>rows</code>、<code>columns</code> 都是 8 的迷宮，會長這樣：</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/ThetaMaze-7.JPG" alt="Theta 迷宮"  /></div></div></p>
<p>怎麼越外圍開口越大呢？而且，為什麼我是使用 <code>line</code> 來繪製啊？使用 <code>line</code> 來繪製，就是為了突顯越外圍開口越大這件事，實際上，就算你試圖使用 <code>arc</code> 來繪製，試著讓開口變小，也不能改變這迷宮在繪製時，越外環細胞越大的事實，畢竟，這只是純粹將方形拉成圓形罷了。</p>
<p>單純只是想讓這迷宮好看一些，不要內外環開口差距太明顯的話，可以讓最內環的半徑大一些，然後減少 <code>rows</code>、增加 <code>columns</code>：</p>
<pre class="prettyprint"><code lang="javascript">function drawMaze(maze, cellWidth) {
    const thetaStep = TWO_PI / maze.columns;

    maze.cells.forEach(cell =&gt; {
        // 增加最內環的半徑
        const innerR = (cell.y + 4) * cellWidth;
        const outerR = (cell.y + 5) * cellWidth;   
        ...
    });

    // 最外的牆也要做調整
    const r = cellWidth * (maze.rows + 4);
    for(let theta = 0; theta &lt; TWO_PI; theta = theta + thetaStep) {
        const vt1 = p5.Vector.fromAngle(theta, r);
        const vt2 = p5.Vector.fromAngle(theta + thetaStep, r);
        line(vt1.x, vt1.y, vt2.x, vt2.y);
    }   
}
</code></pre>
<p>這樣畫出來就會好一些：</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/ThetaMaze-8.JPG" alt="Theta 迷宮"  /></div></div></p>
<p>只不過這比較算是迷宮環了，或許在中間開個口會比較好，當寶物室？</p>
<pre class="prettyprint"><code lang="javascript">function drawMaze(maze, cellWidth) {
    const thetaStep = TWO_PI / maze.columns;

    maze.cells.forEach(cell =&gt; {
        // (0, 0) 不畫牆
        if(cell.x === 0 &amp;&amp; cell.y === 0) {
            return;
        } 
        ...
    });

    ...
}
</code></pre>
<p>另一個問題是，角度為 0 時的牆始終是封閉的，也就是以上的繪製方法，右方總是會有一條實線？當然，因為是將方形拉成圓，記得嗎？方形迷宮時，最右邊的牆是不會打通的，因為是邊界嘛！</p>
<p>如果你讓最右邊的牆可以打通，這意謂著穿越回到最左邊的細胞，反之亦然，這樣拉成圓時，表示可以順、逆時針無阻礙地打牆，這只要在 <code>Maze</code> 的 <code>nextX</code> 小修改一下：</p>
<pre class="prettyprint"><code lang="javascript">function nextX(maze, x, dir) {
    let nx = x + [1, 0, -1, 0][dir];
    return nx &gt;= 0 ? (nx % maze.columns) : (nx + maze.columns);
}
</code></pre>
<p>當然，呼叫 <code>nextX</code> 的地方，也要記得改一下傳入 <code>Maze</code> 實例，而 <code>visitRight</code>、<code>visitTop</code>、<code>visitLeft</code>、<code>visitBottom</code>，不能只是對 <code>currentCell.x</code> 加減 1，改呼叫 <code>nextX</code> 才行：</p>
<pre class="prettyprint"><code lang="javascript">function visitRight(maze, currentCell) {
    if(currentCell.wallType === Maze.TOP_RIGHT_WALL) {
        currentCell.wallType = Maze.TOP_WALL;
    }
    else {
        currentCell.wallType = Maze.NO_WALL;
    }
    maze.cells.push(cell(nextX(maze, currentCell.x, R), nextY(currentCell.y, R), Maze.TOP_RIGHT_WALL));
}

function visitTop(maze, currentCell) {
    if(currentCell.wallType === Maze.TOP_RIGHT_WALL) {
        currentCell.wallType = Maze.RIGHT_WALL;
    }
    else {
        currentCell.wallType = Maze.NO_WALL;
    }
    maze.cells.push(cell(nextX(maze, currentCell.x, T), nextY(currentCell.y, T), Maze.TOP_RIGHT_WALL));
}

function visitLeft(maze, currentCell) {
    maze.cells.push(cell(nextX(maze, currentCell.x, L), nextY(currentCell.y, L), Maze.TOP_WALL));
}

function visitBottom(maze, currentCell) {
    maze.cells.push(cell(nextX(maze, currentCell.x, B), nextY(currentCell.y, B), Maze.RIGHT_WALL));
}
</code></pre>
<p>這樣的話就可以繪製出以下的迷宮：</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/ThetaMaze-9.JPG" alt="Theta 迷宮"  /></div></div></p>
<p>要說這是 Theta 迷宮，也算是啦！只不過不是這篇文件一開頭看到的那個 Theta 迷宮，那個 Theta 迷宮的製作方式，就留待下一篇來探討了。</p>
<p>底下列出至今的成果：</p>
<script type="text/p5" data-p5-version="1.1.9" data-height="400" data-preview-width="400">function setup() {
    createCanvas(300, 300);
    noLoop();
}

function draw() {
    background(220);
    
    const rows = 6;
    const columns = 32;
    
    const cellWidth = (width - 60) / (rows * 3);
    const maze = new Maze(rows, columns);

    maze.backtracker();
	
    strokeWeight(5);
    translate(width / 2 , height / 2);
    drawMaze(maze, cellWidth);
}

function cell(x, y, wallType) {
    return {x, y, wallType};
}

class Maze {
    constructor(rows, columns) {
	    this.rows = rows;
		this.columns = columns;
	}
	
	backtracker(x = 0, y = 0) {
        this.cells = [];
	    this.cells.push(cell(x, y, Maze.TOP_RIGHT_WALL));
		backtracker(this);
	}
}

Maze.NO_WALL = 'no_wall';
Maze.TOP_WALL = 'top_wall';
Maze.RIGHT_WALL = 'right_wall';
Maze.TOP_RIGHT_WALL = 'top_right_wall';

function notVisited(maze, x, y) {
    return maze.cells.find(cell => cell.x === x && cell.y === y) === undefined;
}

function isVisitable(maze, x, y) {
    return y >= 0 && y < maze.rows &&    
           x >= 0 && x < maze.columns && 
		   notVisited(maze, x, y); 
} 

const R = 0; 
const T = 1; 
const L = 2; 
const B = 3; 

function nextX(maze, x, dir) {
    let nx = x + [1, 0, -1, 0][dir];
    return nx >= 0 ? (nx % maze.columns) : (nx + maze.columns);
}

function nextY(y, dir) {
    return y + [0, -1, 0, 1][dir];
}

function visitRight(maze, currentCell) {
    if(currentCell.wallType === Maze.TOP_RIGHT_WALL) {
	    currentCell.wallType = Maze.TOP_WALL;
	}
	else {
	    currentCell.wallType = Maze.NO_WALL;
	}
	maze.cells.push(cell(nextX(maze, currentCell.x, R), nextY(currentCell.y, R), Maze.TOP_RIGHT_WALL));
}

function visitTop(maze, currentCell) {
    if(currentCell.wallType === Maze.TOP_RIGHT_WALL) {
	    currentCell.wallType = Maze.RIGHT_WALL;
	}
	else {
	    currentCell.wallType = Maze.NO_WALL;
	}
	maze.cells.push(cell(nextX(maze, currentCell.x, T), nextY(currentCell.y, T), Maze.TOP_RIGHT_WALL));
}

function visitLeft(maze, currentCell) {
	maze.cells.push(cell(nextX(maze, currentCell.x, L), nextY(currentCell.y, L), Maze.TOP_WALL));
}

function visitBottom(maze, currentCell) {
	maze.cells.push(cell(nextX(maze, currentCell.x, B), nextY(currentCell.y, B), Maze.RIGHT_WALL));
}

function visit(maze, currentCell, dir) {
    switch(dir) {
	    case R:  
		    visitRight(maze, currentCell); break;
		case T:
		    visitTop(maze, currentCell); break;
		case L:
		    visitLeft(maze, currentCell); break;
		case B:
		    visitBottom(maze, currentCell); break;
	}
}

function backtracker(maze) {
    const currentCell = maze.cells[maze.cells.length - 1];
    const rdirs = shuffle([R, T, L, B]);
	const vdirs = rdirs.filter(dir => {
	    const nx = nextX(maze, currentCell.x, dir);
		const ny = nextY(currentCell.y, dir);
		return isVisitable(maze, nx, ny);
	});
	
	if(vdirs.length === 0) {
	    return;
	}
	
	vdirs.forEach(dir => {
	    const nx = nextX(maze, currentCell.x, dir);
		const ny = nextY(currentCell.y, dir);
		
		if(isVisitable(maze, nx, ny)) {
		    visit(maze, currentCell, dir);
			backtracker(maze);
		}
	});
}

function drawMaze(maze, cellWidth) {
    const thetaStep = TWO_PI / maze.columns;
  
    maze.cells.forEach(cell => {
        if(cell.x === 0 && cell.y === 0) {
            return;
        }   
		
        const innerR = (cell.y + 4) * cellWidth;
        const outerR = (cell.y + 5) * cellWidth;   
        const theta1 = -thetaStep * cell.x;
        const theta2 = -thetaStep * (cell.x + 1);
      
        const innerVt1 = p5.Vector.fromAngle(theta1, innerR);
        const innerVt2 = p5.Vector.fromAngle(theta2, innerR);
        const outerVt2 = p5.Vector.fromAngle(theta2, outerR);
        
        if(cell.wallType === Maze.TOP_WALL || cell.wallType === Maze.TOP_RIGHT_WALL) {
            line(innerVt1.x, innerVt1.y, innerVt2.x, innerVt2.y);
        }
               

        if(cell.wallType === Maze.RIGHT_WALL || cell.wallType === Maze.TOP_RIGHT_WALL) {
            line(innerVt2.x, innerVt2.y, outerVt2.x, outerVt2.y);
        }
	});
    
    const r = cellWidth * (maze.rows + 4);
    for(let theta = 0; theta < TWO_PI; theta = theta + thetaStep) {
        const vt1 = p5.Vector.fromAngle(theta, r);
        const vt2 = p5.Vector.fromAngle(theta + thetaStep, r);
        line(vt1.x, vt1.y, vt2.x, vt2.y);
    }
}
</script>

            
           <br><br><div class="ad336-280" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型廣告 336 x 280 --><ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-9750319131714390" data-ad-slot="9976409681"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div><br><div class="recommend" style="text-align: center;"><hr><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 自動大小回應相符內容 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="4953478487" data-ad-format="autorelaxed"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>
        </article>
    </main>
</div></body>
</html>
<script src="https://toolness.github.io/p5.js-widget/p5-widget.js"></script>
<script src="../js/ui.js"></script>
<div class="analytics"><script async src="https://www.googletagmanager.com/gtag/js?id=G-QVQQYFSC8J"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-QVQQYFSC8J');</script></div>
