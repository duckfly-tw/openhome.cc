<!doctype html><html lang="zh-tw">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="在 Marching squares（一） 與 Marching squares（二） 談到了如何建立等值線，現在的問題是，若想要的是這樣的輪廓圖呢？

單純地將等值線加粗，沒辦法構成這樣的圖形，你需...">

    <meta property="og:locale" content="zh_TW">
    <meta property="og:title" content="Marching squares（三）">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://openhome.cc/Gossip/P5JS/MarchingSquares3.html">
    <meta property="og:image" content="https://openhome.cc/Gossip/images/caterpillar_small.jpg">
    <meta property="og:site_name" content="OPENHOME.CC">
    <meta property="og:description" content="在 Marching squares（一） 與 Marching squares（二） 談到了如何建立等值線，現在的問題是，若想要的是這樣的輪廓圖呢？

單純地將等值線加粗，沒辦法構成這樣的圖形，你需...">

    <title>Marching squares（三）</title>

    <link rel="stylesheet" href="../css/pure-0.6.0/pure-min.css">

    <!--[if lte IE 8]>
        <link rel="stylesheet" href="../css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="../css/layouts/side-menu.css">
    <!--<![endif]-->
  

     <link rel="stylesheet" href="../css/caterpillar.css">
     <script async src="../google-code-prettify/run_prettify.js"></script>
     <!-- 網頁層級廣告 --><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle =window.adsbygoogle || []).push({google_ad_client: "ca-pub-9750319131714390",enable_page_level_ads: true });</script></head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="MarchingSquares3.html#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
    <div id="menu">
        <div class="pure-menu">
            <a class="pure-menu-heading" href="index.html">回 P5JS</a>
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><br><div class="social" style="text-align: center;"><a href="http://twitter.com/caterpillar"><img title="Twitter" alt="Twitter" src="../images/twitter.png"></a> <a href="http://www.facebook.com/openhome.cc"><img title="Facebook" alt="Facebook" src="../images/facebook.png"></a></div><br> <div id="search box"><script>(function() {var cx = 'partner-pub-9750319131714390:3926766884';var gcse = document.createElement('script');gcse.type = 'text/javascript';gcse.async = true;gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(gcse, s);})();</script><gcse:searchbox-only></gcse:searchbox-only></div><br><div class="ad" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 2015 新版型 160 x 600 廣告 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:600px"
     data-ad-client="ca-pub-9750319131714390"
     data-ad-slot="3747048883"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div></li>
            </ul>
        </div>
    </div>

    <main id="main">
        <header class="header">
            <h1>Marching squares（三）</h1>
        </header>

        <article class="content">
            <br><div class="ad-3" style="text-align: center;"><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型回應式廣告 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="7104125683" data-ad-format="auto"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div> 
            
            <p>在 <a href="MarchingSquares.html">Marching squares（一）</a> 與 <a href="MarchingSquares2.html">Marching squares（二）</a> 談到了如何建立等值線，現在的問題是，若想要的是這樣的輪廓圖呢？</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/MarchingSquares3-1.JPG" alt="Marching squares（三）"  /></div></div></p>
<p>單純地將等值線加粗，沒辦法構成這樣的圖形，你需要的圖形就像梯田，在一個高度的下界與上界之間，畫出一個平面的帶狀區域，</p>
<p>Marching squares 的等值線演算，可以擴展為等值帶演算，你會指定高度的下界與上界，因此每一格資料不僅是被標示為 0 與 1，而會是個三元值，分別代表小於下界、在上下界之間、高於上界，若分別標示為 0、1、2，那麼以維基百科 <a href="https://en.wikipedia.org/wiki/Marching_squares">Marching squares</a> 中的圖來說，就會有 82 種可能性。</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/MarchingSquares3-2.JPG" alt="Marching squares（三）"  /></div></div></p>
<p>上圖是將維基百科 <a href="https://en.wikipedia.org/wiki/Marching_squares">Marching squares</a> 中的圖，加上了細胞角落標示的編號，等值帶是藍色區域的部份（也就是 1111 那個顏色），乍看 82 種可能性，要為等值帶建立頂點很繁雜，不過有些頂點旋轉後是相同的，圖中將它們分類以虛線框圍起來了，這麼一來，基本的等值帶頂點就只有 34 種，其餘就旋轉頂點，就能得到相對應的等值帶。</p>
<p>在程式實作方法類似等值線，首先標示每一格的資料，作為細胞的一角：</p>
<pre class="prettyprint"><code lang="javascript">function mapToCorners(values, threshold) {
    const corners = []
    for(let r = 0; r &lt; values.length; r++) {
        const row = [];
        for(let c = 0; c &lt; values[r].length; c++) {
            const v = values[r][c];
            row.push({
                vt : createVector(c, r, values[r][c]),
                thresholdLabel: v &gt; threshold.upper ? '2' : (v &lt;= threshold.upper &amp;&amp; v &gt;= threshold.lower ? '1' : '0')
            });
        }
        corners.push(row);
    }
    return corners;
}
</code></pre>
<p>再來建立細胞資料，每個細胞資料會包含四個角落的向量，以及角落值的編號：</p>
<pre class="prettyprint"><code lang="javascript">function flatMapToCells(corners) {
    const cells = [];
    for(let r = 0; r &lt; corners.length - 1; r++) {
        for(let c = 0; c &lt; corners[r].length - 1; c++) {
            cells.push({
                vts: [
                    corners[r][c].vt,
                    corners[r + 1][c].vt,
                    corners[r + 1][c + 1].vt,
                    corners[r][c + 1].vt
                ], 
                cornerCase: cornerCase([
                    corners[r][c],
                    corners[r + 1][c],
                    corners[r + 1][c + 1],
                    corners[r][c + 1]
               ])
            });
        }
    }
    return cells;
}

function cornerCase(corners) {
    return corners.map(corner =&gt; corner.thresholdLabel).join('');
}
</code></pre>
<p>有了細胞資料之後，接下來就是建立等值帶了，這邊需要更細心一些，雖然歸納為 34 種了，也還是很多啦！總之也是小心座標點別對應錯誤了：</p>
<pre class="prettyprint"><code lang="javascript">function case1222(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[vts[0], inter_pt(vts[0], vts[1], U), inter_pt(vts[0], vts[3], U)]];
}

function case2111(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[inter_pt(vts[0], vts[3], U), inter_pt(vts[0], vts[1], U), vts[1], vts[2], vts[3]]];
}

function case0111(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[inter_pt(vts[0], vts[3], L), inter_pt(vts[0], vts[1], L), vts[1], vts[2], vts[3]]];
}

function case1000(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[vts[0], inter_pt(vts[0], vts[1], L), inter_pt(vts[0], vts[3], L)]];
}

function case0222(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[inter_pt(vts[0], vts[3], L), inter_pt(vts[0], vts[1], L), inter_pt(vts[0], vts[1], U), inter_pt(vts[0], vts[3], U)]];
}

function case2211(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[inter_pt(vts[0], vts[3], U), inter_pt(vts[1], vts[2], U), vts[2], vts[3]]];
}

function case0011(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[inter_pt(vts[0], vts[3], L), inter_pt(vts[1], vts[2], L), vts[2], vts[3]]];
}

function case2000(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[inter_pt(vts[0], vts[3], U), inter_pt(vts[0], vts[1], U), inter_pt(vts[0], vts[1], L), inter_pt(vts[0], vts[3], L)]];
}

function case2201(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[inter_pt(vts[0], vts[3], U), inter_pt(vts[1], vts[2], U), inter_pt(vts[1], vts[2], L), inter_pt(vts[2], vts[3], L), vts[3]]];
}

function case2210(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[inter_pt(vts[0], vts[3], U), inter_pt(vts[1], vts[2], U), vts[2], inter_pt(vts[2], vts[3], L), inter_pt(vts[0], vts[3], L)]];
}

function case0012(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[inter_pt(vts[0], vts[3], L), inter_pt(vts[1], vts[2], L), vts[2], inter_pt(vts[2], vts[3], U), inter_pt(vts[0], vts[3], U)]];
}

function case0021(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[inter_pt(vts[0], vts[3], L), inter_pt(vts[1], vts[2], L), inter_pt(vts[1], vts[2], U), inter_pt(vts[2], vts[3], U), vts[3]]];
}

function case1120(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[vts[0], vts[1], inter_pt(vts[1], vts[2], U), inter_pt(vts[2], vts[3], U), inter_pt(vts[2], vts[3], L), inter_pt(vts[0], vts[3], L)]];
}

function case1102(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[vts[0], vts[1], inter_pt(vts[1], vts[2], L), inter_pt(vts[2], vts[3], L), inter_pt(vts[2], vts[3], U), inter_pt(vts[0], vts[3], U)]];
}

function case1012(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[vts[0], inter_pt(vts[0], vts[1], L), inter_pt(vts[1], vts[2], L), vts[2], inter_pt(vts[2], vts[3], U), inter_pt(vts[0], vts[3], U)]];
}

function case2121(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    const cp = center(vts);

    if(cp.z &gt; U) {
        return [
            [inter_pt(vts[0], vts[1], U), vts[1], inter_pt(vts[1], vts[2], U), inter_pt(vts[1], cp, U)], [inter_pt(vts[0], vts[3], U), inter_pt(cp, vts[3], U), inter_pt(vts[2], vts[3], U), vts[3]]
        ];
    }
    else if(cp.z &lt;= U &amp;&amp; cp.z &gt;= L) {
        return [
            [inter_pt(vts[0], vts[3], U), inter_pt(vts[0], cp, U), inter_pt(vts[0], vts[1], U), vts[1], inter_pt(vts[1], vts[2], U), inter_pt(vts[2], cp, U), inter_pt(vts[2], vts[3], U), vts[3]]
        ];
    }

    return [
        [inter_pt(vts[0], vts[3], U), inter_pt(vts[0], cp, U), inter_pt(vts[0], cp, L), inter_pt(vts[3], cp, L), inter_pt(vts[2], cp, L), inter_pt(vts[2], cp, U), inter_pt(vts[2], vts[3], U), vts[3]], 
        [inter_pt(vts[2], vts[1], U), inter_pt(vts[2], cp, U), inter_pt(vts[2], cp, L), inter_pt(vts[1], cp, L), inter_pt(vts[0], cp, L), inter_pt(vts[0], cp, U), inter_pt(vts[0], vts[1], U), vts[1]]
    ];
}

function case0101(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    const cp = center(vts);

    if(cp.z &lt; L) {
        return [
            [inter_pt(vts[0], vts[1], L), vts[1], inter_pt(vts[1], vts[2], L), inter_pt(vts[1], cp, L)], [inter_pt(vts[0], vts[3], L), inter_pt(cp, vts[3], L), inter_pt(vts[2], vts[3], L), vts[3]]
        ];
    }
    else if(cp.z &lt;= U &amp;&amp; cp.z &gt;= L) {
        return [
            [inter_pt(vts[0], vts[3], L), inter_pt(vts[0], cp, L), inter_pt(vts[0], vts[1], L), vts[1], inter_pt(vts[1], vts[2], L), inter_pt(vts[2], cp, L), inter_pt(vts[2], vts[3], L), vts[3]]
        ];
    }

    return [
        [inter_pt(vts[0], vts[3], L), inter_pt(vts[0], cp, L), inter_pt(vts[0], cp, U), inter_pt(vts[3], cp, U), inter_pt(vts[2], cp, U), inter_pt(vts[2], cp, L), inter_pt(vts[2], vts[3], L), vts[3]], 
        [inter_pt(vts[2], vts[1], L), inter_pt(vts[2], cp, L), inter_pt(vts[2], cp, U), inter_pt(vts[1], cp, U), inter_pt(vts[0], cp, U), inter_pt(vts[0], cp, L), inter_pt(vts[0], vts[1], L), vts[1]]
    ];
}

function case2020(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    const cp = center(vts);

    if(cp.z &gt; U) {
        return [
            [inter_pt(vts[0], vts[1], U), inter_pt(vts[0], vts[1], L), inter_pt(vts[1], cp, L), inter_pt(vts[1], vts[2], L), inter_pt(vts[1], vts[2], U), inter_pt(vts[1], cp, U)], 
            [inter_pt(vts[0], vts[3], U), inter_pt(cp, vts[3], U), inter_pt(vts[2], vts[3], U), inter_pt(vts[2], vts[3], L), inter_pt(cp, vts[3], L), inter_pt(vts[0], vts[3], L)]
        ];
    }
    else if(cp.z &lt;= U &amp;&amp; cp.z &gt;= L) {
        return [
            [inter_pt(vts[0], vts[3], U), inter_pt(vts[0], cp, U), inter_pt(vts[0], vts[1], U), inter_pt(vts[0], vts[1], L), inter_pt(vts[1], cp, L), inter_pt(vts[1], vts[2], L), inter_pt(vts[1], vts[2], L), inter_pt(cp, vts[2], U), inter_pt(vts[2], vts[3], U), inter_pt(vts[2], vts[3], L), inter_pt(cp, vts[3], L), inter_pt(vts[0], vts[3], L)]
        ];
    }

    return [
        [inter_pt(vts[0], vts[3], U), inter_pt(vts[0], cp, U), inter_pt(vts[0], vts[1], U), inter_pt(vts[0], vts[1], L), inter_pt(vts[0], cp, L), inter_pt(vts[0], vts[3], L)], 
        [inter_pt(vts[2], vts[3], L), inter_pt(cp, vts[2], L), inter_pt(vts[1], vts[2], L), inter_pt(vts[1], vts[2], U), inter_pt(cp, vts[2], U), inter_pt(vts[2], vts[3], U)]
    ];
}

function case2021(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    const cp = center(vts);

    if(cp.z &gt; U) {
        return [
            [inter_pt(vts[0], vts[1], U), inter_pt(vts[0], vts[1], L), inter_pt(vts[1], cp, L), inter_pt(vts[1], cp, U), inter_pt(vts[1], vts[2], L), inter_pt(vts[1], vts[2], U), inter_pt(vts[1], cp, U)],
            [inter_pt(vts[0], vts[3], U), inter_pt(cp, vts[3], U), inter_pt(vts[2], vts[3], U), vts[3]]
        ];
    }
    else if(cp.z &lt;= U &amp;&amp; cp.z &gt;= L) {
        return [
            [inter_pt(vts[0], vts[3], U), inter_pt(vts[0], cp, U), inter_pt(vts[0], vts[1], U), inter_pt(vts[0], vts[1], L), inter_pt(vts[1], cp, L),  inter_pt(vts[1], vts[2], L), inter_pt(vts[1], vts[2], U), inter_pt(vts[2], cp, U), inter_pt(vts[2], vts[3], U), vts[3]]
        ];
    }

    return [
        [inter_pt(vts[0], vts[3], U), inter_pt(vts[0], cp, U), inter_pt(vts[0], vts[1], U), inter_pt(vts[0], vts[1], L),  inter_pt(vts[0], cp, L), inter_pt(vts[3], cp, L),  inter_pt(vts[2], cp, L),  inter_pt(vts[1], vts[2], L), inter_pt(vts[1], vts[2], U), inter_pt(vts[2], cp, U), inter_pt(vts[2], vts[3], U), vts[3]]
    ];
}

function case0201(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    const cp = center(vts);

    if(cp.z &lt; L) {
        return [
            [inter_pt(vts[0], vts[1], L), inter_pt(vts[1], cp, U), inter_pt(vts[0], vts[1], U), inter_pt(vts[1], vts[2], U), inter_pt(vts[1], vts[2], U), inter_pt(vts[1], cp, L)], 
            [inter_pt(vts[0], vts[3], L), inter_pt(cp, vts[3], L), inter_pt(vts[2], vts[3], L), vts[3]]
        ];
    }
    else if(cp.z &lt;= U &amp;&amp; cp.z &gt;= L) {
        return [
            [inter_pt(vts[0], vts[3], L), inter_pt(vts[0], cp, L), inter_pt(vts[0], vts[1], L), inter_pt(vts[0], vts[1], U), inter_pt(vts[1], cp, U), inter_pt(vts[1], vts[2], U), inter_pt(vts[1], vts[2], L), inter_pt(vts[2], cp, L), inter_pt(vts[2], vts[3], L), vts[3]]
        ];
    }

    return [
        [inter_pt(vts[0], vts[3], L), inter_pt(vts[0], cp, L), inter_pt(vts[0], vts[1], L), inter_pt(vts[0], vts[1], U), inter_pt(vts[0], cp, U), inter_pt(vts[3], cp, U), inter_pt(vts[2], cp, U), inter_pt(vts[1], vts[2], U), inter_pt(vts[1], vts[2], L), inter_pt(vts[2], cp, L), inter_pt(vts[2], vts[3], L), vts[3]]
    ];
}

function rotated(vts, n) {
    return vts.slice(n, vts.length).concat(vts.slice(0, n));
}

function isobands(cell, threshold) {
    const vts = cell.vts;
    const U = threshold.upper;
    const L = threshold.lower;
    switch(cell.cornerCase) {
        case '2222': case '0000': 
            return [];
        case '1111':
            return [vts];

        // 底下每四個一組，逆時針轉動頂點就可以了  
        case '1222':
            return case1222(vts, threshold);
        case '2122':
            return case1222(vts, threshold, 1);     
        case '2212':
            return case1222(vts, threshold, 2);         
        case '2221':
            return case1222(vts, threshold, 3);

        case '2111':
            return case2111(vts, threshold);
        case '1211':
            return case2111(vts, threshold, 1);
        case '1121':
            return case2111(vts, threshold, 2);
        case '1112':
            return case2111(vts, threshold, 3); 

        case '0111':
            return case0111(vts, threshold);    
        case '1011':
            return case0111(vts, threshold, 1);
        case '1101':
            return case0111(vts, threshold, 2);
        case '1110':
            return case0111(vts, threshold, 3); 

        case '1000':
            return case1000(vts, threshold);
        case '0100':
            return case1000(vts, threshold, 1);
        case '0010':
            return case1000(vts, threshold, 2);
        case '0001':
            return case1000(vts, threshold, 3); 

        case '0222':
            return case0222(vts, threshold);
        case '2022':
            return case0222(vts, threshold, 1);
        case '2202':
            return case0222(vts, threshold, 2);
        case '2220':
            return case0222(vts, threshold, 3);

        case '2211':
            return case2211(vts, threshold);
        case '1221':
            return case2211(vts, threshold, 1);
        case '1122':
            return case2211(vts, threshold, 2);
        case '2112':
            return case2211(vts, threshold, 3);

        case '0011':
            return case0011(vts, threshold);
        case '1001':
            return case0011(vts, threshold, 1);
        case '1100':
            return case0011(vts, threshold, 2);
        case '0110':
            return case0011(vts, threshold, 3);

        case '2000':
            return case2000(vts, threshold);
        case '0200':
            return case2000(vts, threshold, 1);
        case '0020':
            return case2000(vts, threshold, 2);
        case '0002':
            return case2000(vts, threshold, 3);

        case '2201':
            return case2201(vts, threshold);
        case '1220':
            return case2201(vts, threshold, 1);
        case '0122':
            return case2201(vts, threshold, 2);
        case '2012':
            return case2201(vts, threshold, 3);

        case '2210':
            return case2210(vts, threshold);
        case '0221':
            return case2210(vts, threshold, 1);
        case '1022':
            return case2210(vts, threshold, 2);
        case '2102':
            return case2210(vts, threshold, 3);

        case '0012':
            return case0012(vts, threshold);
        case '2001':
            return case0012(vts, threshold, 1);
        case '1200':
            return case0012(vts, threshold, 2);
        case '0120':
            return case0012(vts, threshold, 3);;

        case '0021':
            return case0021(vts, threshold);
        case '1002':
            return case0021(vts, threshold, 1);
        case '2100':
            return case0021(vts, threshold, 2);
        case '0210':
            return case0021(vts, threshold, 3);

        case '1120':
            return case1120(vts, threshold);
        case '0112':
            return case1120(vts, threshold, 1);
        case '2011':
            return case1120(vts, threshold, 2);
        case '1201':
            return case1120(vts, threshold, 3);

        case '1102':
            return case1102(vts, threshold);
        case '2110':
            return case1102(vts, threshold, 1);
        case '0211':
            return case1102(vts, threshold, 2);
        case '1021':
            return case1102(vts, threshold, 3);

        case '1012':
            return case1012(vts, threshold);
        case '2101':
            return case1012(vts, threshold, 1);
        case '1210':
            return case1012(vts, threshold, 2);
        case '0121':
            return case1012(vts, threshold, 3);

        // 鞍部每個 case 有三種情況，另一 case 逆時針轉動頂點就可以了  
        case '2121':
            return case2121(vts, threshold);
        case '1212':
            return case2121(vts, threshold, 1);

        case '0101':
            return case0101(vts, threshold);
        case '1010':
            return case0101(vts, threshold, 1);

        case '2020':
            return case2020(vts, threshold);        
        case '0202':
            return case2020(vts, threshold, 1); 

        // 鞍部每個 case 有三種情況，另三 case 逆時針轉動頂點就可以了  
        case '2021':
            return case2021(vts, threshold);
        case '1202':
            return case2021(vts, threshold, 1);
        case '2120':
            return case2021(vts, threshold, 2);
        case '0212':
            return case2021(vts, threshold, 3);

        case '0201':
            return case0201(vts, threshold);
        case '1020':
            return case0201(vts, threshold, 1);
        case '0102':
            return case0201(vts, threshold, 2);
        case '2010':
            return case0201(vts, threshold, 3);
    }
}
</code></pre>
<p>這麼一來，就可以建立一個 contours 函式來取得全部的等值帶：</p>
<pre class="prettyprint"><code lang="javascript">function contours(values, threshold) {
    const corners = mapToCorners(values, threshold);
    return flatMapToCells(corners)
         .map(cell =&gt; isobands(cell, threshold))
         .filter(lines =&gt; lines.length &gt; 0)
         .flat();
}
</code></pre>
<p>底下完整的範例，結合了〈<a href="PerlinNoise.html">Perlin 雜訊</a>〉畫出的等值帶（這邊沒有使用 <a href="https://toolness.github.io/p5.js-widget/">p5.js-widget</a>，因為它載入太長的程式碼會有問題）：</p>
<pre class="prettyprint"><code lang="javascript">function setup() {
    createCanvas(300, 300);
    noLoop();
    noStroke();
}

function draw() {
    background(220);

    const values = [];
    for(let x = 0; x &lt; width; x++) {
        const row = [];
        for(let y = 0; y &lt; height; y++) {
            const c = 255 * noise(x / 100, y / 100);
            row.push(c);
        }  
        values.push(row);
    } 

    for(let t = 255; t &gt; 0; t -= 20) {
        fill(t, 255 - t, 0);
        contours(values, {lower: t - 20, upper: t}).forEach(band =&gt; {
            beginShape();
            band.forEach(p =&gt; vertex(p.x, p.y));
            endShape(CLOSE);
        });
    }  
}

function contours(values, threshold) {
    const corners = mapToCorners(values, threshold);

    return flatMapToCells(corners)
         .map(cell =&gt; isobands(cell, threshold))
         .filter(lines =&gt; lines.length &gt; 0)
         .flat();
}

function mapToCorners(values, threshold) {
    const corners = []
    for(let r = 0; r &lt; values.length; r++) {
        const row = [];
        for(let c = 0; c &lt; values[r].length; c++) {
            const v = values[r][c];
            row.push({
                vt : createVector(c, r, values[r][c]),
                thresholdLabel: v &gt; threshold.upper ? '2' : (v &lt;= threshold.upper &amp;&amp; v &gt;= threshold.lower ? '1' : '0')
            });
        }
        corners.push(row);
    }
    return corners;
}

function flatMapToCells(corners) {
    const cells = [];
    for(let r = 0; r &lt; corners.length - 1; r++) {
        for(let c = 0; c &lt; corners[r].length - 1; c++) {
            cells.push({
                vts: [
                    corners[r][c].vt,
                    corners[r + 1][c].vt,
                    corners[r + 1][c + 1].vt,
                    corners[r][c + 1].vt
                ], 
                cornerCase: cornerCase([
                    corners[r][c],
                    corners[r + 1][c],
                    corners[r + 1][c + 1],
                    corners[r][c + 1]
               ])
            });
        }
    }
    return cells;
}

function cornerCase(corners) {
    return corners.map(corner =&gt; corner.thresholdLabel).join('');
}

function case1222(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[vts[0], inter_pt(vts[0], vts[1], U), inter_pt(vts[0], vts[3], U)]];
}

function case2111(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[inter_pt(vts[0], vts[3], U), inter_pt(vts[0], vts[1], U), vts[1], vts[2], vts[3]]];
}

function case0111(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[inter_pt(vts[0], vts[3], L), inter_pt(vts[0], vts[1], L), vts[1], vts[2], vts[3]]];
}

function case1000(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[vts[0], inter_pt(vts[0], vts[1], L), inter_pt(vts[0], vts[3], L)]];
}

function case0222(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[inter_pt(vts[0], vts[3], L), inter_pt(vts[0], vts[1], L), inter_pt(vts[0], vts[1], U), inter_pt(vts[0], vts[3], U)]];
}

function case2211(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[inter_pt(vts[0], vts[3], U), inter_pt(vts[1], vts[2], U), vts[2], vts[3]]];
}

function case0011(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[inter_pt(vts[0], vts[3], L), inter_pt(vts[1], vts[2], L), vts[2], vts[3]]];
}

function case2000(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[inter_pt(vts[0], vts[3], U), inter_pt(vts[0], vts[1], U), inter_pt(vts[0], vts[1], L), inter_pt(vts[0], vts[3], L)]];
}

function case2201(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[inter_pt(vts[0], vts[3], U), inter_pt(vts[1], vts[2], U), inter_pt(vts[1], vts[2], L), inter_pt(vts[2], vts[3], L), vts[3]]];
}

function case2210(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[inter_pt(vts[0], vts[3], U), inter_pt(vts[1], vts[2], U), vts[2], inter_pt(vts[2], vts[3], L), inter_pt(vts[0], vts[3], L)]];
}

function case0012(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[inter_pt(vts[0], vts[3], L), inter_pt(vts[1], vts[2], L), vts[2], inter_pt(vts[2], vts[3], U), inter_pt(vts[0], vts[3], U)]];
}

function case0021(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[inter_pt(vts[0], vts[3], L), inter_pt(vts[1], vts[2], L), inter_pt(vts[1], vts[2], U), inter_pt(vts[2], vts[3], U), vts[3]]];
}

function case1120(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[vts[0], vts[1], inter_pt(vts[1], vts[2], U), inter_pt(vts[2], vts[3], U), inter_pt(vts[2], vts[3], L), inter_pt(vts[0], vts[3], L)]];
}

function case1102(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[vts[0], vts[1], inter_pt(vts[1], vts[2], L), inter_pt(vts[2], vts[3], L), inter_pt(vts[2], vts[3], U), inter_pt(vts[0], vts[3], U)]];
}

function case1012(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    return [[vts[0], inter_pt(vts[0], vts[1], L), inter_pt(vts[1], vts[2], L), vts[2], inter_pt(vts[2], vts[3], U), inter_pt(vts[0], vts[3], U)]];
}

function case2121(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    const cp = center(vts);

    if(cp.z &gt; U) {
        return [
            [inter_pt(vts[0], vts[1], U), vts[1], inter_pt(vts[1], vts[2], U), inter_pt(vts[1], cp, U)], [inter_pt(vts[0], vts[3], U), inter_pt(cp, vts[3], U), inter_pt(vts[2], vts[3], U), vts[3]]
        ];
    }
    else if(cp.z &lt;= U &amp;&amp; cp.z &gt;= L) {
        return [
            [inter_pt(vts[0], vts[3], U), inter_pt(vts[0], cp, U), inter_pt(vts[0], vts[1], U), vts[1], inter_pt(vts[1], vts[2], U), inter_pt(vts[2], cp, U), inter_pt(vts[2], vts[3], U), vts[3]]
        ];
    }

    return [
        [inter_pt(vts[0], vts[3], U), inter_pt(vts[0], cp, U), inter_pt(vts[0], cp, L), inter_pt(vts[3], cp, L), inter_pt(vts[2], cp, L), inter_pt(vts[2], cp, U), inter_pt(vts[2], vts[3], U), vts[3]], 
        [inter_pt(vts[2], vts[1], U), inter_pt(vts[2], cp, U), inter_pt(vts[2], cp, L), inter_pt(vts[1], cp, L), inter_pt(vts[0], cp, L), inter_pt(vts[0], cp, U), inter_pt(vts[0], vts[1], U), vts[1]]
    ];
}

function case0101(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    const cp = center(vts);

    if(cp.z &lt; L) {
        return [
            [inter_pt(vts[0], vts[1], L), vts[1], inter_pt(vts[1], vts[2], L), inter_pt(vts[1], cp, L)], [inter_pt(vts[0], vts[3], L), inter_pt(cp, vts[3], L), inter_pt(vts[2], vts[3], L), vts[3]]
        ];
    }
    else if(cp.z &lt;= U &amp;&amp; cp.z &gt;= L) {
        return [
            [inter_pt(vts[0], vts[3], L), inter_pt(vts[0], cp, L), inter_pt(vts[0], vts[1], L), vts[1], inter_pt(vts[1], vts[2], L), inter_pt(vts[2], cp, L), inter_pt(vts[2], vts[3], L), vts[3]]
        ];
    }

    return [
        [inter_pt(vts[0], vts[3], L), inter_pt(vts[0], cp, L), inter_pt(vts[0], cp, U), inter_pt(vts[3], cp, U), inter_pt(vts[2], cp, U), inter_pt(vts[2], cp, L), inter_pt(vts[2], vts[3], L), vts[3]], 
        [inter_pt(vts[2], vts[1], L), inter_pt(vts[2], cp, L), inter_pt(vts[2], cp, U), inter_pt(vts[1], cp, U), inter_pt(vts[0], cp, U), inter_pt(vts[0], cp, L), inter_pt(vts[0], vts[1], L), vts[1]]
    ];
}

function case2020(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    const cp = center(vts);

    if(cp.z &gt; U) {
        return [
            [inter_pt(vts[0], vts[1], U), inter_pt(vts[0], vts[1], L), inter_pt(vts[1], cp, L), inter_pt(vts[1], vts[2], L), inter_pt(vts[1], vts[2], U), inter_pt(vts[1], cp, U)], 
            [inter_pt(vts[0], vts[3], U), inter_pt(cp, vts[3], U), inter_pt(vts[2], vts[3], U), inter_pt(vts[2], vts[3], L), inter_pt(cp, vts[3], L), inter_pt(vts[0], vts[3], L)]
        ];
    }
    else if(cp.z &lt;= U &amp;&amp; cp.z &gt;= L) {
        return [
            [inter_pt(vts[0], vts[3], U), inter_pt(vts[0], cp, U), inter_pt(vts[0], vts[1], U), inter_pt(vts[0], vts[1], L), inter_pt(vts[1], cp, L), inter_pt(vts[1], vts[2], L), inter_pt(vts[1], vts[2], L), inter_pt(cp, vts[2], U), inter_pt(vts[2], vts[3], U), inter_pt(vts[2], vts[3], L), inter_pt(cp, vts[3], L), inter_pt(vts[0], vts[3], L)]
        ];
    }

    return [
        [inter_pt(vts[0], vts[3], U), inter_pt(vts[0], cp, U), inter_pt(vts[0], vts[1], U), inter_pt(vts[0], vts[1], L), inter_pt(vts[0], cp, L), inter_pt(vts[0], vts[3], L)], 
        [inter_pt(vts[2], vts[3], L), inter_pt(cp, vts[2], L), inter_pt(vts[1], vts[2], L), inter_pt(vts[1], vts[2], U), inter_pt(cp, vts[2], U), inter_pt(vts[2], vts[3], U)]
    ];
}

function case2021(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    const cp = center(vts);

    if(cp.z &gt; U) {
        return [
            [inter_pt(vts[0], vts[1], U), inter_pt(vts[0], vts[1], L), inter_pt(vts[1], cp, L), inter_pt(vts[1], cp, U), inter_pt(vts[1], vts[2], L), inter_pt(vts[1], vts[2], U), inter_pt(vts[1], cp, U)],
            [inter_pt(vts[0], vts[3], U), inter_pt(cp, vts[3], U), inter_pt(vts[2], vts[3], U), vts[3]]
        ];
    }
    else if(cp.z &lt;= U &amp;&amp; cp.z &gt;= L) {
        return [
            [inter_pt(vts[0], vts[3], U), inter_pt(vts[0], cp, U), inter_pt(vts[0], vts[1], U), inter_pt(vts[0], vts[1], L), inter_pt(vts[1], cp, L),  inter_pt(vts[1], vts[2], L), inter_pt(vts[1], vts[2], U), inter_pt(vts[2], cp, U), inter_pt(vts[2], vts[3], U), vts[3]]
        ];
    }

    return [
        [inter_pt(vts[0], vts[3], U), inter_pt(vts[0], cp, U), inter_pt(vts[0], vts[1], U), inter_pt(vts[0], vts[1], L),  inter_pt(vts[0], cp, L), inter_pt(vts[3], cp, L),  inter_pt(vts[2], cp, L),  inter_pt(vts[1], vts[2], L), inter_pt(vts[1], vts[2], U), inter_pt(vts[2], cp, U), inter_pt(vts[2], vts[3], U), vts[3]]
    ];
}

function case0201(cellVts, threshold, r = 0) {
    const vts = rotated(cellVts, r);
    const U = threshold.upper;
    const L = threshold.lower;
    const cp = center(vts);

    if(cp.z &lt; L) {
        return [
            [inter_pt(vts[0], vts[1], L), inter_pt(vts[1], cp, U), inter_pt(vts[0], vts[1], U), inter_pt(vts[1], vts[2], U), inter_pt(vts[1], vts[2], U), inter_pt(vts[1], cp, L)], 
            [inter_pt(vts[0], vts[3], L), inter_pt(cp, vts[3], L), inter_pt(vts[2], vts[3], L), vts[3]]
        ];
    }
    else if(cp.z &lt;= U &amp;&amp; cp.z &gt;= L) {
        return [
            [inter_pt(vts[0], vts[3], L), inter_pt(vts[0], cp, L), inter_pt(vts[0], vts[1], L), inter_pt(vts[0], vts[1], U), inter_pt(vts[1], cp, U), inter_pt(vts[1], vts[2], U), inter_pt(vts[1], vts[2], L), inter_pt(vts[2], cp, L), inter_pt(vts[2], vts[3], L), vts[3]]
        ];
    }

    return [
        [inter_pt(vts[0], vts[3], L), inter_pt(vts[0], cp, L), inter_pt(vts[0], vts[1], L), inter_pt(vts[0], vts[1], U), inter_pt(vts[0], cp, U), inter_pt(vts[3], cp, U), inter_pt(vts[2], cp, U), inter_pt(vts[1], vts[2], U), inter_pt(vts[1], vts[2], L), inter_pt(vts[2], cp, L), inter_pt(vts[2], vts[3], L), vts[3]]
    ];
}

function rotated(vts, n) {
    return vts.slice(n, vts.length).concat(vts.slice(0, n));
}

function isobands(cell, threshold) {
    const vts = cell.vts;
    const U = threshold.upper;
    const L = threshold.lower;
    switch(cell.cornerCase) {
        case '2222': case '0000': 
            return [];
        case '1111':
            return [vts];

        // 底下每四個一組，逆時針轉動頂點就可以了  
        case '1222':
            return case1222(vts, threshold);
        case '2122':
            return case1222(vts, threshold, 1);     
        case '2212':
            return case1222(vts, threshold, 2);         
        case '2221':
            return case1222(vts, threshold, 3);

        case '2111':
            return case2111(vts, threshold);
        case '1211':
            return case2111(vts, threshold, 1);
        case '1121':
            return case2111(vts, threshold, 2);
        case '1112':
            return case2111(vts, threshold, 3); 

        case '0111':
            return case0111(vts, threshold);    
        case '1011':
            return case0111(vts, threshold, 1);
        case '1101':
            return case0111(vts, threshold, 2);
        case '1110':
            return case0111(vts, threshold, 3); 

        case '1000':
            return case1000(vts, threshold);
        case '0100':
            return case1000(vts, threshold, 1);
        case '0010':
            return case1000(vts, threshold, 2);
        case '0001':
            return case1000(vts, threshold, 3); 

        case '0222':
            return case0222(vts, threshold);
        case '2022':
            return case0222(vts, threshold, 1);
        case '2202':
            return case0222(vts, threshold, 2);
        case '2220':
            return case0222(vts, threshold, 3);

        case '2211':
            return case2211(vts, threshold);
        case '1221':
            return case2211(vts, threshold, 1);
        case '1122':
            return case2211(vts, threshold, 2);
        case '2112':
            return case2211(vts, threshold, 3);

        case '0011':
            return case0011(vts, threshold);
        case '1001':
            return case0011(vts, threshold, 1);
        case '1100':
            return case0011(vts, threshold, 2);
        case '0110':
            return case0011(vts, threshold, 3);

        case '2000':
            return case2000(vts, threshold);
        case '0200':
            return case2000(vts, threshold, 1);
        case '0020':
            return case2000(vts, threshold, 2);
        case '0002':
            return case2000(vts, threshold, 3);

        case '2201':
            return case2201(vts, threshold);
        case '1220':
            return case2201(vts, threshold, 1);
        case '0122':
            return case2201(vts, threshold, 2);
        case '2012':
            return case2201(vts, threshold, 3);

        case '2210':
            return case2210(vts, threshold);
        case '0221':
            return case2210(vts, threshold, 1);
        case '1022':
            return case2210(vts, threshold, 2);
        case '2102':
            return case2210(vts, threshold, 3);

        case '0012':
            return case0012(vts, threshold);
        case '2001':
            return case0012(vts, threshold, 1);
        case '1200':
            return case0012(vts, threshold, 2);
        case '0120':
            return case0012(vts, threshold, 3);;

        case '0021':
            return case0021(vts, threshold);
        case '1002':
            return case0021(vts, threshold, 1);
        case '2100':
            return case0021(vts, threshold, 2);
        case '0210':
            return case0021(vts, threshold, 3);

        case '1120':
            return case1120(vts, threshold);
        case '0112':
            return case1120(vts, threshold, 1);
        case '2011':
            return case1120(vts, threshold, 2);
        case '1201':
            return case1120(vts, threshold, 3);

        case '1102':
            return case1102(vts, threshold);
        case '2110':
            return case1102(vts, threshold, 1);
        case '0211':
            return case1102(vts, threshold, 2);
        case '1021':
            return case1102(vts, threshold, 3);

        case '1012':
            return case1012(vts, threshold);
        case '2101':
            return case1012(vts, threshold, 1);
        case '1210':
            return case1012(vts, threshold, 2);
        case '0121':
            return case1012(vts, threshold, 3);

        case '2121':
            return case2121(vts, threshold);
        case '1212':
            return case2121(vts, threshold, 1);

        case '0101':
            return case0101(vts, threshold);
        case '1010':
            return case0101(vts, threshold, 1);

        case '2020':
            return case2020(vts, threshold);        
        case '0202':
            return case2020(vts, threshold, 1); 

        case '2021':
            return case2021(vts, threshold);
        case '1202':
            return case2021(vts, threshold, 1);
        case '2120':
            return case2021(vts, threshold, 2);
        case '0212':
            return case2021(vts, threshold, 3);

        case '0201':
            return case0201(vts, threshold);
        case '1020':
            return case0201(vts, threshold, 1);
        case '0102':
            return case0201(vts, threshold, 2);
        case '2010':
            return case0201(vts, threshold, 3);
    }
}

function inter_pt(v1, v2, threshold) {
    return p5.Vector.lerp(v1, v2, (threshold - v1.z) / (v2.z - v1.z));
}

function center(vts) {
    return p5.Vector.add(vts[0], vts[1]).add(vts[2]).add(vts[3]).div(4);
}
</code></pre>
<p>等值線、帶並不單只是用於等高線、等壓線之類的場合，我曾經實現了 OpenSCAD 版本的 Marching squares，並寫了個簡單的切片程式 <a href="https://cults3d.com/en/3d-model/art/image-slicer">Image slicer</a>，可以從圖片生成可列印的三維線稿模型：</p>
<p><div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" src="images/MarchingSquares3-3.JPG" alt="Marching squares（三）"  /></div></div></p>

            
           <br><br><div class="ad336-280" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型廣告 336 x 280 --><ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-9750319131714390" data-ad-slot="9976409681"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div><br><div class="recommend" style="text-align: center;"><hr><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 自動大小回應相符內容 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="4953478487" data-ad-format="autorelaxed"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>
        </article>
    </main>
</div></body>
</html>

<script src="../js/ui.js"></script>
<div class="analytics"><script async src="https://www.googletagmanager.com/gtag/js?id=G-QVQQYFSC8J"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-QVQQYFSC8J');</script></div>
