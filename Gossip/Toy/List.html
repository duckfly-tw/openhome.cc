<!doctype html><html lang="zh-tw">
<head><meta http-equiv="refresh" content="0; URL=https://openhome.cc/Gossip/Toy/'https://openhome.cc/zh-tw/toy-lang/flow-ctrl/list/'">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="List 是有序的物件集合，具有索引特性，長度可以變動。要建立 List，可以使用內建的 List 類別，每個元素，使用逗號 , 區隔，例如：
lt = new List(1, 2)

# 逐行顯示元...">

    <meta property="og:locale" content="zh_TW">
    <meta property="og:title" content="List 與迭代 API">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://openhome.cc/Gossip/Toy/List.html">
    <meta property="og:image" content="https://openhome.cc/Gossip/images/caterpillar_small.jpg">
    <meta property="og:site_name" content="OPENHOME.CC">
    <meta property="og:description" content="List 是有序的物件集合，具有索引特性，長度可以變動。要建立 List，可以使用內建的 List 類別，每個元素，使用逗號 , 區隔，例如：
lt = new List(1, 2)

# 逐行顯示元...">

    <title>List 與迭代 API</title>

    <link rel="stylesheet" href="../css/pure-0.6.0/pure-min.css">

    <!--[if lte IE 8]>
        <link rel="stylesheet" href="../css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="../css/layouts/side-menu.css">
    <!--<![endif]-->
  

     <link rel="stylesheet" href="../css/caterpillar.css">
     <script async src="../google-code-prettify/run_prettify.js"></script>
     <!-- 網頁層級廣告 --><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle =window.adsbygoogle || []).push({google_ad_client: "ca-pub-9750319131714390",enable_page_level_ads: true });</script></head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="List.html#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
    <div id="menu">
        <div class="pure-menu">
            <a class="pure-menu-heading" href="https://openhome.cc/Gossip/Toy/index.html"><< Toy</a>
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><br><div class="social" style="text-align: center;"><a href="http://twitter.com/caterpillar"><img title="Twitter" alt="Twitter" src="../images/twitter.png"></a> <a href="http://www.facebook.com/openhome.cc"><img title="Facebook" alt="Facebook" src="../images/facebook.png"></a> </div><br> <div id="search box"><script>(function() {var cx = 'partner-pub-9750319131714390:3926766884';var gcse = document.createElement('script');gcse.type = 'text/javascript';gcse.async = true;gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(gcse, s);})();</script><gcse:searchbox-only></gcse:searchbox-only></div><br><div class="ad" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 2015 新版型 160 x 600 廣告 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:600px"
     data-ad-client="ca-pub-9750319131714390"
     data-ad-slot="3747048883"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div></li>
            </ul>
        </div>
    </div>

    <main id="main">
        <header class="header">
            <h1>List 與迭代 API</h1>
        </header>

        <article class="content">
            <br><div class="ad-3" style="text-align: center;"><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型回應式廣告 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="7104125683" data-ad-format="auto"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div> 
            
            <p>List 是有序的物件集合，具有索引特性，長度可以變動。要建立 List，可以使用內建的 <code>List</code> 類別，每個元素，使用逗號 <code>,</code> 區隔，例如：</p>
<pre class="prettyprint"><code lang="toy">lt = new List(1, 2)

# 逐行顯示元素
i = 0
while i &lt; lt.length() {
    println(lt.get(i))
    i += 1
}

lt.add(3).add(4)
println(lt)      # 顯示 [1,2,3,4]
</code></pre>
<p>除了使用 <code>List</code> 之外，也可以使用 <code>[]</code> 實字，這是建立 List 的便捷方式，例如：</p>
<pre class="prettyprint"><code lang="toy">lt = [1, 2, 3, 4]
println(lt)    # [1,2,3,4]

lt.remove(1)
println(lt)    # [2,3,4]

lt2 = lt.concat([10, 20])
println(lt2)   # [2,3,4,10,20]
</code></pre>
<p>List 是 <code>List</code> 類別的實例，<code>List</code> 類別上定義了一些迭代處理元素的便捷方法，例如：</p>
<pre class="prettyprint"><code lang="toy">([1, 2, 3, 4, 5].filter(elem -&gt; elem &gt;= 2) 
                .map(elem -&gt; elem * 100)   
                .forEach(println)) # 顯示 200、300、400、500
</code></pre>
<p>在 ToyLang 中，如果運算式需要跨越多行，必須使用 <code>()</code> 將之含括，另一個方式是使用 <code>\</code>：</p>
<pre class="prettyprint"><code lang="toy">[1, 2, 3, 4, 5].filter(elem -&gt; elem &gt;= 2) \
               .map(elem -&gt; elem * 100)   \
               .forEach(println)   # 顯示 200、300、400、500
</code></pre>
<p>如上所示，<code>filter</code>、<code>map</code>、<code>forEach</code> 等方法，可以接受函式，也就是說在 ToyLang 中，函式是一級值，而這邊指定的是 lambda 運算式，它會產生函式實例，對於可以在一行內完成的小函式，使用 lambda 運算式是比較方便的。</p>
<p>如果要建立的 List 數值是某個範圍，可以使用 <code>range</code> 函式，例如：</p>
<pre class="prettyprint"><code lang="toy">(range(2, 6).filter(elem -&gt; elem &gt;= 2) 
            .map(elem -&gt; elem * 100)   
            .forEach(println)) # 顯示 200、300、400、500
</code></pre>
<p>range 可根據指定的數值範圍，產生 <code>List</code> 實例，預設的步進值是 1，可以用第三個引數來指定步進值，步進值可以是負數：</p>
<pre class="prettyprint"><code lang="toy">println(range(1, 30, 5))    # 顯示 [1,6,11,16,21,26]
println(range(100, 90, -2)) # 顯示 [100,98,96,94,92]
</code></pre>
<p>甚至可以使用 lambda 運算式來指定範圍的終點以及步進方式：</p>
<pre class="prettyprint"><code lang="toy">println(range(1, n -&gt; n &lt; 30, n -&gt; n + 5))    # 顯示 [1,6,11,16,21,26]
println(range(100, n -&gt; n &gt; 90, n -&gt; n - 2))  # 顯示 [100,98,96,94,92]
</code></pre>
<p>如果只是需要迭代，不需要實際產生 List，可以使用 <code>iterate</code> 函式：</p>
<pre class="prettyprint"><code lang="toy">iterate(1, 5).forEach(println) # 顯示 1 到 4
</code></pre>
<p>與 <code>range</code> 不同的是，<code>iterate</code> 產生的並不是 <code>List</code> 實例，而是個迭代器，這個迭代器具有 <code>hasNext</code>、<code>next</code>、<code>forEach</code>、<code>select</code> 以及 <code>collect</code> 方法，舉例而言，<code>range(1, 100)</code> 會產生 <code>List</code>，內含元素值 1 到 99，然而 <code>iterate(1, 100)</code> 並沒有馬上產生 1 到 99 的數值，只有在 <code>next</code> 等方法呼叫之時，才會進一步產生出值來。</p>
<p>也就是說，如果只是要迭代，而不是真的要有個 List，那麼 <code>iterate</code> 會比較有效率，若需要將數值收集起來，可以使用 <code>collect</code> 方法，若需要先做個條件過濾再收集起來，可以使用 <code>select</code>，這兩個方法是會產生 <code>List</code> 實例，用以銜接 <code>List</code> 的 API。</p>
<pre class="prettyprint"><code lang="toy">(iterate(2, 6).select(elem -&gt; elem &gt;= 2) 
              .forEach(println)) # 顯示 2、3、4、5
</code></pre>
<hr />
<p>在實作 ToyLang 的過程中，<code>List</code> 是放在很後期才實作出來的 API，因為它是個類別，顯然地，就必須在有函式與類別的語法，以及相對應的語法節點之後，才能夠進一步實作。</p>
<p>為了儘早讓 ToyLang 可以做些比較實際的運算，<code>List</code> 底層實際銜接了 JavaScript 原生的 <code>Array</code> API，這沒有什麼好意外地，許多語言為了效率，有些函式在底層也都會銜接至 C 語言的程式庫。</p>
<p>對於 ToyLang 來說，銜接至 JavaScript 程式庫的實作，都放在 <a href="https://github.com/JustinSDK/toy_lang/tree/master/toy_lang/js/builtin">builtin</a> 之中，現在要解釋裏頭的實作原理還太早，這部份會等到談到函式與類別之後，再來逐步說明。</p>
<p>然而如同〈<a href="StringComment.html">字串與註解</a>〉裏說過的，老是將函式或方法，直接對應至底層 JavaScript 的 API 沒有意思，因而後來，除了真的必須得用到 JavaScript 環境的一些 API 之外，我就直接用 ToyLang 來寫函式或方法了，例如 <code>range</code> 與 <code>iterate</code>，就是實作在 <a href="https://github.com/JustinSDK/toy_lang/blob/master/toy_lang/lib/builtin.toy">builtin.toy</a> 之中：</p>
<pre class="prettyprint"><code lang="toy">def stopLambda(stop, step) {
    if typeof(stop) == 'number' {
        if noValue(step) or ((typeof(step) == 'number') and step &gt; 0) {
            return i -&gt; i &lt; stop
        }
        else {
            return i -&gt; i &gt; stop 
        }
    }
    return stop
}

def stepLambda(step) {
    if noValue(step) {
        return i -&gt; i + 1
    }

    if typeof(step) == 'number' {
        return i -&gt; i + step
    }
    return step
}

def iterate(start, stop, step) {
    n = start
    p = stopLambda(stop, step)
    s = stepLambda(step)

    class Iter {
        def hasNext() {
            return p(n)
        }

        def next() {
            v = n
            nonlocal n = s(n)
            return v
        }

        def forEach(action) {
            while this.hasNext() {
                action(this.next())
            }
        }          

        def select(predicate) {
            lt = []
            while this.hasNext() {
                nx = this.next()
                if predicate(nx) {
                    lt.add(nx)
                }
            }
            return lt
        }  

        def collect(mapper) {
            lt = []
            this.forEach(elem -&gt; lt.add(mapper(elem)))
            return lt  
        }
    }

    return new Iter()
}

def range(start, stop, step) {
    lt = []
    iterate(start, stop, step).forEach(n -&gt; lt.add(n))
    return lt
}
</code></pre>
<p>你也可以從這個程式碼中，先預覽一下 ToyLang 的函式與類別語法風格，這某些程度也是在測試 ToyLang 的文法是否足以勝任一般性的任務，另一方面，現代開發者，應該很少有機會自行實作標準程式庫吧！偶而地，想要搞點小實驗，像是自行實現個亂數函式，就可以 ToyLang 裏試試，別有一番樂趣。</p>
<p>方才談到，ToyLang 中若運算式要跨越多行，必須使用 <code>()</code> 或者是 <code>\</code>，這是因為先前提過的，為了簡化 Parser 的設計，ToyLang 採逐行剖析，強硬地運用了 Regular expression 來處理了大半的事情，然而，若不能跨行，上面範例那種流暢 API 風格，撰寫時就會受到一定的限制。</p>
<p>ToyLang 在預處理原始碼時，會將 <code>()</code> 或 <code>\</code> 標示的多行合併為一行，然後再進行剖析，<a href="https://github.com/JustinSDK/toy_lang/blob/master/toy_lang/js/interpreter/tokenizer/tokenizer.js">tokenizer.js</a> 裏的 <code>concatExpr</code> 函式做的，就是這件事。</p>
<p>然而，多行合併為一行，也就會造成顯示除錯訊息時的小問題，例如：</p>
<pre class="prettyprint"><code lang="toy">([1, 2, 3, 4, 5].filter(elem -&gt; elem &gt;= 2) 
                .map(elem -&gt; elem * 100)   
                .foreach(println))
</code></pre>
<p>顯示的錯誤訊息會是：</p>
<pre class="prettyprint"><code lang="toy">ReferenceError: foreach is not defined
    at [1, 2, 3, 4, 5].filter(elem -&gt; elem &gt;= 2) .map(elem -&gt; elem * 100) .foreach(println) (/main.toy:1)
</code></pre>
<p>也就是原本換行排版好的原始碼，在錯誤訊息中也被合併為一行了，這個嘛，必須從一開始的 Parser 設計就解決，就當成日後有機會實現下門語言的課題吧！</p>
<p>回到 <code>List</code> 本身，<code>[]</code> 的寫法，在建立語法樹時，實際上等同於 <code>new List()</code>，這在 <a href="https://github.com/JustinSDK/toy_lang/blob/master/toy_lang/js/interpreter/expr_parser.js">expr_parser.js</a> 中可以看到：</p>
<pre class="prettyprint"><code lang="toy">['list', {
    burst(elemTokenables) {
        const NewOperator = UNARY_OPERATORS.get('new');
        const args = elemTokenables.length === 1 &amp;&amp; elemTokenables[0].value === '' ? [[]] :
                           [elemTokenables.map(elem =&gt; EXPR_PARSER.parse(elem))]

        return new NewOperator(
            new FunCall(
                Variable.of('List'), 
                args
            )
        );
    }        
}]
</code></pre>
<p>如果編譯器會產生中介的位元碼（byte code）之類，最後寫出的位元碼會是相同的，這就是所謂的語法糖吧！雖然 <code>List</code> 可以使用 <code>[]</code> 建立，不過以索引取值或設值，還是透過 <code>List</code> 的 <code>get</code>、<code>set</code> 方法，理由之一是，後期我把心力都放在語法樹上，<code>lt[0]</code>、或 <code>lt[1] = 10</code> 這類的語法，必須在 Parser 實作，有點懶得去做，另一個原因，等到後面談到函式時，再來說吧！</p>

            
           <br><br><div class="ad336-280" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型廣告 336 x 280 --><ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-9750319131714390" data-ad-slot="9976409681"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div><br><div class="recommend" style="text-align: center;"><hr><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 自動大小回應相符內容 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="4953478487" data-ad-format="autorelaxed"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>
        </article>
    </main>
</div></body>
</html>
<script src="../js/ui.js"></script>
<div class="analytics">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'G-QVQQYFSC8J', 'auto');
  ga('send', 'pageview');

</script>
</div>
