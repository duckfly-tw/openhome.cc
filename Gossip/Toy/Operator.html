<!doctype html><html lang="zh-tw">
<head><meta http-equiv="refresh" content="0; URL=https://openhome.cc/Gossip/Toy/'https://openhome.cc/zh-tw/toy-lang/fundamental/op-expr/'">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="任何語言中最基本的運算子，無非就是 +、-、*、/ 等算術運算子，用在數值運算時就是加、減、乘、除運算。+ 在許多語言中可以串接字串，ToyLang 中也不例外：
println('Just' + '...">

    <meta property="og:locale" content="zh_TW">
    <meta property="og:title" content="運算子與運算式">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://openhome.cc/Gossip/Toy/Operator.html">
    <meta property="og:image" content="https://openhome.cc/Gossip/images/caterpillar_small.jpg">
    <meta property="og:site_name" content="OPENHOME.CC">
    <meta property="og:description" content="任何語言中最基本的運算子，無非就是 +、-、*、/ 等算術運算子，用在數值運算時就是加、減、乘、除運算。+ 在許多語言中可以串接字串，ToyLang 中也不例外：
println('Just' + '...">

    <title>運算子與運算式</title>

    <link rel="stylesheet" href="../css/pure-0.6.0/pure-min.css">

    <!--[if lte IE 8]>
        <link rel="stylesheet" href="../css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="../css/layouts/side-menu.css">
    <!--<![endif]-->
  

     <link rel="stylesheet" href="../css/caterpillar.css">
     <script async src="../google-code-prettify/run_prettify.js"></script>
     <!-- 網頁層級廣告 --><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle =window.adsbygoogle || []).push({google_ad_client: "ca-pub-9750319131714390",enable_page_level_ads: true });</script></head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="Operator.html#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
    <div id="menu">
        <div class="pure-menu">
            <a class="pure-menu-heading" href="https://openhome.cc/Gossip/Toy/index.html"><< Toy</a>
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><br><div class="social" style="text-align: center;"><a href="http://twitter.com/caterpillar"><img title="Twitter" alt="Twitter" src="../images/twitter.png"></a> <a href="http://www.facebook.com/openhome.cc"><img title="Facebook" alt="Facebook" src="../images/facebook.png"></a> </div><br> <div id="search box"><script>(function() {var cx = 'partner-pub-9750319131714390:3926766884';var gcse = document.createElement('script');gcse.type = 'text/javascript';gcse.async = true;gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(gcse, s);})();</script><gcse:searchbox-only></gcse:searchbox-only></div><br><div class="ad" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 2015 新版型 160 x 600 廣告 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:600px"
     data-ad-client="ca-pub-9750319131714390"
     data-ad-slot="3747048883"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div></li>
            </ul>
        </div>
    </div>

    <main id="main">
        <header class="header">
            <h1>運算子與運算式</h1>
        </header>

        <article class="content">
            <br><div class="ad-3" style="text-align: center;"><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型回應式廣告 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="7104125683" data-ad-format="auto"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div> 
            
            <p>任何語言中最基本的運算子，無非就是 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 等算術運算子，用在數值運算時就是加、減、乘、除運算。<code>+</code> 在許多語言中可以串接字串，ToyLang 中也不例外：</p>
<pre class="prettyprint"><code lang="toy">println('Just' + 'in') # 顯示 Justin
</code></pre>
<p>在 ToyLang 中，可以用於運算式的運算子有：</p>
<ul>
<li>算術運算：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code></li>
<li>邏輯運算：<code>and</code>、<code>or</code>、<code>not</code></li>
<li>關係運算：<code>==</code>、<code>!=</code>、<code>&gt;=</code>、<code>&gt;</code>、<code>&lt;=</code></li>
<li>位元運算：<code>&amp;</code>、<code>|</code>、<code>^</code>、<code>&gt;&gt;</code>、<code>&lt;&lt;</code></li>
<li>實例運算：<code>new</code></li>
<li>物件操作：<code>.</code></li>
</ul>
<p><code>and</code>、<code>or</code> 有捷徑運算的效果，運算元不用是 <code>true</code> 或 <code>false</code> 的結果，<code>0</code>、<code>''</code>、<code>false</code> 都會被當成不成立，其他都是成立，<code>and</code> 與 <code>or</code> 在可以判定結果成立與否時，當時的運算元會被傳回。例如：</p>
<pre class="prettyprint"><code lang="toy">println(0 or 'Justin')          # 顯示 Justin
println('Justin' and 'Monica')  # 顯示 Monica
</code></pre>
<p>嗯？<code>null</code> 呢？ToyLang 中沒有這東西，ToyLang 中沒有顯式的 <code>null</code> 可以使用，放棄它吧！&hellip;XD</p>
<p>運算子有其優先順序，大致上與其他語言相同，如果不確定的話，當然就是加上括號：</p>
<pre class="prettyprint"><code lang="toy">x = (1 + 2) * (3 + 4)
println(x)  # 顯示 21
</code></pre>
<p><code>=</code> 是個指定，除了它之外，還有 <code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>&amp;=</code>、<code>|=</code>、<code>^=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>，這之後的文件再來談。</p>
<hr />
<p>在實現語言時，最基本的開始就是實現運算式，就最簡單的加法來說，想要實現 1 + 2 的話：</p>
<pre class="prettyprint"><code lang="toy">class Context {
}

class Num {
    constructor(value) {
        this.value = value;
    }

    evaluate(context) {
        return this;
    }
}

class Add {
    constructor(left, right) {
        this.left = left;
        this.right = right;
    }

    evaluate(context) {
        return new Num(
            this.left.evaluate(context).value + this.right.evaluate(context).value
        );
    }
}

const r = new Add(new Num(1), new Num(2)).evaluate(new Context());
</code></pre>
<p>若要取得運算後的值，透過 <code>r.value</code> 就可以了，對於基本型態來說，<code>Context</code> 這個環境物件通常沒有作用，之後還會看到 <code>Context</code> 實際發揮效用的場合，目前只是為了令語法節點有一致的 <code>evaluate</code> 協定而傳入。</p>
<p>就單詞的語法節點來說，真正重要的只在建構式，<code>evaluate</code> 則是賦予該節點實際運算意義的部份，ToyLang 是將兩者寫在一起同一個類別之中。</p>
<p>那麼，對於 (1 + 2) * (3 + 4) 該如何展現呢？基本上是這樣的：</p>
<pre class="prettyprint"><code lang="toy">class Multiply {
    constructor(left, right) {
        this.left = left;
        this.right = right;
    }

    evaluate(context) {
        return new Num(
            this.left.evaluate(context).value * this.right.evaluate(context).value
        );
    }
}

const node = new Multiply(
    new Add(new Num(1), new Num(2)),
    new Add(new Num(3), new Num(4))
);

const r = node.evaluate(new Context());
</code></pre>
<p>對於語法樹來說，節點的組合本身，已經包含了運算的先後順序，問題就在於，那這個節點的建立順序是怎麼完成的，總要有個地方處理括號、決定節點的組合方式吧！</p>
<p>這部份就是 Parser 的職責，而且 Parser 在處理運算式這方面的實現並不輕鬆，畢竟整個程式，就像是一條超大型運算式組合而成，當中會有許多運算子、運算元，充滿了文法的遞迴性。</p>
<p>你可以試著從 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 的剖析開始，至於運算子的優先順序處理，我採用的方式是中序式轉後序式，接著是用後序式進行運算，沒錯，就是〈<a href="../AlgorithmGossip/InFixPostfix.htm">中序式轉後序式</a>〉、〈<a href="../AlgorithmGossip/PostfixCal.htm">後序式的運算</a>〉作出發點。</p>
<p>首先，必須將 <code>(1 + 2) * (3 + 4)</code>，因而必須切割單詞，然後轉為 <code>12+34+*</code>，單詞的切割是使用 Regex，這就是先前為何要談到，如何為數值、字串等定義 Regex 的原因。</p>
<p>接著下一步並不是直接對 <code>12+34+*</code> 作運算，而是對 <code>12+34+*</code> 進行節點的組合，這部份的實現撰寫在 <a href="https://github.com/JustinSDK/toy_lang/blob/master/toy_lang/js/interpreter/expr_parser.js">expr_parse.js</a> 之中，<code>// expression</code> 註解的後面：</p>
<pre class="prettyprint"><code lang="toy">// expression

function exprAst(tokenables) {
    return tokenables.reduce((stack, tokenable) =&gt; {
        if(isBinaryOperator(tokenable.value)) {
            return reduceBinary(stack, tokenable);
        } 

        if(isUnaryOperator(tokenable.value)) {
            return reduceUnary(stack, tokenable);
        }         

        return stack.push(
            OPERAND_PARSER.parse(tokenable)
        );
    }, new Stack()).top;
}

function precedence(operator) {
    switch(operator) {
        case '.':    return 14;
        case 'new':  return 13;
        case '$neg': return 12;
        case 'not':  return 11;
        case '*': case '/': case '%':
                     return 10;
        case '+': case '-':
                     return 9;
        case '&lt;&lt;': case '&gt;&gt;':
                     return 8;
        case '&gt;=': case '&gt;': case '&lt;=': case '&lt;':
                     return 7;
        case '==': case '!=':
                     return 6;
        case '&amp;':    return 5;
        case '^':    return 4; 
        case '|':    return 3;
        case 'and':  return 2;
        case 'or':   return 1;
        default:     return 0; 
    }
}

略 ...
</code></pre>
<p>運算子的優先順序只要定義好，〈<a href="../AlgorithmGossip/InFixPostfix.htm">中序式轉後序式</a>〉、〈<a href="../AlgorithmGossip/PostfixCal.htm">後序式的運算</a>〉中的方式就可以適用更多的運算子，<code>precedence</code> 函式中定義的就是運算子的優先順序。</p>
<p>文件中有提到，在化簡二元運算子時，會從堆疊中取出兩個運算元，文件中沒提到的是，運算子中其實會有單元運算子，這部份只要取出一個運算元就可以了。</p>
<p>還有文件中沒提到的是 <code>-</code>，它可以當成是減法二元運算子，然而，也可以當成是負號單元運算子，Regex 中可以使用旁觀（look around）比對，不過我當時忘記運用它了，因而是直接在程式中判斷。無論是採用哪種方式，如果 <code>-</code> 前並不是運算元（而是 <code>)</code> 或其他運算子）的話，就表示它是個負號單元運算子。</p>
<p>運算子的語法節點，獨立定義在 <a href="https://github.com/JustinSDK/toy_lang/blob/master/toy_lang/js/interpreter/ast/operator.js">operator.js</a> 裏頭，雖然大部份運算子，我都直接對應至 JavaScript 的運算子，然而必須注意有捷徑運算功能的 <code>and</code> 與 <code>or</code>。</p>
<p>我一開始也忘了處理捷徑運算，直到後來在實作〈<a href="../AlgorithmGossip/index.html">常見程式演算</a>〉裏的題目找 bug 時，才發現怎麼沒有捷徑運算的效果，簡單來說，不能左右運算元都估值，而是先估值左運算元，接著才決定要不要估值右運算元，以 <code>and</code> 的節點為例：</p>
<pre class="prettyprint"><code lang="toy">class AndOperator {
    constructor(left, right) {
        this.left = left;
        this.right = right;
    }

    evaluate(context) {
        const maybeCtxLeft = this.left.evaluate(context); // 先估值左運算元
        return maybeCtxLeft.notThrown(
            left =&gt; {
                if(left.value === undefined ? left.toString(context) : left.value) {
                    // 左運算元成立才會執行右運算元估值
                    return this.right.evaluate(context).notThrown(right =&gt; right);
                }
                return left;
            }
        );
    }
}
</code></pre>
<p>如先前談到的，運算式的剖析與處理並不輕鬆，Regex 的定義以及比對的順序至關重要，你可以在 <a href="https://github.com/JustinSDK/toy_lang/blob/master/toy_lang/js/interpreter/tokenizer/regex.js">regex.js</a> 中看到一些比對的範本，若是你想挑戰看看實作運算式，可以參考一下。</p>
<p>必須說的是，使用 Regex 來做運算式的比對，並不完全適合，因為 Regex 是上下文無關（context-free）的語言，然而，若想實作的語言是上下文相關語言，會有許多 Regex 做不到的事，例如之後會談到，任意深度的對稱括號比對就是一個例子。</p>
<p>我若有心力實作下一門語言的話，將單詞切割階段獨立出來，自行設計狀態機之類的東西來辨別語法結構等，會是屆時的實現目標。</p>

            
           <br><br><div class="ad336-280" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型廣告 336 x 280 --><ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-9750319131714390" data-ad-slot="9976409681"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div><br><div class="recommend" style="text-align: center;"><hr><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 自動大小回應相符內容 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="4953478487" data-ad-format="autorelaxed"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>
        </article>
    </main>
</div></body>
</html>
<script src="../js/ui.js"></script>
<div class="analytics">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'G-QVQQYFSC8J', 'auto');
  ga('send', 'pageview');

</script>
</div>
