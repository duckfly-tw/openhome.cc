<!doctype html><html lang="zh-tw">
<head><meta http-equiv="refresh" content="0; URL=https://openhome.cc/Gossip/Toy/'https://openhome.cc/zh-tw/toy-lang/obj/class'">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="在 ToyLang 中要定義類別，必須使用 class，例如，可以定義一個帳戶（Account）類別：
class Account {
    balance = 0 

    def init(n...">

    <meta property="og:locale" content="zh_TW">
    <meta property="og:title" content="定義類別">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://openhome.cc/Gossip/Toy/Class.html">
    <meta property="og:image" content="https://openhome.cc/Gossip/images/caterpillar_small.jpg">
    <meta property="og:site_name" content="OPENHOME.CC">
    <meta property="og:description" content="在 ToyLang 中要定義類別，必須使用 class，例如，可以定義一個帳戶（Account）類別：
class Account {
    balance = 0 

    def init(n...">

    <title>定義類別</title>

    <link rel="stylesheet" href="../css/pure-0.6.0/pure-min.css">

    <!--[if lte IE 8]>
        <link rel="stylesheet" href="../css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="../css/layouts/side-menu.css">
    <!--<![endif]-->
  

     <link rel="stylesheet" href="../css/caterpillar.css">
     <script async src="../google-code-prettify/run_prettify.js"></script>
     <!-- 網頁層級廣告 --><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle =window.adsbygoogle || []).push({google_ad_client: "ca-pub-9750319131714390",enable_page_level_ads: true });</script></head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="Class.html#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
    <div id="menu">
        <div class="pure-menu">
            <a class="pure-menu-heading" href="https://openhome.cc/Gossip/Toy/index.html"><< Toy</a>
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><br><div class="social" style="text-align: center;"><a href="http://twitter.com/caterpillar"><img title="Twitter" alt="Twitter" src="../images/twitter.png"></a> <a href="http://www.facebook.com/openhome.cc"><img title="Facebook" alt="Facebook" src="../images/facebook.png"></a> </div><br> <div id="search box"><script>(function() {var cx = 'partner-pub-9750319131714390:3926766884';var gcse = document.createElement('script');gcse.type = 'text/javascript';gcse.async = true;gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(gcse, s);})();</script><gcse:searchbox-only></gcse:searchbox-only></div><br><div class="ad" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 2015 新版型 160 x 600 廣告 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:600px"
     data-ad-client="ca-pub-9750319131714390"
     data-ad-slot="3747048883"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div></li>
            </ul>
        </div>
    </div>

    <main id="main">
        <header class="header">
            <h1>定義類別</h1>
        </header>

        <article class="content">
            <br><div class="ad-3" style="text-align: center;"><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型回應式廣告 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="7104125683" data-ad-format="auto"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div> 
            
            <p>在 ToyLang 中要定義類別，必須使用 <code>class</code>，例如，可以定義一個帳戶（<code>Account</code>）類別：</p>
<pre class="prettyprint"><code lang="toy">class Account {
    balance = 0 

    def init(number, name) {
        this.number = number
        this.name = name
    }

    def deposit(amount) {
        if amount &lt;= 0 {
            throw new Exception('must be positive')
        }

        this.balance += amount
    }

    def withdraw(amount) {
        if amount &gt; this.balance {
            throw new Exception('balance not enough')
        }

        this.balance -= amount            
    }

    def toString() {
        return '{0}, {1}, {2}'.format(this.number, this.name, this.balance)
    }
}

acct = new Account('123', 'Justin')
acct.deposit(100)
acct.withdraw(20)
println(acct)
</code></pre>
<p>類別中的方法一樣使用 <code>def</code> 來定義，因為 ToyLang 中，方法本質上就是個函式，而方法中若出現 <code>this</code>，基本上代表建立的類別實例（<code>this</code> 也可以出現在函式中，這在之後還會談到）。</p>
<p>類別本體中可以有陳述句，若是 <code>=</code> 指定陳述，變數會成為類別實例上的特性，例如上例中的 <code>balance</code> 就是一個例子，後續在類別本體中使用變數時，也不需要使用 <code>this</code>。</p>
<p><code>init</code> 方法是個特定的名稱，用來定義類別的實例建立之後，要進行的初始化動作，如果要建立類別的實例，可以使用 <code>new</code> 關鍵字，例如 <code>new Account('123', 'Justin')</code>，這會執行類別本體陳述，接著建立一個物件，將類別本體陳述中建立的變數，指定為物件上之特性，之後物件會成為方法中 <code>this</code> 參考之對象，呼叫 <code>init</code> 方法，<code>'123'</code> 會指定給 <code>number</code> 參數，而 <code>'Justin'</code> 指定給 <code>name</code> 參數，然後執行 <code>init</code> 本體完成初始化。</p>
<p>每個建構出來的 <code>Account</code> 實例，都會擁有自己的特性，可以直接透過物件及 <code>.</code> 運算子來存取特性：</p>
<pre class="prettyprint"><code lang="toy">println(acct.name)                   # 顯示 Justin
println(acct.hasOwnProperty('name')) # 顯示 true
</code></pre>
<p>從上例中可以看到，可以透過 <code>hasOwnProperty</code> 來測試，某個特性是否為某實例擁有，<code>hasOwnProperty</code> 是繼承至 <code>Object</code>，之後文件還會談到繼承。</p>
<p>雖然呼叫方法也是透過 <code>.</code> 運算子，然而，方法並不屬於物件本身，而是屬於類別本身：</p>
<pre class="prettyprint"><code lang="toy">println(acct.deposit)                    # 顯示 &lt;Function deposit&gt;
println(acct.hasOwnProperty('deposit'))  # 顯示 false
println(Account.hasOwnMethod('deposit')) # 顯示 true
</code></pre>
<p>每個類別都會是 <code>Class</code> 的實例，而 <code>Class</code> 定義了 <code>hasOwnMethod</code> 方法，可用來測試某個類別是否擁有某個方法。</p>
<p>某些場合需要取得物件的字串描述時，建議定義 <code>toString</code> 方法，內建的 <code>println</code> 等函式，遇到物件時，就會呼叫 <code>toString</code> 來取得描述，若自定義類別時沒有定義 <code>toString</code>，會使用從 <code>Object</code> 繼承下來的 <code>toString</code> 方法，這之後還會討論。</p>
<hr />
<p>說穿了，物件導向也不過就是看待資料與函式的一種方式！只不過若語法上支援的話，當想要以物件導向看待資料的方式來撰寫程式時，會比較輕鬆罷了。</p>
<p>舉例來說，如果沒有 <code>class</code> 等語法支援的話，要怎麼定義帳戶呢？就目前來說，ToyLang 只有 <code>List</code> 這個資料結構，那就這樣好了：</p>
<pre class="prettyprint"><code lang="toy">def acct_init(number, name) {
    return [number, name, 0]
} 

def acct_deposit(acct, amount) {
    if amount &lt;= 0 {
        throw new Exception('must be positive')
    }
    balance = acct.get(2)
    acct.set(2, balance + amount)
}

def acct_withdraw(acct, amount) {
    if amount &gt; acct.get(2) {
        throw new Exception('balance not enough')
    }
    balance = acct.get(2)
    acct.set(2, balance - amount)
}

def acct_toString(acct) {
    return '{0}, {1}, {2}'.format(acct.get(0), acct.get(1), acct.get(2))
}

acct = acct_init('123', 'Justin')
acct_deposit(acct, 100)
acct_withdraw(acct, 20)
println(acct_toString(acct))
</code></pre>
<p>這當然也是物件導向中「類別」的概念，雖然使用 <code>List</code>，然而，每一個 <code>List</code> 都代表著一個實際的帳戶資料，這個資料在初始化時，都是經由 <code>acct_init</code> 的流程，存款或提款則分別經由 <code>acct_deposit</code>、<code>acct_withdraw</code> 流程等，每個函式中以特定的方式存取 <code>List</code>，就這邊的例子就是索引，而且每個索引位置有其特定之意義。</p>
<p>當然，使用索引並不方便，也許你可以實作 <code>Map</code> 之類的資料結構，這樣就可以有具體的鍵名稱來取得對應的值；另一方面，<code>acct_</code> 名稱前置，用意是在提示，這些函式是屬於帳戶這類資料使用，基本上，你會將這類有 <code>acct_</code> 名稱前置的函式，儘量集中放在程式中某個位置管理，以便需要時，知道要到哪個地方去找尋適當的函式，來操作帳戶這類資料結構。</p>
<p>如果有門語言，只要撰寫 <code>class</code> 之類的語法，將方法定義在類別之中，就可以有具體的特性名稱來取得對應的特性值，透過 <code>.</code> 運算子之類的語法，就會自動知道要到哪些地方找出指定的函式來執行，豈不是美事一件嗎？這就是物件導向語法存在的意義。</p>
<p>然而，自動這件事並不是魔法，實作面上，就是要將上述的需求實現出來，首先就是在使用者定義類別後，語言實作品必須能收集類別本體中的方法定義以及陳述句，這並不難，因為之前在實現函式時，早就做過這件事了。</p>
<p>因為函式本身就像是一種類別容器，方法定義就像是函式中的區域函式，而陳述句自然就是函式本體中的東西了，這聽來像是 JavaScript？沒錯！在 ECMAScript 6 之前，本質上，JavaScript 就只是將這件事明確地實現出來而已。</p>
<p>因此若看 <a href="https://github.com/JustinSDK/toy_lang/blob/master/toy_lang/js/interpreter/line_parser.js">line_parse.js</a> 中剖析類別的部份，幾乎是與剖析函式是相同的：</p>
<pre class="prettyprint"><code lang="toy">function createAssignFunc(tokenableLines, argTokenable) {
    const [fNameTokenable, ...paramTokenables] = argTokenable.tryTokenables('func');    
    fNameTokenable.errIfKeyword();

    const remains = tokenableLines.slice(1);
    const bodyStmt = LINE_PARSER.parse(remains);
    const bodyLineCount = bodyStmt.lineCount;

    return new StmtSequence(
        new DefStmt(
            Variable.of(fNameTokenable.value), 
            new Func(
                paramTokenables.map(paramTokenable =&gt; Variable.of(paramTokenable.value)), 
                bodyStmt,
                fNameTokenable.value
            )
        ),
        LINE_PARSER.parse(tokenableLines.slice(bodyLineCount + 2)),
        tokenableLines[0].lineNumber
    );    
}

function createAssignClass(tokenableLines, argTokenable) {
    const [fNameTokenable, ...paramTokenables] = argTokenable.tryTokenables('func');
    fNameTokenable.errIfKeyword();

    const remains = tokenableLines.slice(1);     
    const stmt = LINE_PARSER.parse(remains);
    const clzLineCount = stmt.lineCount + 2;

    const parentClzNames = paramTokenables.map(paramTokenable =&gt; paramTokenable.value);
    const [fs, notDefStmt] = splitFuncStmt(stmt);

    return new StmtSequence(
        new ClassStmt(
            Variable.of(fNameTokenable.value), 
            new Class({
                notMethodStmt : notDefStmt, 
                methods : new Map(fs), 
                name : fNameTokenable.value, 
                parentClzNames : parentClzNames.length === 0 ? ['Object'] : parentClzNames
            })
        ),
        LINE_PARSER.parse(tokenableLines.slice(clzLineCount)),
        tokenableLines[0].lineNumber
    );   
}
</code></pre>
<p>不同的地方在於，在剖析完類別本體之後，還做了區別 <code>def</code> 陳述與其他陳述的動作，<code>def</code> 陳述被挑出來，作為方法來看待：</p>
<pre class="prettyprint"><code lang="toy">class Class extends Func {
    constructor({notMethodStmt, methods, name, parentClzNames, parentContext}) {
        super([], notMethodStmt, name, parentContext || null);
        this.parentClzNames = parentClzNames || ['Object'];
        this.methods = methods;
    }

    ...

    hasOwnMethod(name) {
        return this.methods.has(name);
    }    

    ...

}
</code></pre>
<p><code>Class</code> 節點定義在 <a href="https://github.com/JustinSDK/toy_lang/blob/master/toy_lang/js/interpreter/ast/value.js">value.js</a> 中；除了剖析時有很大部份與函式類似，執行面上也有大部份是雷同，因此 <code>Class</code> 節點繼承了 <code>Func</code> 節點，非 <code>def</code> 陳述的部份，使用 <code>super</code> 交給了 <code>Func</code> 建構式，至於 <code>def</code> 陳述部份，由 <code>Class</code> 節點本身來管理，像是判斷類別有無定義某個方法，就實現為 <code>hasOwnMethod</code>。</p>
<p>建構類別的實例時，使用的是 <code>new</code> 運算子，它對應的節點是 <code>NewOperator</code>，實現在 <a href="https://github.com/JustinSDK/toy_lang/blob/master/toy_lang/js/interpreter/ast/operator.js">operator.js</a> 中：</p>
<pre class="prettyprint"><code lang="toy">class NewOperator {
    constructor(operand) {
        this.operand = operand;
    }

    instance(context, args) {
        const clzInstance = clzInstanceFrom(context, this.operand);
        // run class body
        const ctx = clzInstance.internalNode.call(context, args);
        return ctx.notThrown(c =&gt; {
            c.variables.delete('arguments');
            return new Instance(
                clzInstance,
                c.variables
            );
        });
    }

    evaluate(context) {
        const args = argsFrom(this.operand);
        const maybeContext = this.instance(context, args);
        return maybeContext.notThrown(ctx =&gt; {
            if(ctx.clzNodeOfLang().hasOwnMethod('init')) {
                const maybeCtx = new MethodCall(maybeContext, 'init', [args]).evaluate(context);
                return maybeCtx.notThrown(c =&gt; maybeContext);
            }
            return ctx;
        });    
    }   
}
</code></pre>
<p>在 <code>instance</code> 方法就可以看到先執行類別本體，取得環境物件上的變數並建立 <code>Instance</code> 節點的動作，執行類別本體本質上就是呼叫函式，因而會有個 <code>arguments</code>，這對類別的實例來說，並非需要的特性，因此將之刪除。</p>
<p>在 <code>instance</code> 方法過後，就是看看類別本身是否定義了 <code>init</code>，若有才會執行，也就是建立一個 <code>MethodCall</code> 節點並執行，這實現在 <a href="https://github.com/JustinSDK/toy_lang/blob/master/toy_lang/js/interpreter/ast/callable.js">callable.js</a> 中：</p>
<pre class="prettyprint"><code lang="toy">class MethodCall {
    constructor(instance, methodName, argsList = []) {
        this.instance = instance;
        this.methodName = methodName;
        this.argsList = argsList;
    }

    evaluate(context) {
        return methodBodyStmt(context, this.instance, this.methodName, this.argsList[0])
                        .evaluate(methodContextFrom(context, this.instance, this.methodName))
                        .notThrown(c =&gt; {
                            if(this.argsList.length &gt; 1) {
                                return callChain(context, c.returnedValue.internalNode, this.argsList.slice(1));
                            }
                            return c.returnedValue === null ? Void : c.returnedValue; 
                        });
    }
}

function methodBodyStmt(context, instance, methodName, args = []) {
    const f = instance.hasOwnProperty(methodName) ? 
                  instance.getOwnProperty(methodName).internalNode : 
                  instance.clzNodeOfLang().getMethod(context, methodName);
    const bodyStmt = f.bodyStmt(context, args.map(arg =&gt; arg.evaluate(context)));
    return new StmtSequence(
        new VariableAssign(Variable.of('this'), instance),  
        bodyStmt,
        bodyStmt.lineNumber
    );
}
</code></pre>
<p>留意到 <code>methodBodyStmt</code>，其中會看看實例上有沒有方法，沒有的話就到實例的類別上取，是的，實例確實也可以擁有方法，就像 JavaScript 那樣，這之後還會看到，扣除這點不談，就如前所述，類別的目的是作為方法的容器，真的單純只是查找方法的地方。</p>
<p>至於真正代表類別實例的節點，是 <a href="https://github.com/JustinSDK/toy_lang/blob/master/toy_lang/js/interpreter/ast/value.js">value.js</a> 中的 <code>Instance</code>，某些程度上，它就只是個包裹 <code>Map</code> 的節點：</p>
<pre class="prettyprint"><code lang="toy">class Instance extends Value {
    constructor(clzOfLang, properties, internalNode) {
        super();
        this.clzOfLang = clzOfLang; 
        this.properties = properties;
        this.internalNode = internalNode || this;
        this.value = this;
    }

    clzNodeOfLang() {
        return this.clzOfLang.internalNode;
    }

    nativeValue() {
        return this.internalNode.value;
    }

    hasOwnProperty(name) {
        return this.properties.has(name);
    } 

    ...
}
</code></pre>
<p><code>properties</code> 參數接受的就是 <code>Map</code>，另一個重要的部份，就是 <code>clzOfLang</code> 了，每個實例必須知道它是屬於哪個類別，如此在使用 <code>.</code> 運算子時，才會知道要到哪個類別上尋找是否有定義方法。</p>
<p><code>.</code> 運算子的部份，就等到談 <code>this</code> 的細節時再來討論了；實際上，類別在處理上有很多的細節，這邊談到的節點，其實也都省略了不少程式碼，主要是先知道有這些節點的存在，以及它們各自在哪些地方，之後有機會，也會來看看那些被省略的程式碼，到底各自負責了什麼。</p>

            
           <br><br><div class="ad336-280" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型廣告 336 x 280 --><ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-9750319131714390" data-ad-slot="9976409681"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div><br><div class="recommend" style="text-align: center;"><hr><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 自動大小回應相符內容 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="4953478487" data-ad-format="autorelaxed"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>
        </article>
    </main>
</div></body>
</html>
<script src="../js/ui.js"></script>
<div class="analytics">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'G-QVQQYFSC8J', 'auto');
  ga('send', 'pageview');

</script>
</div>
