<!doctype html><html lang="zh-tw">
<head><meta http-equiv="refresh" content="0; URL=https://openhome.cc/Gossip/Toy/'https://openhome.cc/zh-tw/toy-lang/flow-ctrl/while'">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="while 陳述根據指定的條件式，判斷是否執行 while 本體，用以進行重複性的演算，例如以下是個求最大公因數的程式：
m = Number.parseInt(input('輸入數字 1'))
n ...">

    <meta property="og:locale" content="zh_TW">
    <meta property="og:title" content="while 陳述">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://openhome.cc/Gossip/Toy/While.html">
    <meta property="og:image" content="https://openhome.cc/Gossip/images/caterpillar_small.jpg">
    <meta property="og:site_name" content="OPENHOME.CC">
    <meta property="og:description" content="while 陳述根據指定的條件式，判斷是否執行 while 本體，用以進行重複性的演算，例如以下是個求最大公因數的程式：
m = Number.parseInt(input('輸入數字 1'))
n ...">

    <title>while 陳述</title>

    <link rel="stylesheet" href="../css/pure-0.6.0/pure-min.css">

    <!--[if lte IE 8]>
        <link rel="stylesheet" href="../css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="../css/layouts/side-menu.css">
    <!--<![endif]-->
  

     <link rel="stylesheet" href="../css/caterpillar.css">
     <script async src="../google-code-prettify/run_prettify.js"></script>
     <!-- 網頁層級廣告 --><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle =window.adsbygoogle || []).push({google_ad_client: "ca-pub-9750319131714390",enable_page_level_ads: true });</script></head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="While.html#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
    <div id="menu">
        <div class="pure-menu">
            <a class="pure-menu-heading" href="https://openhome.cc/Gossip/Toy/index.html"><< Toy</a>
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><br><div class="social" style="text-align: center;"><a href="http://twitter.com/caterpillar"><img title="Twitter" alt="Twitter" src="../images/twitter.png"></a> <a href="http://www.facebook.com/openhome.cc"><img title="Facebook" alt="Facebook" src="../images/facebook.png"></a> </div><br> <div id="search box"><script>(function() {var cx = 'partner-pub-9750319131714390:3926766884';var gcse = document.createElement('script');gcse.type = 'text/javascript';gcse.async = true;gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(gcse, s);})();</script><gcse:searchbox-only></gcse:searchbox-only></div><br><div class="ad" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 2015 新版型 160 x 600 廣告 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:600px"
     data-ad-client="ca-pub-9750319131714390"
     data-ad-slot="3747048883"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div></li>
            </ul>
        </div>
    </div>

    <main id="main">
        <header class="header">
            <h1>while 陳述</h1>
        </header>

        <article class="content">
            <br><div class="ad-3" style="text-align: center;"><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型回應式廣告 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="7104125683" data-ad-format="auto"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div> 
            
            <p><code>while</code> 陳述根據指定的條件式，判斷是否執行 <code>while</code> 本體，用以進行重複性的演算，例如以下是個求最大公因數的程式：</p>
<pre class="prettyprint"><code lang="toy">m = Number.parseInt(input('輸入數字 1'))
n = Number.parseInt(input('輸入數字 2'))

while n != 0 {
   r = m % n
   m = n
   n = r
}

println('GCD: ' + m)
</code></pre>
<p>ToyLang 沒有其他語言中有的 <code>do while</code> 語句，必須使用判斷式及 <code>break</code> 來達成。例如判斷輸入為奇數或偶數，直到使用者回答 No 為止：</p>
<pre class="prettyprint"><code lang="toy">while true {
    number = Number.parseInt(input('輸入數字：'))
    println('輸入數為' + ('奇數' if number % 2 else '偶數'))
    if input('繼續？（Yes/No）') == 'No' {
        break
    }
}
</code></pre>
<p>底下是個很無聊的遊戲，看誰可以最久不撞到這個數字 5：</p>
<pre class="prettyprint"><code lang="toy">import '/lib/math'

while true {
    number = Number.parseInt(math.random() * 10)
    println(number)
    if number == 5 {
        break
    }
}

println('I hit 5....Orz')
</code></pre>
<p>ToyLang 有模組管理機制，<code>math</code> 模組是標準模組之一，其中包含了 <code>random</code> 函式，會隨機產生 0.0 到小於 1.0 的值，乘上 10 再裁掉小數部份，表示產生 0 到 9 的數。</p>
<hr />
<p>如果會建立 <code>if</code> 陳述相對應的語法節點，<code>while</code> 相對應的語法節點，基本上不成問題：</p>
<pre class="prettyprint"><code lang="toy">class While {
    constructor(cond, stmt) {
        this.cond = cond;
        this.stmt = stmt;
    }

    evaluate(context) {
        let ctx = context;
        while(true) {
            if(this.cond.evaluate(context).value) {
                ctx = this.stmt.evaluate(context);
            }
            else {
                break;
            }
        }
        return ctx;
    }   
}
</code></pre>
<p>也就是每次對 <code>while</code> 的條件式節點求值，結果會是 <code>true</code>，就一直執行 <code>while</code> 本體的陳述句節點，不過，還得考慮 <code>break</code>，它會有一個相對應的 <code>Break</code> 節點：</p>
<pre class="prettyprint"><code lang="toy">const Break = {
    lineCount : 1,
    evaluate(context) {
        return context.broken();
    }
};
</code></pre>
<p>也就是執行 <code>break</code>，相對應的 <code>Break</code> 會在環境物件中做個註記，表示執行了 <code>break</code>，只要環境物件中這個註記還存在，<code>while</code> 本體中的之後每個陳述節點都不會執行，而 <code>While</code> 節點：</p>
<pre class="prettyprint"><code lang="toy">class While {
    constructor(cond, stmt) {
        this.cond = cond;
        this.stmt = stmt;
    }

    evaluate(context) {
        let ctx = context;
        while(true) {
            if(this.cond.evaluate(context).value) {
                ctx = this.stmt.evaluate(context);
                if(ctx.isBroken()) {
                    return ctx.fixBroken();
                }
            }
            else {
                break;
            }
        }
        return ctx;
    }   
}
</code></pre>
<p><code>break</code> 會中斷目前的 <code>while</code> 陳述，因此本體的陳述節點執行過後，檢查 <code>ctx.isBroken()</code> 看看環境物件有無註記，有的話就 <code>return</code>，然而在 <code>return</code> 之前，必須先清楚環境物件中關於 <code>break</code> 的註記，這就是 <code>ctx.fixBroken()</code> 做的事情，否則在 <code>while</code> 陳述後若還有其他陳述，也會無法執行。</p>
<p>檢查每個陳述句執行過後，環境物件是否有被註記，實際上應該實作在 <code>StmtSequence</code> 之中，不過，程式中的 <code>StmtSequence</code> 何其多，每執行一次陳述句，就得檢查一次環境物件，著實沒有效率，因而實際上，我並沒有真的做檢查的動作，而是使用回呼函式。</p>
<p>每個環境物件都有個 <code>notBroken</code> 函式，上一個陳述句若傳回 <code>ctx</code>，要執行下個陳述句 <code>stmt</code> 的話，程式碼上會是：</p>
<pre class="prettyprint"><code lang="toy">ctx.notBroken(c =&gt; stmt.evaluate(c));
</code></pre>
<p><code>notBroken</code> 平常參考的函式會是：</p>
<pre class="prettyprint"><code lang="toy">function call(f) {
    return f(this);
} 
</code></pre>
<p>也就是方才的 <code>c</code> 在正常執行流程下，就是 <code>ctx</code>，萬一有個 <code>break</code> 執行了，對應的節點會執行環境物件的 <code>broken</code> 方法，這時環境物件的 <code>notBroken</code> 會被代換為：</p>
<pre class="prettyprint"><code lang="toy">function self(f) {
    return this;
} 
</code></pre>
<p>也就是此時，會忽略掉傳入的 <code>f</code>，因此等同於略過回呼中指定的 <code>stmt</code> 之估值，這樣就不用每次都檢查有沒有被註解 <code>break</code> 了；如果呼叫了環境物件的 <code>fixBroken</code> 方法，就會將 <code>notBroken</code> 參考的函式，恢復為方才的 <code>call</code> 函式。</p>
<p>為什麼取名為 <code>notBroken</code>，因為可讀性，也就是 <code>ctx.notBroken(c =&gt; stmt.evaluate(c))</code> 代表的是，在沒有 <code>break</code> 下執行回呼函式。</p>
<p>方才談到的實作，都可以在 <a href="https://github.com/JustinSDK/toy_lang/blob/master/toy_lang/js/context.js">context.js</a> 與 <a href="https://github.com/JustinSDK/toy_lang/blob/master/toy_lang/js/interpreter/ast/statement.js">statement.js</a> 中看到，實際的流程會再複雜一些，因為還處理了 <code>return</code> 與 <code>throw</code> 的情況。</p>
<p>至於為什麼要採用在環境物件上註記的方式呢？記得之前談過陳述句與運算式的差別嗎？</p>
<p>若是陳述句，通常會對環境物件造成狀態變更，因此陳述句節點，必須傳回環境物件，如此下個陳述節點，才能在最新狀態的環境物件基礎下，繼續執行程式；如果是運算式節點，通常傳回自身，如此下個運算節點，才可以從傳回的物件上取得內含值，像是 <code>xxx.value</code> 這樣的動作。</p>
<p>運算式通常被包含在一個陳述句中，或者之後會看到，被包裝為在一個陳述節點之中，簡而言之，無論是哪個，最新的環境物件都必須被不斷傳遞下去；如果不在環境物件上註記，直接傳回一個代表執行過 <code>break</code> 的物件，那麼上一個陳述句節點執行過後的環境物件狀態，就勢必被中斷，程式的狀態就無法不斷地傳遞下去了。</p>
<p>既然談到了 <code>While</code> 節點，可以看一下 <a href="https://github.com/JustinSDK/toy_lang/blob/master/toy_lang/js/interpreter/ast/statement.js">statement.js</a> 中 <code>While</code> 的實作：</p>
<pre class="prettyprint"><code lang="toy">class While extends Stmt {
    constructor(boolean, stmt) {
        super(stmt.lineCount + 2);
        this.boolean = boolean;
        this.stmt = stmt;
    }

    evaluate(context) {
        let ctx = context;
        while(true) {
            const maybeContext = this.boolean.evaluate(ctx);
            if(maybeContext.thrownNode) {
                return maybeContext;
            }

            if(maybeContext.value) {
                ctx = this.stmt.evaluate(ctx);
                if(ctx.thrownNode || ctx.returnedValue) {
                    return ctx;
                }
                if(ctx.isBroken()) {
                    return ctx.fixBroken();
                }
            } else { break; }
        }
        return ctx;

        /*
            To avoid 'Maximum call stack size exceeded', the above code is the only place which uses 'while'.
            The corresponding code with the functional style is shown below.
         */

        // const maybeContext = this.boolean.evaluate(context);
        // return maybeContext.notThrown(v =&gt; {
        //     if(v.value) {
        //         const ctx = this.stmt.evaluate(context);
        //         return ctx.either(
        //             leftContext =&gt; leftContext, 
        //             rightContext =&gt; rightContext.notReturn(
        //                 c =&gt; c.isBroken() ? c.fixBroken() : this.evaluate(c)        
        //             )
        //         );
        //     }    
        //     return context;
        // });
    }   
}
</code></pre>
<p>嗯？那段註解是什麼？你可以試著找找看 ToyLang 的 .js 實作原始碼，看看其他地方有沒有出現 <code>while</code>，實際上，這是唯一使用到 <code>while</code> 的地方喔！另外，在 .js 實作原始碼中，絕大多數的地方在宣告變數時是使用 <code>const</code>，只有在少數地方使用到 <code>let</code>。</p>
<p>在實作 ToyLang 時，我特意在大多數的地方採用函數式典範，這有很大的好處，特別是對函式流程的抽取、模組與類別職責的分配，以及模組與物件之間的獨立性等，我一直都有談到，對於語言實作來說，元件的獨立性很重要，若以函數式典範作為出發點，你就得一開始就考慮這些要素。</p>
<p>也就因此，具有重複性的邏輯，很多都被 <code>filter</code>、<code>map</code>、<code>reduce</code> 這種基本模式的實作品給解決掉了，<code>filter</code>、<code>map</code>、<code>reduce</code> 做不到的，就採用遞迴解決，結果就是每個函式流程都很精簡，每個模組也不巨大。</p>
<p>然而，這在實作 <code>while</code> 就會有問題，因為 JavaScript 並不支援遞迴的展開，也就因此，會受到遞迴深度的限制，上面程式碼註解的部份，就是實作 <code>while</code> 時對應的遞迴版本，實作它是有價值的，然而，因為受到遞迴深度的限制，<code>while</code> 本體變成差不多只能執行 2000 次左右了。</p>
<p>雖然是 ToyLang，然而，如果 <code>while</code> 只能執行 2000 次左右，那就連 Toy 都稱不上了，對吧！？這也就令此處，成了唯一有使用到 <code>while</code> 實作的地方了！</p>
<p>話說，一下子又是 ToyLang 的 <code>while</code>，一下子又是 JavaScript 的 <code>while</code>，你知道我正在談哪個 <code>while</code> 嗎？沒辦法！選的關鍵字雷同，經常會搞不清楚嘞！</p>
<p>之後在實作類別與實例時，我也是常得保持腦袋清楚，不然，很容易搞不清楚，我現在是想要 JavaScript 的某個實例，還是 ToyLang 的某個實例啊&hellip;XD</p>

            
           <br><br><div class="ad336-280" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型廣告 336 x 280 --><ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-9750319131714390" data-ad-slot="9976409681"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div><br><div class="recommend" style="text-align: center;"><hr><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 自動大小回應相符內容 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="4953478487" data-ad-format="autorelaxed"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>
        </article>
    </main>
</div></body>
</html>
<script src="../js/ui.js"></script>
<div class="analytics">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'G-QVQQYFSC8J', 'auto');
  ga('send', 'pageview');

</script>
</div>
