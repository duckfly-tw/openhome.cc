<!doctype html><html lang="zh-tw">
<head><meta http-equiv="refresh" content="0; URL=https://openhome.cc/Gossip/Toy/'https://openhome.cc/zh-tw/toy-lang/fundamental/var-assign/'">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="ToyLang 是動態定型語言，變數本身並沒有型態資訊，只是用來對應至值或物件，要建立變數，只要命名變數並指定值給它就可以了：
n = 10
n = 'Justin'

由於變數本身沒有型態，之後可以...">

    <meta property="og:locale" content="zh_TW">
    <meta property="og:title" content="變數與指定陳述">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://openhome.cc/Gossip/Toy/VariabeAssign.html">
    <meta property="og:image" content="https://openhome.cc/Gossip/images/caterpillar_small.jpg">
    <meta property="og:site_name" content="OPENHOME.CC">
    <meta property="og:description" content="ToyLang 是動態定型語言，變數本身並沒有型態資訊，只是用來對應至值或物件，要建立變數，只要命名變數並指定值給它就可以了：
n = 10
n = 'Justin'

由於變數本身沒有型態，之後可以...">

    <title>變數與指定陳述</title>

    <link rel="stylesheet" href="../css/pure-0.6.0/pure-min.css">

    <!--[if lte IE 8]>
        <link rel="stylesheet" href="../css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="../css/layouts/side-menu.css">
    <!--<![endif]-->
  

     <link rel="stylesheet" href="../css/caterpillar.css">
     <script async src="../google-code-prettify/run_prettify.js"></script>
     <!-- 網頁層級廣告 --><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle =window.adsbygoogle || []).push({google_ad_client: "ca-pub-9750319131714390",enable_page_level_ads: true });</script></head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="VariabeAssign.html#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon -->
        <span></span>
    </a>
    <div id="menu">
        <div class="pure-menu">
            <a class="pure-menu-heading" href="https://openhome.cc/Gossip/Toy/index.html"><< Toy</a>
            <ul class="pure-menu-list">
                <li class="pure-menu-item"><br><div class="social" style="text-align: center;"><a href="http://twitter.com/caterpillar"><img title="Twitter" alt="Twitter" src="../images/twitter.png"></a> <a href="http://www.facebook.com/openhome.cc"><img title="Facebook" alt="Facebook" src="../images/facebook.png"></a> </div><br> <div id="search box"><script>(function() {var cx = 'partner-pub-9750319131714390:3926766884';var gcse = document.createElement('script');gcse.type = 'text/javascript';gcse.async = true;gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(gcse, s);})();</script><gcse:searchbox-only></gcse:searchbox-only></div><br><div class="ad" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 2015 新版型 160 x 600 廣告 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:600px"
     data-ad-client="ca-pub-9750319131714390"
     data-ad-slot="3747048883"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div></li>
            </ul>
        </div>
    </div>

    <main id="main">
        <header class="header">
            <h1>變數與指定陳述</h1>
        </header>

        <article class="content">
            <br><div class="ad-3" style="text-align: center;"><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型回應式廣告 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="7104125683" data-ad-format="auto"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div> 
            
            <p>ToyLang 是動態定型語言，變數本身並沒有型態資訊，只是用來對應至值或物件，要建立變數，只要命名變數並指定值給它就可以了：</p>
<pre class="prettyprint"><code lang="toy">n = 10
n = 'Justin'
</code></pre>
<p>由於變數本身沒有型態，之後可以將字串 <code>'Justin'</code> 指定給 <code>n</code>；在建立變數之前，嘗試存取變數會發生 <code>ReferenceError</code>。例如：</p>
<pre class="prettyprint"><code lang="toy">println(x)
</code></pre>
<p>若 <code>x</code> 變數不存在，會出現以下錯誤訊息：</p>
<pre class="prettyprint"><code lang="toy">ReferenceError: x is not defined
    at println(x) (/main.toy:1)
</code></pre>
<p><code>=</code> 是個指定陳述，除了它之外，還有 <code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>&amp;=</code>、<code>|=</code>、<code>&gt;&gt;</code>=、<code>&lt;&lt;=</code> 等指定陳述，與其他語言的指定陳述作用相同。例如：</p>
<pre class="prettyprint"><code lang="toy">x = 10
x += 2 # 相當於 x = x + 2
x -= 3 # 相當於 x = x - 3
</code></pre>
<p>想要建立變數，一定得指定某個值才有可能，沒有方式可以建立一個變數而沒有值，你會想到其他語言中可能有 <code>null</code>、<code>undefined</code>、<code>None</code>、<code>nil</code> 之類的實字或名稱，ToyLang 中沒有這類東西。</p>
<hr />
<p>變數在語言實作時，也是一個語法節點，基本上只是用來包含名稱：</p>
<pre class="prettyprint"><code lang="toy">class Variable {
    constructor(name) {
        this.name = name;
    }

    evaluate(context) {
        return context.lookUpVariable(this.name);
    }
}
</code></pre>
<p>例如，<code>new Variable('x')</code> 代表著建立了一個 <code>x</code> 變數的對應節點，變數沒有任何值的資訊，在執行時想要取得變數的對應值，意義就是查找環境變數中，是否有名稱對應的節點，也就是 <code>evaluate</code> 方法的實作內容。</p>
<p>那麼，指定陳述又是什麼意思？以 <code>=</code> 為例，其對應的節點可以如下定義：</p>
<pre class="prettyprint"><code lang="toy">class VariableAssign {
    constructor(variable, value) {
        this.variable = variable;
        this.value = value;
    }

    evaluate(context) {
        return context.assign(this.variable.name, value);
    }
}
</code></pre>
<p>例如，對於底下的程式碼：</p>
<pre class="prettyprint"><code lang="toy">x = 10
</code></pre>
<p>會建立如下的語法節點：</p>
<pre class="prettyprint"><code lang="toy">const variableAssign = new VariableAssign(new Variable('x'), new Primitive(10))
</code></pre>
<p>實際執行 <code>variableAssign.evaluate(context)</code> 時，會需要一個環境物件 <code>context</code>，環境物件的作用之一，就是保存變數名稱與對應的值節點，這可以使用一個簡單的 <code>Map</code>：</p>
<pre class="prettyprint"><code lang="toy">class Context {
    constructor(variables = new Map()) {
        this.variables = variables;
    }

    assign(variable, value) {
        this.variables.set(variable, value);
        return this;
    }

    lookUpVariable(name) {
        return this.variables.get(name);
    }     
}

const context = new Context();
variableAssign.evaluate(context);
</code></pre>
<p>因此 <code>variableAssign.evaluate(context)</code> 之後，環境物件保存變數的 <code>Map</code>，就會有個 <code>x</code> 至 <code>Primitive</code> 實例（內含原生值 10）的對應，之後 <code>new Variable('x').evaluate(context)</code> 時，自然就可以取得 <code>Primitive</code> 實例（內含原生值 10）。</p>
<p>在這邊剛好可以說明一下運算式（expression）與陳述句（statement）的差異性，如先前的文件中看到的，運算式基本上不會改變環境物件的狀態，而在這邊可以看到，陳述句可能改變環境物件狀態（或者是外部狀置狀態），也就是會產生副作用（Side effect）。</p>
<p>（如果實作的是函數式語言，像指定陳述的執行結果，會是產生一個新的環境物件，內含指定陳述之後的結果。）</p>
<p>問題接著來了，如何將兩個陳述句串起來執行呢？畢竟，程式會是由許多行陳述句構成，語法樹上，必須將這些陳述句對應的節點銜接起來，這時需要個 <code>StmtSequence</code> 之類的東西：</p>
<pre class="prettyprint"><code lang="toy">class StmtSequence {
    constructor(firstStmt, secondStmt) {
        this.firstStmt = firstStmt;
        this.secondStmt = secondStmt;
    }

    evaluate(context) {
        return this.secondStmt.evaluate(this.firstStmt.evaluate(context));
    }
}
</code></pre>
<p>例如：</p>
<pre class="prettyprint"><code lang="toy">x = 10
y = x + 20
</code></pre>
<p>語法樹會是：</p>
<pre class="prettyprint"><code lang="toy">new StmtSequence(
    new VariableAssign(
        new Variable('x'), 
        new Primitive(10)
    ),
    new VariableAssign(
        new Variable('y'), 
        new Add(
            new Variable('x'), 
            new Primitive(20)
        )
   )
)
</code></pre>
<p>在執行 <code>StmtSequence</code> 實例的 <code>evaluate</code> 方法時，就會依序執行各個節點的 <code>evaluate</code> 方法，因而可以發現，實作語言的重點之一，就是每個節點一定只關心自己的 <code>evaluate</code> 運算，只要定義好各節點獨立的職責，就可以（依語言規則）自由組合節點，這就是為什麼程式語言可以應付各式各樣的需求之原因。</p>
<p>當然，不可能自行建立語法樹，這是 Parser 的工作，也就是從程式碼切割單詞、判斷單詞並建立對應的語法樹，寫 Parser 很麻煩，然而，如果是以行為單位的剖析的話，可以令工作簡單一些，而這也就是 ToyLang 的作法。</p>
<p>然而，這並不是正確的作法，Regex 應該用於單詞分析，而不是用來判斷數個單詞組成的語法結構代表什麼，隨著語言的文法越複雜，ToyLang 的這個做法，對語言也會造成更多限制，這就是我土炮這門語言得到的教訓，之後會談到。</p>
<p>無論如何，就現有的做法來說，對於 <code>=</code> 指定陳述，基本的模式會是：</p>
<pre class="prettyprint"><code lang="toy">new RegExp(`^(${VARIABLE_REGEX.source})\\s*=\\s*(.*)$`)]
</code></pre>
<p>隨著你的 Regex 模式增多，記得將 Regex 作適當管理，如上頭的 <code>VARIABLE_REGEX</code>，實際上就是 <code>/[a-zA-Z_]+[a-zA-Z_0-9]*/</code>，然而，用個變數並如上頭的組合方式，會讓以 <code>VARIABLE_REGEX</code> 為基礎的 Regex 較易閱讀。</p>
<p>由於是基於行的剖析，指定陳述的剖析在 <code>=</code> 之後，可以簡化為多個任意字元，<code>=</code> 之後捕捉到的部份，交給運算式剖析器處理就好了。</p>
<p>可以在 <a href="https://github.com/JustinSDK/toy_lang/blob/master/toy_lang/js/interpreter/line_parser.js">line_parser.js</a> 中看到，裏頭有各種陳述句剖析之後的語法節點建立方式，而指定陳述的建立，被封裝在 <code>createAssign</code> 之中：</p>
<pre class="prettyprint"><code lang="toy">function createAssign(tokenableLines, clzNode, target, operatorTokenable, assignedTokenable) {
    return new StmtSequence(
        new clzNode(
            target, 
            EXPR_PARSER.parse(assignedTokenable),
            operatorTokenable.value
        ),
        LINE_PARSER.parse(tokenableLines.slice(1)),
        tokenableLines[0].lineNumber
    );
}
</code></pre>
<p><code>createAssign</code> 不會去關心 <code>=</code> 右邊的事，這部份被交給了 <code>EXPR_PARSER</code>，也就是運算式剖析器，<code>EXPR_PARSER</code> 會對右邊剖析，建立相對應的運算式各語法節點。</p>
<p>也就是說，如同語法樹節點只關係自己的職責，剖析器也是，指定陳述只關心 <code>=</code> 左邊是否為變數，右邊是否為運算式，其他的陳述句也會有各自關心的事，這樣文法才能具有遞迴性。</p>
<p>方才談到 <code>StmtSequence</code>，程式碼一定有結束的時候，因此，必須有個空的 <code>StmtSequence</code>，這可以在 <a href="https://github.com/JustinSDK/toy_lang/blob/master/toy_lang/js/interpreter/ast/statement.js">statement.js</a> 看到：</p>
<pre class="prettyprint"><code lang="toy">StmtSequence.EMPTY = {
    lineCount : 0,
    // We don't care about emtpy statements so the lineNumber 0 is enough.
    lineNumber : 0, 
    evaluate(context) {
        return context;
    }
};
</code></pre>
<p>空陳述句什麼都不做，只是將傳入的環境物件傳回，程式碼的結束、區塊的結束等，都可以用空的 <code>StmtSequence</code> 來代表，這之後會看到。</p>
<p>以上的描述是經過簡化的，實際的情況會比較複雜一些，例如，你可以想一下，那 <code>+=</code>、<code>-=</code> 怎麼做，而之後還會看到，像是 <code>if</code>、<code>while</code> 等，並不是只有單行，而是會有一整個區塊，之後也會談到如何處理整個區塊的陳述句。</p>

            
           <br><br><div class="ad336-280" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型廣告 336 x 280 --><ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-9750319131714390" data-ad-slot="9976409681"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div><br><div class="recommend" style="text-align: center;"><hr><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 自動大小回應相符內容 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="4953478487" data-ad-format="autorelaxed"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>
        </article>
    </main>
</div></body>
</html>
<script src="../js/ui.js"></script>
<div class="analytics">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'G-QVQQYFSC8J', 'auto');
  ga('send', 'pageview');

</script>
</div>
