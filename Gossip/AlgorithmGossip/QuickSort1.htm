<!doctype html><html lang="zh-tw">
<head><meta http-equiv="refresh" content="0; URL=https://openhome.cc/Gossip/AlgorithmGossip/'https://openhome.cc/zh-tw/algorithm/sort/quick/'">
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="說明

      


快速排序法（Quick sort）是目前常用的排序方法之一，雖然快速排序法在最差狀況下會達O(n2)，但在多數情況下，快速排序法具有相當不錯的效率表現。

  ...">

<meta property="og:locale" content="zh_TW">
<meta property="og:title" content="快速排序法（一）">
<meta property="og:type" content="article">
<meta property="og:url" content="https://openhome.cc/Gossip/AlgorithmGossip/QuickSort1.htm">
<meta property="og:image" content="https://openhome.cc/Gossip/images/caterpillar_small.jpg">
<meta property="og:site_name" content="OPENHOME.CC">
<meta property="og:description" content="說明

      


快速排序法（Quick sort）是目前常用的排序方法之一，雖然快速排序法在最差狀況下會達O(n2)，但在多數情況下，快速排序法具有相當不錯的效率表現。

  ...">


    <title>快速排序法（一）</title>

<link rel="stylesheet" href="../css/pure-0.6.0/pure-min.css">

    <!--[if lte IE 8]>
        <link rel="stylesheet" href="../css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="../css/layouts/side-menu.css">
    <!--<![endif]-->
  

     <link rel="stylesheet" href="../css/caterpillar.css">
     <script async src="../google-code-prettify/run_prettify.js"></script>
<!-- 網頁層級廣告 --><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle =window.adsbygoogle || []).push({google_ad_client: "ca-pub-9750319131714390",enable_page_level_ads: true });</script></head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="QuickSort1.htm#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon --><span></span>
        
    </a>
    <div id="menu">
        <div class="pure-menu">
            <a class="pure-menu-heading" href="index.html">回 Algorithm</a>
            <ul class="pure-menu-list">
                <br><div class="social" style="text-align: center;"><a href="http://twitter.com/caterpillar"><img title="Twitter" alt="Twitter" src="../images/twitter.png"></a> <a href="http://www.facebook.com/openhome.cc"><img title="Facebook" alt="Facebook" src="../images/facebook.png"></a> </div><br><div id="search box"><script>(function() {var cx = 'partner-pub-9750319131714390:3926766884';var gcse = document.createElement('script');gcse.type = 'text/javascript';gcse.async = true;gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(gcse, s);})();</script><gcse:searchbox-only></gcse:searchbox-only></div><br><div class="ad" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 2015 新版型 160 x 600 廣告 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:600px"
     data-ad-client="ca-pub-9750319131714390"
     data-ad-slot="3747048883"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div></li>
            </ul>
        </div>
    </div>

    <main id="main">
        <header class="header">
            <h1>快速排序法（一）</h1>
        </header>

        <article class="content"><br><div class="ad-3" style="text-align: center;"><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型回應式廣告 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="7104125683" data-ad-format="auto"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div> 
             






      
      <h2>說明</h2>

      


快速排序法（Quick sort）是目前常用的排序方法之一，雖然快速排序法在最差狀況下會達O(n<sup>2</sup>)，但在多數情況下，快速排序法具有相當不錯的效率表現。<br>

      <br>




快速排序法精神是分而治之，以昇冪為例，基本上就將數列分為小於S的子數列、S與大於S的子數列，接著對兩個子數列作相同處理，S稱為軸心，不同的快速排序法實作，差別在於S的選擇與分出子數列的方式。<br>




      
      <h2>解法</h2>

      




這邊介紹的第一個快速排序法版本，其S的選擇是數列開頭，並同時由左而右及由右至左分出子數列：<br>
      <br>
      <div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" alt="" src="images/quickSort1-1.jpg" /></div></div><br>
      <br>
      尚未處理的數列會是在中間被逐步消化完畢：<br>
      <br>
      <div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" alt="" src="images/quickSort1-2.jpg" /></div></div><br>
      <br>
接著將S置於兩個子數列之間。<br>
      <br>
      <div class="pure-g"><div class="pure-u-1"><img class="pure-img-responsive" alt="" src="images/quickSort1-3.jpg" /></div></div><br>
      <br>
此時S左邊都是小於等於S，右邊都是大於S，再分別對這兩個子數列做遞迴處理。<br>
      <br>
      






      
      <h2> 實作：<a href="QuickSort1.htm#C">C</a>&nbsp;&nbsp; &nbsp;<a href="QuickSort1.htm#Java">Java</a>&nbsp;&nbsp; &nbsp;<a href="QuickSort1.htm#Python">Python</a>&nbsp;&nbsp; &nbsp;<a href="QuickSort1.htm#Scala">Scala</a>&nbsp;&nbsp;&nbsp; <a href="QuickSort1.htm#Ruby">Ruby</a>&nbsp;&nbsp;&nbsp; <a href="QuickSort1.htm#JavaScript">JavaScript</a>&nbsp;&nbsp;&nbsp; <a href="QuickSort1.htm#Haskell">Haskell</a><br>
      </h2>





      
      <ul>

        <li><a name="C"></a> C
  </li>

      
      </ul>





      
      <pre class="prettyprint"><code>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br>#define LEN 10 <br>#define SWAP(x,y) {int t; t = x; x = y; y = t;} <br><br>void sort(int*, int, int(*)(int, int)); <br>void quickSort(int*, int, int, int(*)(int, int)); <br>void print(int*, int len);<br>int ascending(int, int);<br>int descending(int, int);<br><br>int main(void) { <br>    int number[LEN] = {10, 9, 1, 2, 5, 3, 8, 7, 12, 11};<br>    <br>    sort(number, LEN, ascending); <br>    print(number, LEN);<br>    <br>    sort(number, LEN, descending); <br>    print(number, LEN);<br><br>    return 0; <br>} <br><br>void sort(int* number, int len, int(*comp)(int, int)) {<br>    quickSort(number, 0, len - 1, comp); <br>}<br><br>void quickSort(int* number, int left, int right, int(*comp)(int, int)) {<br>    if(left &lt; right) {<br>        int axis = partition(number, left, right, comp); <br>        quickSort(number, left, axis - 1, comp);  <br>        quickSort(number, axis + 1, right, comp); <br>    } <br>}<br><br>int partition(int* number, int left, int right, int(*comp)(int, int)) {<br>    int s = number[left];<br>    int axis = partitionUnprocessed(number, left + 1, right, s, comp);<br>    SWAP(number[left], number[axis]); <br>    return axis;<br>}<br><br>int partitionUnprocessed(int* number, int left, int right, <br>                         int s, int(*comp)(int, int)) {<br>    int i = lookRight(number, left, right, s, comp);<br>    int j = lookLeft(number, right, i, s, comp);<br>    if(i &lt; j) {<br>        SWAP(number[i], number[j]); <br>        return partitionUnprocessed(number, i + 1, j - 1, s, comp);<br>    }<br>    return j;<br>}<br><br>int lookRight(int* number, int from, int to, int s, int(*comp)(int, int)) {<br>    int i = from;<br>    while(i &lt; to + 1 &amp;&amp; comp(number[i], s) &lt;= 0) { i++; }<br>    return i;<br>}<br><br>int lookLeft(int* number, int from, int to, int s, int(*comp)(int, int)) {<br>    int j = from;<br>    while(j &gt; to - 1 &amp;&amp; comp(number[j], s) &gt; 0) { j--; }<br>    return j;<br>}<br><br>void print(int* arr, int len) {<br>    int i;<br>    for(i = 0; i &lt; len; i++) { printf("%d ", arr[i]); } <br>    printf("\n");<br>}<br><br>int ascending(int a, int b) { return a - b; }<br>int descending(int a, int b) { return -ascending(a, b); }<br></code></pre>





      <br>





      
      <ul>

        <li><a name="Java"></a> Java
  </li>

      
      </ul>





      
      <pre class="prettyprint"><code>import java.util.*;<br>import static java.lang.System.out;<br>import static java.util.Collections.swap;<br><br>public class Sort {<br>    public static &lt;T extends Comparable&lt;? super T&gt;&gt; <br>        int ascending(T t1, T t2) {  return t1.compareTo(t2); }<br><br>    public static &lt;T extends Comparable&lt;? super T&gt;&gt; <br>        int descending(T t1, T t2) { return -ascending(t1, t2); }<br>    <br>    public static &lt;T extends Comparable&lt;? super T&gt;&gt; <br>        void sort(List&lt;T&gt; list) { sort(list, Sort::ascending); }<br><br>    public static &lt;T&gt; void sort(<br>        List&lt;T&gt; list, Comparator&lt;? super T&gt; c) {<br>         quickSort(list, 0, list.size() - 1, c);<br>    }<br><br>    private static &lt;T&gt; void quickSort(<br>        List&lt;T&gt; list, int left, int right, Comparator&lt;? super T&gt; c) {<br>        if(left &lt; right) {<br>            int axis = partition(list, left, right, c); <br>            quickSort(list, left, axis - 1, c);  <br>            quickSort(list, axis + 1, right, c); <br>        }<br>    }<br><br>    private static &lt;T&gt; int partition(List&lt;T&gt; list, <br>                      int left, int right, Comparator&lt;? super T&gt; c) {<br>        T s = list.get(left);<br>        int axis = partitionUnprocessed(list, left + 1, right, s, c);<br>        swap(list, left, axis);<br>        return axis;<br>    }<br><br>    private static &lt;T&gt; int partitionUnprocessed(List&lt;T&gt; list, <br>                      int left, int right, T s, Comparator&lt;? super T&gt; c) {<br>        int i = lookRight(list, left, right, s, c);<br>        int j = lookLeft(list, right, i, s, c);<br>        if(i &lt; j) {<br>            swap(list, i, j);<br>            return partitionUnprocessed(list, i + 1, j - 1, s, c);<br>        }<br>        return j;<br>    }<br><br>    private static &lt;T&gt; int lookRight(List&lt;T&gt; list, <br>                        int from, int to, T s, Comparator&lt;? super T&gt; c) {<br>        int i = from;<br>        while(i &lt; to + 1 &amp;&amp; c.compare(list.get(i), s) &lt;= 0) { i++; }<br>        return i;<br>    }<br><br>    private static &lt;T&gt; int lookLeft(List&lt;T&gt; list, <br>                        int from, int to, T s, Comparator&lt;? super T&gt; c) {<br>        int j = from;<br>        while(j &gt; to - 1 &amp;&amp; c.compare(list.get(j), s) &gt; 0) { j--; }<br>        return j;<br>    }<br>        <br>    public static void main(String[] args) {<br>        List&lt;Integer&gt; list = <br>            new ArrayList&lt;&gt;(Arrays.asList(10, 9, 1, 2, 5, 3, 8, 7, 12, 11));<br>        <br>        sort(list);<br>        out.println(list);<br>        <br>        sort(list, Sort::descending);<br>        out.println(list);<br>    }<br>}</code></pre>




      <br><ul><li><a name="Python"></a>Python</li></ul><pre class="prettyprint"><code>def ascending(a, b): return a - b<br>def descending(a, b): return -ascending(a, b)<br><br>def quickSort(xs, comp = ascending):<br>    if not xs:<br>        return []<br>    else:<br>        lefter, axis, righter = partition(xs, comp)<br>        return quickSort(lefter, comp) + axis + quickSort(righter, comp)<br><br>def partition(xs, comp):<br>    lefter, righter = partitionUnpressed(<br>        xs[1:], 0, len(xs[1:]) - 1, xs[0], comp)<br>    return (lefter, [xs[0]], righter)<br><br>def partitionUnpressed(xs, left, right, s, comp):<br>    i = lookRight(xs, left, right, s, comp)<br>    j = lookLeft(xs, right, i, s, comp)<br>    if i &lt; j:<br>        outerLefter = xs[left:i] + [xs[j]]<br>        outerRightr = [xs[i]] + xs[j + 1 : right + 1]<br>        innerLefter, innerRighter = partitionUnpressed(<br>            xs, i + 1, j - 1, s, comp)<br>        return (outerLefter + innerLefter, innerRighter + outerRightr)<br>    return (xs[left : i], xs[j + 1 : right + 1])<br><br>def lookRight(xs, i, to, s, comp):<br>    return (lookRight(xs, i + 1, to, s, comp) <br>               if i &lt; to + 1 and comp(xs[i], s) &lt;= 0 else i)<br><br>def lookLeft(xs, j, to, s, comp):<br>    return (lookLeft(xs, j - 1, to, s, comp) <br>               if j &gt; to - 1 and comp(xs[j], s) &gt; 0 else j)<br><br>list = [10, 9, 1, 2, 5, 3, 8, 7, 12, 11]<br><br>print(quickSort(list))<br>print(quickSort(list, descending))</code></pre><br><ul><li><a name="Scala"></a>Scala</li></ul><pre class="prettyprint"><code>object Sort {<br>    def quick[T](xs: List[T], compare: (T, T) =&gt; Boolean): List[T] = {<br>        if(xs.isEmpty) Nil<br>        else {<br>            val (lefter, axis, righter) = partition(xs, compare)<br>            quick(lefter, compare) ++ axis ++ quick(righter, compare)<br>        }<br>    }<br><br>    def partition[T](xs: List[T], compare: (T, T) =&gt; Boolean) = {<br>        val (lefter, righter) = partitionUnpressed(<br>            xs.tail, 0, xs.size - 2, xs.head, compare)<br>        (lefter, List(xs.head), righter)<br>    }<br><br>    def partitionUnpressed[T](xs: List[T], left: Int, right: Int, <br>                s: T, compare: (T, T) =&gt; Boolean): (List[T], List[T])= {<br>        val i = lookRight(xs, left, right, s, compare)<br>        val j = lookLeft(xs, right, i, s, compare)<br>        if(i &lt; j) {<br>            val outerLefter = xs.slice(left, i) ++ List(xs(j))<br>            val outerRighter = xs(i) :: xs.slice(j + 1, right + 1)<br>            val (innerLefter, innerRighter) = <br>                partitionUnpressed(xs, i + 1, j - 1, s, compare)<br>            (outerLefter ++ innerLefter, innerRighter ++ outerRighter)<br>        } else {<br>            (xs.slice(left, i), xs.slice(j + 1, right + 1))<br>        }<br>    }<br><br>    def lookRight[T](xs: List[T], i: Int, to: Int, <br>                s: T, compare: (T, T) =&gt; Boolean): Int = {<br>        if(i &lt; to + 1 &amp;&amp; compare(xs(i), s)) <br>            lookRight(xs, i + 1, to, s, compare) <br>        else i<br>    }<br><br>    def lookLeft[T](xs: List[T], j: Int, to: Int, <br>                s: T, compare: (T, T) =&gt; Boolean): Int = {<br>        if(j &gt; to - 1 &amp;&amp; !compare(xs(j), s)) <br>            lookLeft(xs, j - 1, to ,s, compare) <br>        else j<br>    }<br>}<br><br>val list = List(10, 9, 1, 2, 5, 3, 8, 7, 12, 11)<br><br>println(Sort.quick[Int](list, _ &gt; _))<br>println(Sort.quick[Int](list, _ &lt; _))</code></pre><br>
      <ul>
        <li><a name="Ruby"></a>Ruby</li>
      </ul>
      <pre class="prettyprint"><code>class Sort<br>    @@ascending = -&gt;(a, b) { a - b }<br>    @@descending = -&gt;(a, b) { -@@ascending.call(a, b) }<br>    <br>    def self.ascending; @@ascending end<br>    def self.descending; @@descending end<br>    <br>    def self.quick(xs, comp)<br>        if xs.empty?<br>            []<br>        else<br>            lefter, axis, righter = *partition(xs, comp)<br>            quick(lefter, comp) + axis + quick(righter, comp)<br>        end<br>    end<br><br>    def self.partition(xs, comp)<br>        (head, *tail) = xs<br>        lefter, righter = *partitionUnpressed(<br>            tail, 0, xs.size - 2, head, comp)<br>        [lefter, [head], righter]<br>    end<br>    private_class_method :partition<br><br>    def self.partitionUnpressed(xs, left, right, s, comp)<br>        i = lookRight(xs, left, right, s, comp)<br>        j = lookLeft(xs, right, i, s, comp)<br>        if i &lt; j<br>            outerLefter = xs[left...i] + [xs[j]]<br>            outerRightr = [xs[i]] + xs[j + 1...right + 1]<br>            innerLefter, innerRighter = *partitionUnpressed(<br>                xs, i + 1, j - 1, s, comp)<br>            [outerLefter + innerLefter, innerRighter + outerRightr]<br>        else<br>            [xs[left...i], xs[j + 1...right + 1]]<br>        end<br>    end<br>    private_class_method :partitionUnpressed<br><br>    def self.lookRight(xs, i, to, s, comp)<br>        (i &lt; to + 1 and comp.call(xs[i], s) &lt;= 0) ? <br>            lookRight(xs, i + 1, to, s, comp) : i<br>    end<br>    private_class_method :lookRight<br><br>    def self.lookLeft(xs, j, to, s, comp)<br>        (j &gt; to - 1 and comp.call(xs[j], s) &gt; 0) ? <br>            lookLeft(xs, j - 1, to, s, comp) : j<br>    end<br>    private_class_method :lookLeft<br>end<br><br>list = [10, 9, 1, 2, 5, 3, 8, 7, 12, 11]<br><br>print(Sort.quick(list, Sort.ascending).to_s + "\n")<br>print(Sort.quick(list, Sort.descending).to_s + "\n")<br></code></pre>
      <br>
      <ul>
        <li><a name="JavaScript"></a>JavaScript</li>
      </ul>
      <pre class="prettyprint"><code>function ascending(a, b) {return a - b;}<br>function descending(a, b) {return -ascending(a, b);}<br><br>var quickSort = function() {<br>    function swap(list, i, j) {<br>        var ele = list[i];<br>        list[i] = list[j];<br>        list[j] = ele;<br>    }<br><br>    function quick(list, left, right, c) {<br>        if(left &lt; right) {<br>            var axis = partition(list, left, right, c); <br>            quick(list, left, axis - 1, c);  <br>            quick(list, axis + 1, right, c); <br>        }<br>    }<br>    <br>    function partition(list, left, right, c) {<br>        var s = list[left];<br>        var axis = partitionUnprocessed(list, left + 1, right, s, c);<br>        swap(list, left, axis);<br>        return axis;<br>    }<br><br>    function partitionUnprocessed(list, left, right, s, c) {<br>        var i = lookRight(list, left, right, s, c);<br>        var j = lookLeft(list, right, i, s, c);<br>        if(i &lt; j) {<br>            swap(list, i, j);<br>            return partitionUnprocessed(list, i + 1, j - 1, s, c);<br>        }<br>        return j;<br>    }<br><br>    function lookRight(list, from, to, s, c) {<br>        var i = from;<br>        while(i &lt; to + 1 &amp;&amp; c(list[i], s) &lt;= 0) { i++; }<br>        return i;<br>    }<br><br>    function lookLeft(list, from, to, s, c) {<br>        var j = from;<br>        while(j &gt; to - 1 &amp;&amp; c(list[j], s) &gt; 0) { j--; }<br>        return j;<br>    }<br><br>    return function(list, c) {<br>        return quick(list, 0, list.length - 1, c);<br>    };<br>}();<br><br>var list = [10, 9, 1, 2, 5, 3, 8, 7, 12, 11];<br><br>quickSort(list, ascending);<br>print(list);<br><br>quickSort(list, descending);<br>print(list);<br></code></pre>
      <br>
      <ul>
        <li><a name="Haskell"></a>Haskell</li>
      </ul>
      <pre class="prettyprint"><code>ascending a b = a - b<br>descending a b = -ascending a b<br><br>slice from to xs = take (to - from) (drop from xs)<br><br>quickSort xs comp =<br>    if xs == [] then []<br>    else<br>        let (lefter, axis, righter) = partition xs comp<br>        in (quickSort lefter comp) ++ axis ++ (quickSort righter comp)<br><br>partition xs comp =<br>    let (lefter, righter) = <br>            partitionUnpressed (tail xs) 0 (length xs - 2) (head xs) comp<br>    in (lefter, [head xs], righter)<br><br>partitionUnpressed xs left right s comp =<br>    let i = lookRight xs left right s comp<br>        j = lookLeft xs right i s comp<br>    in<br>        if i &lt; j then<br>            let outerLefter = (slice left i xs) ++  [xs !! j]<br>                outerRighter = (xs !! i) : slice (j + 1) (right + 1) xs<br>                (innerLefter, innerRighter) = <br>                    partitionUnpressed xs (i + 1) (j - 1) s comp<br>            in (outerLefter ++ innerLefter, innerRighter ++ outerRighter)<br>        else (slice left i xs, slice (j + 1) (right + 1) xs)<br><br><br>lookRight xs i to s comp =<br>    if i &lt; to + 1 &amp;&amp; (comp (xs !! i) s) &lt;= 0<br>        then lookRight xs (i + 1) to s comp<br>        else i<br><br>lookLeft xs j to s comp = <br>    if j &gt; to - 1 &amp;&amp; (comp (xs !! j) s) &gt; 0<br>        then lookLeft xs (j - 1) to s comp<br>        else j<br><br>main = sequence [print \$ quickSort xs ascending, <br>                 print \$ quickSort xs descending]<br>    where xs = [10, 9, 1, 2, 5, 3, 8, 7, 12, 11]<br></code></pre>
<br>



 





<br><br><div class="ad-2" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型回應式廣告 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="7104125683" data-ad-format="auto"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></article></main></div></body>
<script src="../js/ui.js"></script>
</html>
<div class="analytics"><script async src="https://www.googletagmanager.com/gtag/js?id=G-QVQQYFSC8J"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-QVQQYFSC8J');</script></div>
