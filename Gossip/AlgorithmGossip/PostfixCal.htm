<!doctype html><html lang="zh-tw">
<head><meta http-equiv="refresh" content="0; URL=https://openhome.cc/Gossip/AlgorithmGossip/'https://openhome.cc/zh-tw/algorithm/computation/postfix-eval/'">
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="說明
將 中序式轉換為後序式
的好處是，不用處理運算子先後順序問題，只要依序由運算式由前往後讀取即可。 
      
       解法

      


運算時由後序式的前方開...">

<meta property="og:locale" content="zh_TW">
<meta property="og:title" content="後序式的運算">
<meta property="og:type" content="article">
<meta property="og:url" content="https://openhome.cc/Gossip/AlgorithmGossip/PostfixCal.htm">
<meta property="og:image" content="https://openhome.cc/Gossip/images/caterpillar_small.jpg">
<meta property="og:site_name" content="OPENHOME.CC">
<meta property="og:description" content="說明
將 中序式轉換為後序式
的好處是，不用處理運算子先後順序問題，只要依序由運算式由前往後讀取即可。 
      
       解法

      


運算時由後序式的前方開...">


    <title>後序式的運算</title>

<link rel="stylesheet" href="../css/pure-0.6.0/pure-min.css">

    <!--[if lte IE 8]>
        <link rel="stylesheet" href="../css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="../css/layouts/side-menu.css">
    <!--<![endif]-->
  

     <link rel="stylesheet" href="../css/caterpillar.css">
     <script async src="../google-code-prettify/run_prettify.js"></script>
<!-- 網頁層級廣告 --><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle =window.adsbygoogle || []).push({google_ad_client: "ca-pub-9750319131714390",enable_page_level_ads: true });</script></head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="PostfixCal.htm#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon --><span></span>
        
    </a>
    <div id="menu">
        <div class="pure-menu">
            <a class="pure-menu-heading" href="index.html">回 Algorithm</a>
            <ul class="pure-menu-list">
                <br><div class="social" style="text-align: center;"><a href="http://twitter.com/caterpillar"><img title="Twitter" alt="Twitter" src="../images/twitter.png"></a> <a href="http://www.facebook.com/openhome.cc"><img title="Facebook" alt="Facebook" src="../images/facebook.png"></a> </div><br><div id="search box"><script>(function() {var cx = 'partner-pub-9750319131714390:3926766884';var gcse = document.createElement('script');gcse.type = 'text/javascript';gcse.async = true;gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(gcse, s);})();</script><gcse:searchbox-only></gcse:searchbox-only></div><br><div class="ad" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 2015 新版型 160 x 600 廣告 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:600px"
     data-ad-client="ca-pub-9750319131714390"
     data-ad-slot="3747048883"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div></li>
            </ul>
        </div>
    </div>

    <main id="main">
        <header class="header">
            <h1>後序式的運算</h1>
        </header>

        <article class="content"><br><div class="ad-3" style="text-align: center;"><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型回應式廣告 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="7104125683" data-ad-format="auto"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div> 
             

說明
將 <a class="wikilink" href="InFixPostfix.htm">中序式轉換為後序式</a>
的好處是，不用處理運算子先後順序問題，只要依序由運算式由前往後讀取即可。 
      
      <h2> 解法</h2>

      


運算時由後序式的前方開始讀取，遇到運算元先存入堆疊，如果遇到運算子，則由堆疊中取出兩個運算元進行對應的運算，然後將結果存回堆疊，如果運算式讀取完
畢，那麼堆疊頂的值就是答案了，例如我們計算12+34+*這個運算式（也就是(1+2)*(3+4)）： 

  
    
      
      <table border="1" width="50%">



  <tbody>



    <tr>




      <td align="left" valign="top">讀取 </td>




      <td align="left" valign="top">堆疊 </td>




    </tr>




    <tr>




      <td align="left" valign="top">1 </td>




      <td align="left" valign="top">1 </td>




    </tr>




    <tr>




      <td align="left" valign="top">2 </td>




      <td align="left" valign="top">1 2 </td>




    </tr>




    <tr>




      <td align="left" valign="top">+ </td>




      <td align="left" valign="top">3 // 1+2 後存回 </td>




    </tr>




    <tr>




      <td align="left" valign="top">3 </td>




      <td align="left" valign="top">3 3 </td>




    </tr>




    <tr>




      <td align="left" valign="top">4 </td>




      <td align="left" valign="top">3 3 4 </td>




    </tr>




    <tr>




      <td align="left" valign="top">+ </td>




      <td align="left" valign="top">3 7 // 3+4 後存回 </td>




    </tr>




    <tr>




      <td align="left" valign="top">* </td>




      <td align="left" valign="top">21 // 3 * 7 後存回</td>



    </tr>



  
  
        
        </tbody>
      
      </table>




      <br>



      
      <h2> 實作：<a href="PostfixCal.htm#C">C</a>&nbsp;&nbsp; &nbsp;<a href="PostfixCal.htm#Java">Java</a>&nbsp;&nbsp; &nbsp;<a href="PostfixCal.htm#Python">Python</a>&nbsp;&nbsp; &nbsp;<a href="PostfixCal.htm#Scala">Scala</a>&nbsp;&nbsp;&nbsp; <a href="PostfixCal.htm#Ruby">Ruby</a>&nbsp;&nbsp;&nbsp; <a href="PostfixCal.htm#JavaScript">JavaScript</a>&nbsp;&nbsp;&nbsp; <a href="PostfixCal.htm#Haskell">Haskell</a><br>
      </h2>
      
      

      
      <ul>

        <li><a name="C"></a> C
  </li>

      
      </ul>




      
      <pre class="prettyprint"><code>#include &lt;stdio.h&gt; <br>#include &lt;stdlib.h&gt; <br><br>#define MAX 80<br><br>void inToPostfix(char*, char*); // 中序轉後序 <br>int priority(char); // 運算子優先<br>double eval(char*); <br>double cal(char, double, double); <br><br>int main(void) { <br>    char infix[MAX] = {'\0'}; <br><br>    printf("運算式："); <br>    scanf("%s", infix); <br>    printf("%f", eval(infix));<br>    <br>    return 0; <br>} <br><br>void inToPostfix(char* infix, char* postfix) { <br>    char stack[MAX] = {'\0'};<br>    int i, j, top;<br>    for(i = 0, j = 0, top = 0; infix[i] != '\0'; i++) switch(infix[i]) { <br>        case '(':              // 運算子堆疊 <br>            stack[++top] = infix[i]; <br>            break; <br>        case '+': case '-': case '*': case '/': <br>            while(priority(stack[top]) &gt;= priority(infix[i])) { <br>                postfix[j++] = stack[top--];<br>            } <br>            stack[++top] = infix[i]; // 存入堆疊 <br>            break; <br>        case ')': <br>            while(stack[top] != '(') { // 遇 ) 輸出至 ( <br>                postfix[j++] = stack[top--];<br>            } <br>            top--;  // 不輸出 ( <br>            break; <br>        default:  // 運算元直接輸出 <br>            postfix[j++] = infix[i];<br>    }<br>    while(top &gt; 0) { <br>        postfix[j++] = stack[top--];<br>    }<br>} <br><br>int priority(char op) { <br>    switch(op) { <br>        case '+': case '-': return 1;<br>        case '*': case '/': return 2;<br>        default:            return 0;<br>    } <br>} <br><br>double eval(char* infix) {<br>    char postfix[MAX]= {'\0'};<br>    char opnd[2] = {'\0'};<br>    double stack[MAX] = {0.0}; <br>    <br>    inToPostfix(infix, postfix);    <br><br>    int top, i;<br>    for(top = 0, i = 0; postfix[i] != '\0'; i++) switch(postfix[i]) { <br>        case '+': case '-': case '*': case '/': <br>            stack[top - 1] = cal(postfix[i], stack[top - 1], stack[top]); <br>            top--; <br>            break; <br>        default: <br>            opnd[0] = postfix[i];<br>            stack[++top] = atof(opnd);<br>    }             <br>    <br>    return stack[top];<br>}<br><br>double cal(char op, double p1, double p2) { <br>    switch(op) { <br>        case '+': return p1 + p2; <br>        case '-': return p1 - p2; <br>        case '*': return p1 * p2; <br>        case '/': return p1 / p2; <br>    } <br>}<br></code></pre>




      <br>




      
      <ul>

        <li><a name="Java"></a> Java
  </li>

      
      </ul>




      
      <pre class="prettyprint"><code>// 使用 <a href="InFixPostfix.htm">中序式轉後序式</a> 中的 Infix<br>import java.util.*;<br><br>public class Calculator {<br>    private static double cal(char op, double p1, double p2) {<br>        switch(op) { <br>            case '+': return p1 + p2; <br>            case '-': return p1 - p2; <br>            case '*': return p1 * p2; <br>            case '/': return p1 / p2;<br>            default:  throw new ArithmeticException(op + " not defined");<br>        }<br>    }<br>    <br>    public static double eval(String expr) {<br>        LinkedList&lt;Double&gt; stack = new LinkedList&lt;&gt;();<br>        for(char c : Infix.toPostfix(expr).toCharArray()) {<br>            if("+-*/".indexOf(c) != -1) {<br>                double p2 = stack.removeLast();<br>                double p1 = stack.removeLast();<br>                stack.add(cal(c, p1, p2));<br>            } else { stack.add(Double.parseDouble(String.valueOf(c))); } <br>        }<br>        return stack.getLast();<br>    }        <br>    <br>    public static void main(String[] args) {<br>        System.out.println(eval(args[0]));<br>    }<br>}</code></pre>



      <br><ul><li><a name="Python"></a>Python</li></ul><pre class="prettyprint"><code># 使用 <a href="InFixPostfix.htm">中序式轉後序式</a> 中的 toPostfix<br>from sys import argv<br>from functools import reduce<br><br>def eval(expr):<br>    def doStack(stack, c):<br>        if c in "+-*/":<br>            return stack[0:-2] + [<br>                {'+': float.__add__,<br>                 '-': float.__sub__,<br>                 '*': float.__mul__,<br>                 '/': float.__floordiv__}[c](stack[-2], stack[-1])]<br>        else:<br>            return stack + [float(c)]<br>            <br>    return reduce(doStack, toPostfix(expr), [])[-1]<br><br>print(eval(argv[1]))</code></pre><br><ul><li><a name="Scala"></a>Scala</li></ul><pre class="prettyprint"><code>// 使用 <a href="InFixPostfix.htm">中序式轉後序式</a> 中的 toPostfix<br>def eval(expr: String) = {<br>    ((Nil:List[Double]) /: Infix.toPostfix(expr)) {<br>        (stack, c) =&gt; {<br>            if("+-*/".contains(c)) {<br>                val op1 = stack.tail.head<br>                val op2 = stack.head<br>                (c match {<br>                    case '+' =&gt; op1 + op2<br>                    case '-' =&gt; op1 - op2<br>                    case '*' =&gt; op1 * op2<br>                    case '/' =&gt; op1 / op2<br>                }) :: stack.tail.tail<br>            } else c.toString.toDouble :: stack<br>        }<br>    }.head<br>}<br><br>println(eval(args(0)))</code></pre><br>
      <ul>
        <li><a name="Ruby"></a>Ruby</li>
      </ul>
      <pre class="prettyprint"><code># 使用 <a href="InFixPostfix.htm">中序式轉後序式</a> 中的 toPostfix<br><br>def eval(expr)<br>    toPostfix(expr).split("").reduce([]) { |stack, c|<br>        if "+-*/".include? c<br>            stack[0...-2] + [stack[-2].send(c, stack[-1])]<br>        else<br>            stack + [c.to_f]<br>        end<br>    } [-1]<br>end<br><br>print(eval(ARGV[0]))<br></code></pre>
      <br>
      <ul>
        <li><a name="JavaScript"></a>JavaScript<br>
        </li>
      </ul>
      <pre class="prettyprint"><code>// 使用 <a href="InFixPostfix.htm">中序式轉後序式</a> 中的 toPostfix<br>function evaluate(expr) {<br>    var stack = [];<br>    toPostfix(expr).split('').forEach(function(c) {<br>        if('+-*/'.indexOf(c) !== -1) {<br>            var p2 = stack.pop();<br>            var p1 = stack.pop();<br>            stack.push(cal(c, p1, p2));<br>        } else {<br>            stack.push(parseInt(c));<br>        }<br>    });<br>    return stack.pop();<br>}<br><br>print(evaluate('(1+2)*(3+4)'));<br></code></pre>
      <br>
      <ul>
        <li><a name="Haskell"></a>Haskell</li>
      </ul>
      <pre class="prettyprint"><code>{- 使用 <a href="InFixPostfix.htm">中序式轉後序式</a> 中的 toPostfix -}<br><br>import qualified Data.Map as Map<br>import System(getArgs)<br><br>eval expr = last $ foldl doStack [] (toPostfix expr)<br>    where<br>        chr2flt c = fromInteger $ read [c]<br>        doStack stack c =<br>            if c `elem` "+-*/" then<br>                let opts = Map.fromList [('+', (+)), ('-', (-)), <br>                                         ('*', (*)), ('/', (/))]<br>                    (Just opt) = Map.lookup c opts<br>                in ((head $ tail stack) `opt` (head stack)) : <br>                   (tail $ tail stack)<br>            else (chr2flt c) : stack<br>            <br>main = do<br>    args &lt;- getArgs<br>    print $ eval $ args !! 0<br></code></pre>
<br>
      




<br><br><div class="ad336-280" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型廣告 336 x 280 --><ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-9750319131714390" data-ad-slot="9976409681"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div><br><div class="recommend" style="text-align: center;"><hr><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 自動大小回應相符內容 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="4953478487" data-ad-format="autorelaxed"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div></article></main></div></body>
<script src="../js/ui.js"></script>
</html>
<div class="analytics"><script async src="https://www.googletagmanager.com/gtag/js?id=G-QVQQYFSC8J"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-QVQQYFSC8J');</script></div>
