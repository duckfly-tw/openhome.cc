<!DOCTYPE html>
<html lang="zh-tw">
  <head><meta http-equiv="refresh" content="0; URL=https://openhome.cc/Gossip/AlgorithmGossip/'https://openhome.cc/zh-tw/algorithm/basics/maze/'">
    <meta content="text/html; charset=utf-8" http-equiv="content-type">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="&nbsp;說明
      老鼠走迷宮是遞迴求解的基本題型，我們在二維陣列中使用2表示迷宮牆壁，使用1來表示老鼠的行走路徑，試以程式求出由入口至出口的路徑。        ...">
    <meta property="og:locale" content="zh_TW">
    <meta property="og:title" content="老鼠走迷宮（一）">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://openhome.cc/Gossip/AlgorithmGossip/MouseGoMaze.htm">
    <meta property="og:image" content="https://openhome.cc/Gossip/images/caterpillar_small.jpg">
    <meta property="og:site_name" content="OPENHOME.CC">
    <meta property="og:description" content="&nbsp;說明
      老鼠走迷宮是遞迴求解的基本題型，我們在二維陣列中使用2表示迷宮牆壁，使用1來表示老鼠的行走路徑，試以程式求出由入口至出口的路徑。        ...">
    <title>老鼠走迷宮（一）</title>
    <link rel="stylesheet" href="../css/pure-0.6.0/pure-min.css">
    <!--[if lte IE 8]>
        <link rel="stylesheet" href="../css/layouts/side-menu-old-ie.css">    <![endif]-->
    <!--[if gt IE 8]><!-->
    <link rel="stylesheet" href="../css/layouts/side-menu.css">
    <!--<![endif]-->
    <link rel="stylesheet" href="../css/caterpillar.css">
    <script async="" src="../google-code-prettify/run_prettify.js"></script>
  <!-- 網頁層級廣告 --><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle =window.adsbygoogle || []).push({google_ad_client: "ca-pub-9750319131714390",enable_page_level_ads: true });</script></head>
  <body>
    <div id="layout">
      <!-- Menu toggle --> <a href="MouseGoMaze.htm#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon --><span></span> </a>
      <div id="menu">
        <div class="pure-menu"> <a class="pure-menu-heading" href="index.html">回
            Algorithm</a>
          <ul class="pure-menu-list">
            <br>
            <div class="social" style="text-align: center;"><a href="http://twitter.com/caterpillar"><img
                  title="Twitter" alt="Twitter" src="../images/twitter.png"></a>
              <a href="http://www.facebook.com/openhome.cc"><img title="Facebook"
                  alt="Facebook" src="../images/facebook.png"></a>
              </div>
            <br>
            <div id="search box">
              <script>(function() {var cx = 'partner-pub-9750319131714390:3926766884';var gcse = document.createElement('script');gcse.type = 'text/javascript';gcse.async = true;gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(gcse, s);})();</script><gcse:searchbox-only></gcse:searchbox-only></div>
            <br>
            <div class="ad" style="text-align: center;">
              <script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
              <!-- 2015 新版型 160 x 600 廣告 --> <ins class="adsbygoogle" style="display:inline-block;width:160px;height:600px"
                data-ad-client="ca-pub-9750319131714390" data-ad-slot="3747048883"></ins>
              <script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div>
          </ul>
        </div>
      </div>
      <main id="main">
        <header class="header">
          <h1>老鼠走迷宮（一）</h1>
        </header>
        <article class="content"><br>
          <div class="ad-3" style="text-align: center;">
            <script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型回應式廣告 --><ins
              class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390"
              data-ad-slot="7104125683" data-ad-format="auto"></ins>
            <script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>
          <h2>&nbsp;說明</h2>
          老鼠走迷宮是遞迴求解的基本題型，我們在二維陣列中使用2表示迷宮牆壁，使用1來表示老鼠的行走路徑，試以程式求出由入口至出口的路徑。<br>
          <h2>解法</h2>
          老鼠的走法有上、左、下、右四個方向，在每前進一格之後就選一個方向前進，無法前進時退回選擇下一個可前進方向，如此在陣列中依序測試四個方向，直到
          走到出口為止，這是遞迴的基本題，請直接看程式應就可以理解。 <br>
          <br>
          <h2> 演算法</h2>
          <pre class="prettyprint"><code>Procedure GO(maze[])<br>    VISIT(maze, START_I, START_J, END_I, END_J)<br>    <br>Procedure VISIT(maze[], i, j, end_i, end_j)<br>    IF maze[i][j] == 0<br>        maze[i][j] = 1<br>        IF maze[end_i][end_j] == 0<br>           IF !(VISIT(maze, i, j + 1, end_i, end_j) OR <br>                VISIT(maze, i + 1, j, end_i, end_j) OR<br>                VISIT(maze, i, j - 1, end_i, end_j) OR <br>                VISIT(maze, i - 1, j, end_i, end_j))<br>               maze[i][j] = 0<br>    RETURN maze[end_i][end_j] == 1<br></code></pre>
          <h2> 實作：<a href="MouseGoMaze.htm#Toy">Toy</a>&nbsp;&nbsp; &nbsp;<a href="MouseGoMaze.htm#C">C</a>&nbsp;&nbsp; &nbsp;<a href="MouseGoMaze.htm#Java">Java</a>&nbsp;&nbsp;
            &nbsp;<a href="MouseGoMaze.htm#Python">Python</a>&nbsp;&nbsp; &nbsp;<a href="MouseGoMaze.htm#Scala">Scala</a>&nbsp;&nbsp;&nbsp;
            <a href="MouseGoMaze.htm#Ruby">Ruby</a>&nbsp;&nbsp;&nbsp; <a href="MouseGoMaze.htm#JavaScript">JavaScript</a>&nbsp;&nbsp;&nbsp;
            <a href="MouseGoMaze.htm#Haskell">Haskell</a>&nbsp;&nbsp;&nbsp; <a href="MouseGoMaze.htm#Prolog">Prolog</a><br>
          </h2>
          <ul>
            <li><a name="Toy"><a href="../Toy/index.html">Toy</a></a> </li>
          </ul>
          <pre class="prettyprint"><code>def pt(x, y) {
    return new Object([['x', x], ['y', y]])
}

class Maze {
    def init(raw) {
        this.raw = raw
    }
 
    def get(x, y) {
        return this.raw.get(x).get(y)
    }

    def set(x, y, v) {
        this.raw.get(x).set(y, v)
    }

    def visit(st, ed) {
        if not this.get(st.x, st.y) {
            this.set(st.x, st.y, 1)
            if not this.get(ed.x, ed.y) and not this.tryOneOut(st, ed) {
                this.set(st.x, st.y, 0)
            }
        }
        return this.get(ed.x, ed.y)
    }
    
    def tryOneOut(st, ed) {
        (return this.visit(pt(st.x, st.y + 1), ed) or 
                this.visit(pt(st.x + 1, st.y), ed) or 
                this.visit(pt(st.x, st.y - 1), ed) or 
                this.visit(pt(st.x - 1, st.y), ed))

    }

    def printSymbol(i, j) {
        switch this.get(i, j) {
            case 0 
                print('  ')
            case 1
                print('++')
            case 2
                print('██') 
        }
    }

    def printRow(i) {
        (iterate(0, this.raw.get(i).length())
              .forEach(j -> this.printSymbol(i, j)))
        println()
    }

    def print() {
        iterate(0, this.raw.length()).forEach(this.printRow)
    }
}

(maze = new Maze([
    [2, 2, 2, 2, 2, 2, 2],
    [2, 0, 0, 0, 0, 0, 2],
    [2, 0, 2, 0, 2, 0, 2],
    [2, 0, 0, 2, 0, 2, 2],
    [2, 2, 0, 2, 0, 2, 2],
    [2, 0, 0, 0, 0, 0, 2],
    [2, 2, 2, 2, 2, 2, 2]
]))

if not maze.visit(pt(1, 1), pt(5, 5)) {
    println('沒有找到出口！')
}

maze.print()</code></pre>
          <br>
          <ul>
            <li><a name="C"> C</a> </li>
          </ul>
          <pre class="prettyprint"><code>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#define SIZE 7<br><br>typedef struct {<br>    int x; <br>    int y;<br>} Point;<br><br>Point pt(int, int);<br>int visit(int[][SIZE], Point, Point);<br>void print(int[][SIZE]);<br><br>int main(void) { <br>    int maze[SIZE][SIZE] = {{2, 2, 2, 2, 2, 2, 2}, <br>                            {2, 0, 0, 0, 0, 0, 2}, <br>                            {2, 0, 2, 0, 2, 0, 2}, <br>                            {2, 0, 0, 2, 0, 2, 2}, <br>                            {2, 2, 0, 2, 0, 2, 2}, <br>                            {2, 0, 0, 0, 0, 0, 2}, <br>                            {2, 2, 2, 2, 2, 2, 2}}; <br><br>    if(!visit(maze, pt(1, 1), pt(5, 5))) {<br>        printf("\n沒有找到出口！\n"); <br>    }<br>    print(maze);<br>    <br>    return 0; <br>}<br><br>Point pt(int x, int y) {<br>    Point p = {x, y};<br>    return p;<br>}<br><br>int visit(int maze[][SIZE], Point start, Point end) {<br>    if(!maze[start.x][start.y]) {<br>         maze[start.x][start.y] = 1;<br>         if(!maze[end.x][end.y] &amp;&amp; <br>            !(visit(maze, pt(start.x, start.y + 1), end) || <br>              visit(maze, pt(start.x + 1, start.y), end) ||<br>              visit(maze, pt(start.x, start.y - 1), end) || <br>              visit(maze, pt(start.x - 1, start.y), end))) {<br>                 maze[start.x][start.y] = 0;<br>         }<br>    }<br>    return maze[end.x][end.y];<br>    <br>}<br><br>void print(int maze[][SIZE]) {<br>    int i, j;<br>    for(i = 0; i &lt; SIZE; i++) { <br>        for(j = 0; j &lt; SIZE; j++) switch(maze[i][j]) {<br>            case 0 : printf("  "); break;<br>            case 1 : printf("◇"); break;<br>            case 2 : printf("█"); <br>        }<br>        printf("\n"); <br>    }     <br>}<br></code></pre>
          <br>
          <ul>
            <li><a name="Java">Java</a>  </li>
          </ul>
          <pre class="prettyprint"><code>import static java.lang.System.out;<br><br>class Point {<br>    final int x;<br>    final int y;<br>    Point(int x, int y) {<br>        this.x = x;<br>        this.y = y;<br>    }<br>}<br><br>public class Mouse {<br>    public static int[][] go(int[][] maze, Point start, Point end) {<br>        visit(maze, start, end);<br>        return maze;<br>    }<br>    <br>    public static boolean visit(int[][] maze, Point pt, Point end) {<br>        if(isVisitable(maze, pt)) {<br>            maze[pt.x][pt.y] = 1;<br>            if(!isEnd(maze, end) &amp;&amp; !tryOneOut(maze, pt, end)) {<br>                maze[pt.x][pt.y] = 0;<br>            }<br>        }<br>        return isEnd(maze, end);<br>    }<br><br>    public static boolean isVisitable(int[][] maze, Point pt) {<br>        return maze[pt.x][pt.y] == 0;<br>    }<br>    <br>    public static boolean isEnd(int[][] maze, Point end) {<br>        return maze[end.x][end.y] == 1;<br>    }<br>    <br>    public static boolean tryOneOut(int[][] maze, Point pt, Point end) {<br>        return visit(maze, new Point(pt.x, pt.y + 1), end) ||<br>               visit(maze, new Point(pt.x + 1, pt.y), end) ||<br>               visit(maze, new Point(pt.x, pt.y - 1), end) ||<br>               visit(maze, new Point(pt.x - 1, pt.y), end);<br>    }<br>    <br>    public static void main(String[] args) {<br>        int[][] maze = new int[][]{{2, 2, 2, 2, 2, 2, 2}, <br>                                   {2, 0, 0, 0, 0, 0, 2}, <br>                                   {2, 0, 2, 0, 2, 0, 2}, <br>                                   {2, 0, 0, 2, 0, 2, 2}, <br>                                   {2, 2, 0, 2, 0, 2, 2}, <br>                                   {2, 0, 0, 0, 0, 0, 2}, <br>                                   {2, 2, 2, 2, 2, 2, 2}};<br>                                   <br>        for(int[] row : Mouse.go(maze, new Point(1, 1), new Point(5, 5))) {<br>            for(int block : row) switch(block) {<br>                case 0: out.print("  "); break;<br>                case 1: out.print("◇"); break;<br>                case 2: out.print("█");<br>            }<br>            out.println();<br>        }<br>        out.println(Mouse.isEnd(maze, new Point(5, 5)) <br>                    ? "找到出口" : "沒有找到出口！");<br>    }<br>} <br></code></pre>
          <br>
          <ul>
            <li><a name="Python">Python</a></li>
          </ul>
          <pre class="prettyprint"><code>class Mouse:<br>    @staticmethod<br>    def go(maze, start, end):<br>        route = []<br>        Mouse.visit(maze, start, end, route)<br>        return route<br>    <br>    @staticmethod<br>    def visit(maze, pt, end, route):<br>        if Mouse.isVisitable(maze, pt, route):<br>            route.append(pt)<br>            if not Mouse.isEnd(route, end) and \<br>               not Mouse.tryOneOut(maze, pt, end, route):<br>                route.pop()<br>        return Mouse.isEnd(route, end)<br>    <br>    @staticmethod<br>    def isVisitable(maze, pt, route):<br>        return maze[pt[0]][pt[1]] == 0 and pt not in route<br>        <br>    @staticmethod<br>    def isEnd(route, end):<br>        return end in route<br>        <br>    @staticmethod<br>    def tryOneOut(maze, pt, end, route):<br>        return Mouse.visit(maze, (pt[0], pt[1] + 1), end, route) or \<br>               Mouse.visit(maze, (pt[0] + 1, pt[1]), end, route) or \<br>               Mouse.visit(maze, (pt[0], pt[1] - 1), end, route) or \<br>               Mouse.visit(maze, (pt[0] - 1, pt[1]), end, route)<br>               <br>maze = [[2, 2, 2, 2, 2, 2, 2],<br>        [2, 0, 0, 0, 0, 0, 2],<br>        [2, 0, 2, 0, 2, 0, 2],<br>        [2, 0, 0, 2, 0, 2, 2],<br>        [2, 2, 0, 2, 0, 2, 2],<br>        [2, 0, 0, 0, 0, 0, 2],<br>        [2, 2, 2, 2, 2, 2, 2]]<br>        <br>for pt in Mouse.go(maze, (1, 1), (5, 5)):<br>    maze[pt[0]][pt[1]] = 1<br><br>if maze[5][5] == 0:<br>    print("找不到出口")<br><br>for row in maze:<br>    for block in row:<br>        {<br>            0 : lambda: print("  ", end=""),<br>            1 : lambda: print("◇", end=""),<br>            2 : lambda: print("█",end=""),<br>        }[block]()<br>    print()</code></pre>
          <br>
          <ul>
            <li><a name="Scala">Scala</a></li>
          </ul>
          <pre class="prettyprint"><code>case class Point(x: Int, y: Int)<br><br>object Mouse {<br>    def go(maze: List[List[Int]], start: Point, end: Point) = {<br>        visit(maze, start, end, Nil)<br>    }<br>    <br>    def visit(maze: List[List[Int]], pt: Point, <br>              end: Point, route: List[Point]): List[Point] = {<br>        if(isVisitable(maze, pt, route)) {<br>            if(isEnd(pt, end)) end::route <br>            else tryOneOut(maze, pt, end, pt::route)<br>        } else Nil<br>    }<br>    <br>    def isVisitable(maze: List[List[Int]], pt: Point, route: List[Point]) = {<br>        maze(pt.x)(pt.y) == 0 &amp;&amp; !route.contains(pt)<br>    }<br>    <br>    def isEnd(pt: Point, end: Point) = pt == end<br>    <br>    def tryOneOut(maze: List[List[Int]], pt: Point, <br>                  end: Point, route: List[Point]) = {<br>        or(visit(maze, Point(pt.x, pt.y + 1), end, route)) { <br>            or(visit(maze, Point(pt.x + 1, pt.y), end, route)) {<br>                or(visit(maze, Point(pt.x, pt.y - 1), end, route)) {<br>                    visit(maze, Point(pt.x - 1, pt.y), end, route)<br>                }<br>            }<br>        }<br>    }<br>    <br>    def or(expr1: =&gt; List[Point])(expr2: =&gt; List[Point]) = {<br>        val route = expr1<br>        if(route == Nil) expr2 else route    <br>    }<br>}<br><br>val maze = List(<br>               List(2, 2, 2, 2, 2, 2, 2), <br>               List(2, 0, 0, 0, 0, 0, 2), <br>               List(2, 0, 2, 0, 2, 0, 2), <br>               List(2, 0, 0, 2, 0, 2, 2), <br>               List(2, 2, 0, 2, 0, 2, 2), <br>               List(2, 0, 0, 0, 0, 0, 2), <br>               List(2, 2, 2, 2, 2, 2, 2)<br>           )<br><br>val route = Mouse.go(maze, Point(1, 1), Point(5, 5))<br><br>if(!route.contains(Point(5, 5))) {<br>    println("找不到出口")<br>}<br><br>for(i &lt;- 0 until maze.length) {<br>    for(j &lt;- 0 until maze(i).length) {<br>        if(route.contains(Point(i, j))) {<br>            print("◇")<br>        } else {<br>            maze(i)(j) match {<br>                case 0 =&gt; print("  ")<br>                case 2 =&gt; print("█")<br>            }<br>        }<br>    }<br>    println()<br>}<br></code></pre>
          <br>
          <ul>
            <li><a name="Ruby">Ruby</a></li>
          </ul>
          <pre class="prettyprint"><code>#encoding: Big5<br>class Mouse<br>    def self.go(maze, start, goal)<br>        route = []<br>        visit(maze, start, goal, route)<br>        route<br>    end<br>    <br>    def self.visit(maze, pt, goal, route)<br>        if isVisitable(maze, pt, route)<br>            route &lt;&lt; pt<br>            if not isGoal(route, goal) and <br>               not tryOneOut(maze, pt, goal, route)<br>                route.pop<br>            end<br>        end<br>        isGoal(route, goal)<br>    end<br>    <br>    def self.isVisitable(maze, pt, route)<br>        maze[pt[:x]][pt[:y]] == 0 and not route.include? pt<br>    end<br>   <br>    def self.isGoal(route, goal)<br>        route.include? goal<br>    end<br>    <br>    def self.tryOneOut(maze, pt, goal, route)<br>        visit(maze, {x: pt[:x], y: pt[:y] + 1}, goal, route) or<br>        visit(maze, {x: pt[:x] + 1, y: pt[:y]}, goal, route) or<br>        visit(maze, {x: pt[:x], y: pt[:y] - 1}, goal, route) or<br>        visit(maze, {x: pt[:x] - 1, y: pt[:y]}, goal, route)<br>    end<br>end<br><br>maze = [<br>          [2, 2, 2, 2, 2, 2, 2],<br>          [2, 0, 0, 0, 0, 0, 2],<br>          [2, 0, 2, 0, 2, 0, 2],<br>          [2, 0, 0, 2, 0, 2, 2],<br>          [2, 2, 0, 2, 0, 2, 2],<br>          [2, 0, 0, 0, 0, 0, 2],<br>          [2, 2, 2, 2, 2, 2, 2]<br>       ]<br>       <br>Mouse.go(maze, {x: 1, y: 1}, {x: 5, y: 5}).each do |pt|<br>    maze[pt[:x]][pt[:y]] = 1<br>end<br><br>if maze[5][5] == 0<br>    puts "找不到出口"<br>end<br><br>maze.each do |row|<br>    row.each do |block|<br>        case block<br>            when 0 then print "  "<br>            when 1 then print "◇"<br>            when 2 then print "█"<br>        end<br>    end<br>    puts<br>end<br></code></pre>
          <br>
          <ul>
            <li><a name="JavaScript">JavaScript</a></li>
          </ul>
          <pre class="prettyprint"><code>var mouse = function() {<br><br>    function visit(maze, pt, end) {<br>        if(isVisitable(maze, pt)) {<br>            maze[pt.x][pt.y] = 1;<br>            if(!isEnd(maze, end) &amp;&amp; !tryOneOut(maze, pt, end)) {<br>                maze[pt.x][pt.y] = 0;<br>            }<br>        }<br>        return isEnd(maze, end);<br>    }<br>    <br>    function isVisitable(maze, pt) {<br>        return maze[pt.x][pt.y] === 0;<br>    }<br>    <br>    function isEnd(maze, end) {<br>        return maze[end.x][end.y] === 1;<br>    }<br>    <br>    function tryOneOut(maze, pt, end) {<br>        return visit(maze, {x: pt.x, y: pt.y + 1}, end) ||<br>               visit(maze, {x: pt.x + 1, y: pt.y}, end) ||<br>               visit(maze, {x: pt.x, y: pt.y - 1}, end) ||<br>               visit(maze, {x: pt.x - 1, y: pt.y}, end);<br>    }<br>    <br>    return function(maze, start, end) {<br>        visit(maze, start, end);<br>        return maze;<br>    };<br>    <br>}();<br><br>var maze = mouse([[2, 2, 2, 2, 2, 2, 2],<br>                  [2, 0, 0, 0, 0, 0, 2],<br>                  [2, 0, 2, 0, 2, 0, 2],<br>                  [2, 0, 0, 2, 0, 2, 2],<br>                  [2, 2, 0, 2, 0, 2, 2],<br>                  [2, 0, 0, 0, 0, 0, 2],<br>                  [2, 2, 2, 2, 2, 2, 2]],<br>                  {x: 1, y: 1}, {x: 5, y: 5});<br><br>var layout = '';<br>maze.forEach(function(row) {<br>    row.forEach(function(block) {<br>        switch(block) {<br>            case 0: layout += '  '; break;<br>            case 1: layout += '◇'; break;<br>            case 2: layout += '█';<br>        }<br>    });<br>    layout += '\n';<br>});<br>print(layout);<br></code></pre>
          <br>
          <ul>
            <li><a name="Haskell">Haskell</a></li>
          </ul>
          <pre class="prettyprint"><code>mouse maze start end = visit maze start end []<br>    where visit maze pt end route = if isVisitable maze pt route then <br>                                        if isEnd pt end then end:route <br>                                        else tryOneOut maze pt end (pt:route)<br>                                    else []<br>                                    <br>          isVisitable maze pt route = <br>              maze !! fst pt !! snd pt == 0 &amp;&amp; not (pt `elem` route)<br>              <br>          isEnd pt end = pt == end<br>          <br>          tryOneOut maze pt end route = <br>              visit maze (fst pt, snd pt + 1) end route `or'`<br>              visit maze (fst pt + 1, snd pt) end route `or'`<br>              visit maze (fst pt, snd pt - 1) end route `or'`<br>              visit maze (fst pt - 1, snd pt) end route<br>              <br>          or' expr1 expr2 = if route == [] then expr2 else route<br>              where route = expr1<br>    <br>main = sequence [putStrLn row | row &lt;- toSymbol maze \$ mouse maze start end]<br>    where maze = [<br>              [2, 2, 2, 2, 2, 2, 2],<br>              [2, 0, 0, 0, 0, 0, 2],<br>              [2, 0, 2, 0, 2, 0, 2],<br>              [2, 0, 0, 2, 0, 2, 2],<br>              [2, 2, 0, 2, 0, 2, 2],<br>              [2, 0, 0, 0, 0, 0, 2],<br>              [2, 2, 2, 2, 2, 2, 2]]<br><br>          start = (1, 1)<br>          end = (5, 5)<br><br>          width = length maze<br>          height = length \$ maze !! 0<br><br>          toSymbol maze route = [[if (i, j) `elem` route then 'M' <br>                                  else case (maze !! i !! j) of <br>                                           0 -&gt; ' '<br>                                           2 -&gt; 'X' | j &lt;- [0..height - 1]<br>                                 ] | i &lt;- [0..width - 1]]<br></code></pre>
          <br>
          <ul>
            <li> <a id="Prolog">Prolog</a></li>
          </ul>
          <p> </p>
          <pre class="prettyprint"><code>contains(Pt, [Pt|_]).
contains(Pt, [_|T]) :- contains(Pt, T).

elem(Maze, [Px, Py], N) :- 
    nth0(Py, Maze, Row), nth0(Px, Row, N).

visitable(Maze, Route, Pt) :- 
    elem(Maze, Pt, 0), not(contains(Pt, Route)).

finish(Pt, Pt, Route, [Pt|Route]).

workaround(Maze, End, Route, Pt, Solution) :- 
    down(Maze, End, Route, Pt, Solution); 
    right(Maze, End, Route, Pt, Solution);
    up(Maze, End, Route, Pt, Solution); 
    left(Maze, End, Route, Pt, Solution).

down(Maze, End, Route, [Px, Py], Solution) :- 
    Npy is Py + 1, 
    find(Maze, End, Route, [Px, Npy], Solution).
    
right(Maze, End, Route, [Px, Py], Solution) :- 
    Npx is Px + 1, 
    find(Maze, End, Route, [Npx, Py], Solution).
    
up(Maze, End, Route, [Px, Py], Solution) :- 
    Npy is Py - 1, 
    find(Maze, End, Route, [Px, Npy], Solution).
    
left(Maze, End, Route, [Px, Py], Solution) :- 
    Npx is Px - 1,
    find(Maze, End, Route, [Npx, Py], Solution).

tryMore(Maze, End, Route, Pt, Solution) :- 
    workaround(Maze, End, [Pt|Route], Pt, Solution).

finish_or_tryMore(Maze, End, Route, Pt, Solution) :- 
    finish(End, Pt, Route, Solution); tryMore(Maze, End, Route, Pt, Solution).

find(Maze, End, Route, Pt, Solution) :- 
    visitable(Maze, Route, Pt), finish_or_tryMore(Maze, End, Route, Pt, Solution).

printMaze(_, X, Y, Solution) :- contains([X, Y], Solution), write("◇").
printMaze(0, _, _, _) :- write("  ").
printMaze(2, _, _, _) :- write("█").

printNext(T, Solution, X, Y) :- NX is X + 1, printRow(T, Solution, NX, Y).

printRow([], _, _, _) :- nl.
printRow([H|T], Solution, X, Y) :- printMaze(H, X, Y, Solution), printNext(T, Solution, X, Y).
    
printIt([Row|Rows], Solution, Y) :-
    printRow(Row, Solution, 0, Y), NY is Y + 1, printIt(Rows, Solution, NY).
    
printIt([], _, _) :- nl.

main(_) :-
    Maze = [
            [2, 2, 2, 2, 2, 2, 2],
            [2, 0, 0, 0, 0, 0, 2],
            [2, 0, 2, 0, 2, 0, 2],
            [2, 0, 0, 2, 0, 2, 2],
            [2, 2, 0, 2, 0, 2, 2],
            [2, 0, 0, 0, 0, 0, 2],
            [2, 2, 2, 2, 2, 2, 2]
         ],
    find(Maze,
         [5, 5],
         [],
         [1, 1],
         Solution
    ), 
    printIt(Maze, Solution, 0).<br></code></pre>
          <br>
          <br>
          <div class="ad336-280" style="text-align: center;">
            <script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型廣告 336 x 280 --><ins
              class="adsbygoogle" style="display:inline-block;width:336px;height:280px"
              data-ad-client="ca-pub-9750319131714390" data-ad-slot="9976409681"></ins>
            <script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>
          <br>
          <div class="recommend" style="text-align: center;">
            <hr>
            <script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 自動大小回應相符內容 --><ins
              class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390"
              data-ad-slot="4953478487" data-ad-format="autorelaxed"></ins>
            <script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>
        </article>
      </main>
    </div></body>
    <script src="../js/ui.js"></script>
    <div class="analytics"><script async src="https://www.googletagmanager.com/gtag/js?id=G-QVQQYFSC8J"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-QVQQYFSC8J');</script></div>
</html>
