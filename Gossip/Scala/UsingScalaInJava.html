<!doctype html><html lang="zh-tw">
<head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="若
是在JVM平台上，Scala的類別會編譯為.class檔案，基本上在Java程式中，也可以使用這些編譯好的.class檔，不過由於某些Scala
的語法特性，在Java中並不存在，因此若要在J...">

<meta property="og:locale" content="zh_TW">
<meta property="og:title" content="在 Java 中使用 Scala 類別">
<meta property="og:type" content="article">
<meta property="og:url" content="https://openhome.cc/Gossip/Scala/UsingScalaInJava.html">
<meta property="og:image" content="https://openhome.cc/Gossip/images/caterpillar_small.jpg">
<meta property="og:site_name" content="OPENHOME.CC">
<meta property="og:description" content="若
是在JVM平台上，Scala的類別會編譯為.class檔案，基本上在Java程式中，也可以使用這些編譯好的.class檔，不過由於某些Scala
的語法特性，在Java中並不存在，因此若要在J...">


    <title>在 Java 中使用 Scala 類別</title>

<link rel="stylesheet" href="../css/pure-0.6.0/pure-min.css">

    <!--[if lte IE 8]>
        <link rel="stylesheet" href="../css/layouts/side-menu-old-ie.css">
    <![endif]-->
    <!--[if gt IE 8]><!-->
        <link rel="stylesheet" href="../css/layouts/side-menu.css">
    <!--<![endif]-->
  

     <link rel="stylesheet" href="../css/caterpillar.css">
     <script async src="../google-code-prettify/run_prettify.js"></script>
<!-- 網頁層級廣告 --><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle =window.adsbygoogle || []).push({google_ad_client: "ca-pub-9750319131714390",enable_page_level_ads: true });</script></head>
<body>

<div id="layout">
    <!-- Menu toggle -->
    <a href="UsingScalaInJava.html#menu" id="menuLink" class="menu-link">
        <!-- Hamburger icon --><span></span>
        
    </a>
    <div id="menu">
        <div class="pure-menu">
            <a class="pure-menu-heading" href="https://openhome.cc/Gossip/Scala/">回 Scala 目錄</a>
            <ul class="pure-menu-list">
                <br><div class="social" style="text-align: center;"><a href="http://twitter.com/caterpillar"><img title="Twitter" alt="Twitter" src="../images/twitter.png"></a> <a href="http://www.facebook.com/openhome.cc"><img title="Facebook" alt="Facebook" src="../images/facebook.png"></a> </div><br><div id="search box"><script>(function() {var cx = 'partner-pub-9750319131714390:3926766884';var gcse = document.createElement('script');gcse.type = 'text/javascript';gcse.async = true;gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//www.google.com/cse/cse.js?cx=' + cx;var s = document.getElementsByTagName('script')[0];s.parentNode.insertBefore(gcse, s);})();</script><gcse:searchbox-only></gcse:searchbox-only></div><br><div class="ad" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<!-- 2015 新版型 160 x 600 廣告 -->
<ins class="adsbygoogle"
     style="display:inline-block;width:160px;height:600px"
     data-ad-client="ca-pub-9750319131714390"
     data-ad-slot="3747048883"></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script></div></li>
            </ul>
        </div>
    </div>

    <main id="main">
        <header class="header">
            <h1>在 Java 中使用 Scala 類別</h1>
        </header>

        <article class="content"><br><div class="ad-3" style="text-align: center;"><script async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型回應式廣告 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="7104125683" data-ad-format="auto"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div> 
            若
是在JVM平台上，Scala的類別會編譯為.class檔案，基本上在Java程式中，也可以使用這些編譯好的.class檔，不過由於某些Scala
的語法特性，在Java中並不存在，因此若要在Java程式中使用Scala所編譯好的類別，就必須注意一些語法或名稱對應的方式。<br><br>當你在Scala中定義一個類別：<br><pre class="prettyprint"><code lang="scala">class Some</code></pre><br>使用scalac編譯後會產生Some.class檔案，若你想要在Java中使用這個Some類別：<br><pre class="prettyprint"><code lang="scala">public class Main {  // 這是 Java<br>    public static void main(String[] args) {<br>        Some s = new Some();<br>    }<br>}</code></pre><br>你可以編譯Main.java，但在執行時若沒有指定Classpath中包括scala-library.jar的位置，就會出現錯誤：<br><div class="cmd"><span style="color: rgb(255, 255, 255);">&gt;javac Main.java<br><br>&gt;java Main<br>Exception in thread "main" java.lang.NoClassDefFoundError: scala/ScalaObject<br>....</span></div><br>這是因為，Scala中的自定義類別，會實作scala.ScalaObject特徵，也就是編譯出來的.class，其實相當於：<br><div style="margin-left: 40px;"><span style="font-weight: bold;">import java.rmi.RemoteException;</span><br><span style="font-weight: bold;">import scala.ScalaObject;</span><br><span style="font-weight: bold;"></span><br><span style="font-weight: bold;">public class Some</span><span style="font-weight: bold;"> <span style="color: red;">implements ScalaObject</span></span><span style="font-weight: bold;"> {</span><br><span style="font-weight: bold;">&nbsp; public int \$tag()</span><span style="font-weight: bold;"> throws RemoteException</span><span style="font-weight: bold;"> {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; return ScalaObject.class.\$tag(this);</span><br><span style="font-weight: bold;">&nbsp; }</span><br><span style="font-weight: bold;">}</span><br></div><br>若要能順利執行，則必須指定Classpath包括scala-library.jar的位置：<br><div class="cmd"><span style="color: rgb(255, 255, 255);">&gt;java -cp .;%SCALA_HOME%/lib/scala-library.jar Main<br></span></div><br>在定義類別時，使用val宣告的變數，對應至Java使用final修飾的變數。如果是類別的資料成員，無論是使用val宣告或var宣告的變數，一律對應至private資料成員，在Scala中提供的權限修飾，對應至相對應的存取方法權限。例如：<br><pre class="prettyprint"><code lang="scala">class Some {<br>    private var m = 123<br>    private val s = "XD"<br>}</code></pre><br>編譯過後的.class會是：<br><div style="margin-left: 40px;"><span style="font-weight: bold;">import java.rmi.RemoteException;</span><br><span style="font-weight: bold;">import scala.ScalaObject;</span><br><br><span style="font-weight: bold;">public class Some implements ScalaObject {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; private int m;</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; private final String s = "XD"</span><br><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; public Some() {</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; super();<br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; m = 123;</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; }</span><br><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; private void m_\$eq(int x\$1) { m = x\$1; }</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; private int m() { return m; }</span><br><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; private String s() { return s; }</span><br><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; public int \$tag() throws RemoteException {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return scala.ScalaObject.class.\$tag(this);</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; }</span><br><span style="font-weight: bold;">}</span><br></div><br>所以，如果是這個類別：<br><pre class="prettyprint"><code lang="scala">class Some {<br>    val s = "XD"<br>}</code></pre><br>在Java中要取得s的值，則必須呼叫方法，例如：<br><pre class="prettyprint"><code lang="scala">public class Main { // 這是 Java<br>    public static void main(String[] args) {<br>        Some some = new Some();<br>        System.out.println(some.s());<br>    }<br>}</code></pre><br>如果你希望編譯過後的類別具有設值方法（Setter）與取值方法（Getter），則可以使用 @BeanProperty 標註，請參考 <a href="Annotation.html">標註（Annotation）</a> 的內容。<br><br>在Scala中所有東西都是物件，就算是1、0.1等數值也是物件，而在編譯為.class之後，為了效率，會儘量將數值轉為Java的基本資料型態，而在必要的地方使用Integer等包裹類別（Wrapper）。例如：<br><pre class="prettyprint"><code lang="scala">class Some {<br>    def doIt(a: Int): Int = {<br>        val l = new java.util.ArrayList[Int]<br>        l.add(a)<br>        return l.get(0)<br>    }<br>}</code></pre><br>這個類別在編譯為.class之後，相當於：<br><div style="margin-left: 40px;">import java.rmi.RemoteException;<br>import java.util.ArrayList;<br>import scala.ScalaObject;<br>import scala.runtime.BoxesRunTime;<br><br>public class Some&nbsp;implements ScalaObject {<br>&nbsp; public <span style="color: red;">int</span> doIt(<span style="color: red;">int</span> a)&nbsp; {<br>&nbsp;&nbsp;&nbsp; ArrayList l = new ArrayList();<br>&nbsp;&nbsp;&nbsp; l.add(<span style="color: red;">BoxesRunTime.boxToInteger(a)</span>);<br>&nbsp;&nbsp;&nbsp; return <span style="color: red;">BoxesRunTime.unboxToInt(l.get(0))</span>;<br>&nbsp; }<br><br>&nbsp; public int \$tag()&nbsp; throws RemoteException {<br>&nbsp;&nbsp;&nbsp; return ScalaObject.class.\$tag(this);<br>&nbsp; }<br>}<br></div><br>在
參數與傳回值的型態部份轉為int，而必要的地方使用裝箱（Boxing）與拆箱（Unboxing）。在Scala中如果設定參數型態或傳回值型態為
Any、AnyRef或AnyVal，編譯.class後，都對應於java.lang.Object。如果傳回值設定為AnyVal，則傳回的數值會裝
箱，例如：<br><pre class="prettyprint"><code lang="scala">class Some {<br>    def doSomething(a: AnyVal): AnyVal = 1<br>}</code></pre><br>這個類別在編譯過後，.class的定義基本上如下：<br><div style="margin-left: 40px;"><span style="font-weight: bold;">import java.rmi.RemoteException;</span><br><span style="font-weight: bold;">import scala.ScalaObject;</span><br><span style="font-weight: bold;">import scala.runtime.BoxesRunTime;</span><br><br><span style="font-weight: bold;">public class Some implements ScalaObject {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; public Some() {}</span><br><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; public <span style="color: red;">Object</span> doSomething(<span style="color: red;">Object</span> a) {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return <span style="color: red;">BoxesRunTime.boxToInteger(1)</span>;</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; }</span><br><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; public int \$tag() throws RemoteException {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return scala.ScalaObject.class.\$tag(this);</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; }</span><br><span style="font-weight: bold;">}</span><br></div><br>Scala的 <a href="SingletonObject.html">單
例物件</a> 在Java中，可以使用存取靜態成員的方式來使用，例如：<br><pre class="prettyprint"><code lang="scala">object Some {<br>    def doSomething = "XD"<br>}</code></pre><br>在Java中可以這麼使用：<br><pre class="prettyprint"><code lang="scala">public class Main {  // 這是 Java<br>    public static void main(String[] args) {<br>        System.out.println(Some.doSomething()); // XD<br>    }<br>}</code></pre><br>不過別誤以為單例物件轉換為Java之後，單例物件的名稱就是類別名稱，其中的成員直接就是實作為靜態成員！不然會誤入這個陷阱：<br><pre class="prettyprint"><code lang="scala">class Some<br><br>object Some {<br>    def doSomething = "XD"<br>}</code></pre><br>上面定義了伴侶類別與伴侶物件，在編譯過後，在Java中這麼使用是會有錯的：<br><pre class="prettyprint"><code lang="scala">public class Main {  // 這是 Java<br>    public static void main(String[] args) {<br>        System.out.println(Some.doSomething()); // 編譯錯誤<br>    }<br>}</code></pre><br>其實，只要是Scala中使用object定義的物件，在轉換為.class後，其實真正的類別名稱是「單例物件名\$」，該類別中會有個MODULE\$成員參考到this，例如上面的例子會產生Some\$類別，其定義為：<br><div style="margin-left: 40px;"><span style="font-weight: bold;">import java.rmi.RemoteException;</span><br><span style="font-weight: bold;">import scala.ScalaObject;</span><br><br><span style="font-weight: bold;">public final class <span style="color: red;">Some\$</span> implements ScalaObject {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; public Some\$() {}</span><br><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; public String doSomething() {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return "XD";</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; }</span><br><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; public int \$tag() throws RemoteException {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return scala.ScalaObject.class.\$tag(this);</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; }</span><br><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; public static final Some\$ MODULE\$ = this;</span><br><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; static {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; new Some\$();</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; }</span><br><span style="font-weight: bold;">}</span><br></div><br>在沒有伴侶類別的情況下，編譯會產生一個Some類別定義如下：<br><div style="margin-left: 40px;"><span style="font-weight: bold;">import java.rmi.RemoteException;</span><br><br><span style="font-weight: bold;">public final class Some {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; <span style="color: red;">public static final String doSomething() {</span></span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Some\$.MODULE\$.doSomething();</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; }</span><br><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; public static final int \$tag() throws RemoteException {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Some\$.MODULE\$.\$tag();</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; }</span><br><span style="font-weight: bold;">}</span><br></div><br>這也是為何你可以在Java中使用Some.doSometing()的原因。然而在有伴侶類別的情況下，所產生的Some類別定義會是：<br><div style="margin-left: 40px;"><span style="font-weight: bold;">import java.rmi.RemoteException;</span><br><span style="font-weight: bold;">import scala.ScalaObject;</span><br><br><span style="font-weight: bold;">public class Some implements ScalaObject {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; public Some() {}</span><br><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; public int \$tag() throws RemoteException {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return scala.ScalaObject.class.\$tag(this);</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; }</span><br><span style="font-weight: bold;">}</span><br></div><br>這也是為什麼，你不可以在Java中使用Some.doSometing()的原因。無論是否有伴侶類別，其實想要在Java中使用Scala單例物件中定義的成員，方式都是：<br><pre class="prettyprint"><code lang="scala">public class Main {  // 這是 Java<br>    public static void main(String[] args) {<br>        Some\$.MODULE\$.doSomething();<br>    }<br>}</code></pre><br>在Scala中若設定建構式為private或其它權限，例如：<br><pre class="prettyprint"><code lang="scala">class Some private {}</code></pre><br>編譯為.class後，基本上建構式也會被標示為相對應的權限，例如.class的定義會是：<br><div style="margin-left: 40px;"><span style="font-weight: bold;">import java.rmi.RemoteException;</span><br><span style="font-weight: bold;">import scala.ScalaObject;</span><br><br><span style="font-weight: bold;">public class Some implements ScalaObject{</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; <span style="color: red;">private</span> Some() {}</span><br><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; public int \$tag() throws RemoteException {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return scala.ScalaObject.class.\$tag(this);</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; }</span><br><span style="font-weight: bold;">}</span><br></div><br>但若出現伴侶物件且嘗試建構物件時，編譯過後的.class，private就不是private了。例如：<br><pre class="prettyprint"><code lang="scala">class Some private {<br>}<br><br>object Some {<br>    def apply = new Some<br>}</code></pre><br>在上例中，Some在編譯過後，其.class的定義會是：<br><div style="margin-left: 40px;"><span style="font-weight: bold;">import java.rmi.RemoteException;</span><br><span style="font-weight: bold;">import scala.ScalaObject;</span><br><br><span style="font-weight: bold;">public class Some implements ScalaObject {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; <span style="color: red;">public</span> Some() {}</span><br><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; public int \$tag() throws RemoteException {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return scala.ScalaObject.class.\$tag(this);</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; }</span><br><span style="font-weight: bold;">}</span><br></div><br>在Scala中有特徵（Trait），特徵可以有實作，在Java中要使用Scala中的特徵所編譯過來的.class，最簡單的方式，是就是在Scala中定義沒有任何實作的特徵，如此編譯過去的.class，就是對應至Java的介面（Interface）。例如：<br><pre class="prettyprint"><code lang="scala">trait Some {<br>    def doIt(a: Any): Any<br>}</code></pre><br>在編譯為.class後，會對應至以下的Java介面：<br><div style="margin-left: 40px;"><span style="font-weight: bold;">public <span style="color: red;">interface</span> Some {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; public abstract Object doIt(Object obj);</span><br><span style="font-weight: bold;">}</span><br></div><br>有實作的特徵在Java中沒有直接對應的語法，可以得到如Scala中直接具有實作特徵的好處。真的要使用具實作的特徵編譯出來的.class還是有辦法的，不過只會讓Java中的程式更為複雜，所以並不鼓勵，這在之後的文件還會介紹。<br><br>Scala的 <a href="TypeParameterization.html">型態參數</a> 對應至Java的泛型（Generic）語法，由於Java並不支援 <a href="Covariance.html">共變性（Covariance）</a> 與 <a href="Contravariance.html">逆變性（Contravariance）</a>，在Scala中如果定義型態參數時標註了正變或逆變，編譯之後的.class是不會包含任何正變、逆變資訊的。例如：<br><pre class="prettyprint"><code lang="scala">class Fruit<br>class Apple extends Fruit<br>class Some[+T]<br>class Util {<br>    val sf: Some[Fruit] = new Some[Apple]<br>}</code></pre><br>編譯之後的.class定義分別如下：<br><div style="margin-left: 40px;"><span style="font-weight: bold;">// Some.class</span><br><span style="font-weight: bold;">import java.rmi.RemoteException;</span><br><span style="font-weight: bold;">import scala.ScalaObject;</span><br><br><span style="font-weight: bold;">public class Some<span style="color: red;">&lt;T&gt;</span> implements ScalaObject {</span><br><span style="font-weight: bold;">&nbsp; public int \$tag() throws RemoteException {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; return ScalaObject.class.\$tag(this);</span><br><span style="font-weight: bold;">&nbsp; }</span><br><span style="font-weight: bold;">}</span><br><span style="font-weight: bold;"></span><br><span style="font-weight: bold;">// Util.class</span><br><span style="font-weight: bold;">import java.rmi.RemoteException;</span><br><span style="font-weight: bold;">import scala.ScalaObject;</span><br><span style="font-weight: bold;"></span><br><span style="font-weight: bold;">public class Util</span><span style="font-weight: bold;"> implements ScalaObject</span><span style="font-weight: bold;"> {</span><br><span style="font-weight: bold;">&nbsp; private final Some<span style="color: red;">&lt;Fruit&gt;</span> sf;</span><br><span style="font-weight: bold;"></span><br><span style="font-weight: bold;">&nbsp; public Util()</span><span style="font-weight: bold;"> {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; this.sf = <span style="color: red;">new Some()</span>; <br>&nbsp;&nbsp;} </span><br><span style="font-weight: bold;">&nbsp; public Some<span style="color: red;">&lt;Fruit&gt;</span> sf() { return this.sf;</span><span style="font-weight: bold;"> }</span><br><span style="font-weight: bold;"></span><br><span style="font-weight: bold;">&nbsp; public int \$tag()</span><span style="font-weight: bold;"> throws RemoteException</span><span style="font-weight: bold;"> {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; return ScalaObject.class.\$tag(this);</span><br><span style="font-weight: bold;">&nbsp; }</span><br><span style="font-weight: bold;">}</span><br><span style="font-weight: bold;"></span></div><br>如果使用了 <a href="ExistentialType.html">既存型態（Existential type）</a>，編譯後的.class，會對應至Java的型態通配字元語法。例如：<br><pre class="prettyprint"><code lang="scala">class Util {<br>    val sf: Some[_ &lt;: Fruit] = new Some[Apple]<br>}</code></pre><br>在編譯為.class後，定義如下：<br><div style="margin-left: 40px;"><span style="font-weight: bold;">import java.rmi.RemoteException;</span><br><span style="font-weight: bold;">import scala.ScalaObject;</span><br><br><span style="font-weight: bold;">public class Util implements ScalaObject {</span><br><span style="font-weight: bold;">&nbsp; private final Some<span style="color: red;">&lt;? extends Fruit&gt;</span> sf;</span><br><br><span style="font-weight: bold;">&nbsp; public Util() {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; this.sf = new Some(); </span><br><span style="font-weight: bold;">&nbsp; } </span><br><span style="font-weight: bold;">&nbsp; public Some<span style="color: red;">&lt;? extends Fruit&gt;</span> sf() { return this.sf; }</span><br><br><span style="font-weight: bold;">&nbsp; public int \$tag() throws RemoteException {</span><br><span style="font-weight: bold;">&nbsp;&nbsp;&nbsp; return ScalaObject.class.\$tag(this);</span><br><span style="font-weight: bold;">&nbsp; }</span><br><span style="font-weight: bold;">}</span><br></div><br>




<br><br><div class="ad336-280" style="text-align: center;"><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 2015 新版型廣告 336 x 280 --><ins class="adsbygoogle" style="display:inline-block;width:336px;height:280px" data-ad-client="ca-pub-9750319131714390" data-ad-slot="9976409681"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div><br><div class="recommend" style="text-align: center;"><hr><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><!-- 自動大小回應相符內容 --><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-9750319131714390" data-ad-slot="4953478487" data-ad-format="autorelaxed"></ins><script>(adsbygoogle = window.adsbygoogle || []).push({});</script></div>

  </article></main></div></body>
<script src="../js/ui.js"></script>
</html>
<div class="analytics"><script async src="https://www.googletagmanager.com/gtag/js?id=G-QVQQYFSC8J"></script><script>window.dataLayer = window.dataLayer || [];function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config', 'G-QVQQYFSC8J');</script></div>
